{
  "language": "Solidity",
  "sources": {
    "contracts/_library/_test/provenance/statemachine/FiniteStateMachineImpl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../../../provenance/statemachine/FiniteStateMachine.sol\";\n\ncontract FiniteStateMachineImpl is FiniteStateMachine {\n  bytes32 public constant STATE_CREATED = \"STATE_CREATED\";\n\n  bytes32[] public _allStates = [STATE_CREATED];\n  bytes32[] public _allRoles;\n\n  StateMachineMeta[] internal _meta;\n\n  struct StateMachineMeta {\n    uint256 index;\n    uint256 amount;\n    string proof;\n    string ipfsFieldContainerHash;\n  }\n\n  constructor(address gateKeeper) Secured(gateKeeper) {}\n\n  function initialState() public pure override returns (bytes32) {\n    return STATE_CREATED;\n  }\n\n  function allStates() public view override returns (bytes32[] memory) {\n    return _allStates;\n  }\n\n  function allRoles() public view override returns (bytes32[] memory) {\n    return _allRoles;\n  }\n\n  function getNextStatesForState(bytes32 state) public view override returns (bytes32[] memory) {}\n\n  function getAllowedRolesForState(bytes32 state) public view override returns (bytes32[] memory) {}\n\n  function getAllowedFunctionsForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  function getPreconditionsForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  function getCallbacksForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  function getCallbackFunctionsForState(bytes32 state)\n    internal\n    override\n    returns (function(uint256, bytes32, bytes32) internal[] memory)\n  {}\n\n  function getPreFunctionForState(bytes32 state) public pure override returns (bytes4) {}\n\n  function getPreconditionFunctionsForState(bytes32 state)\n    internal\n    view\n    override\n    returns (function(uint256, bytes32, bytes32) internal view[] memory)\n  {}\n\n  function preconditionsForState(bytes32 state)\n    internal\n    view\n    returns (function(uint256, bytes32, bytes32) internal view[] memory)\n  {}\n\n  function callbacksForState(bytes32 state) internal returns (function(uint256, bytes32, bytes32) internal[] memory) {}\n\n  function create(\n    uint256 amount,\n    string memory proof,\n    string memory ipfsFieldContainerHash\n  ) public {\n    _registry.push();\n    StateMachine storage sm = _registry[_registry.length - 1];\n    sm.currentState = initialState();\n    sm.createdAt = block.timestamp;\n    sm.index = _registry.length - 1;\n\n    _meta.push();\n    StateMachineMeta storage meta = _meta[_meta.length - 1];\n    meta.amount = amount;\n    meta.proof = proof;\n    meta.ipfsFieldContainerHash = ipfsFieldContainerHash;\n    meta.index = _meta.length - 1;\n  }\n\n  function getByIndex(uint256 index) public view returns (StateMachine memory item, StateMachineMeta memory meta) {\n    item = _registry[index];\n    meta = _meta[index];\n  }\n\n  function getContents() public view returns (StateMachine[] memory registry, StateMachineMeta[] memory meta) {\n    registry = _registry;\n    meta = _meta;\n  }\n}\n"
    },
    "contracts/_library/provenance/statemachine/FiniteStateMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\nimport \"../../utility/syncing/Syncable.sol\";\nimport \"./IFiniteStateMachine.sol\";\n\n/**\n * @title Base contract for state machines\n */\nabstract contract FiniteStateMachine is IFiniteStateMachine, Secured, Syncable {\n  StateMachine[] internal _registry;\n\n  /**\n   * @dev Struct defining a State Machine\n   * @notice Gets decorated with StateMachineMeta\n   */\n  struct StateMachine {\n    uint256 index;\n    bytes32 currentState;\n    Transition[] transitions;\n    uint256 createdAt;\n  }\n\n  /**\n   * @dev Struct defining a transition between states\n   */\n  struct Transition {\n    bytes32 fromState;\n    bytes32 toState;\n    address actor;\n    uint256 timestamp;\n  }\n\n  /**\n   * @notice Returns the length of the state machine registry\n   * @dev Returns the length of the state machine registry\n   * @return length the number of state machines in the registry\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = _registry.length;\n  }\n\n  // Due to a possibly different return type (include meta) this gets implemented in the inheriting contract\n  // function getByIndex(uint index) public view returns (StateMachine memory item) {\n  //   item = _registry[index];\n  // }\n\n  // Due to a possibly different return type (include meta) this gets implemented in the inheriting contract\n  // function getContents() public view returns (StateMachine[] memory registry) {\n  //   registry = _registry;\n  // }\n\n  function getCallbackFunctionsForState(bytes32 state)\n    internal\n    virtual\n    override\n    returns (function(uint256, bytes32, bytes32) internal[] memory);\n\n  /**\n   * @notice Transitions a state machine to a new state\n   * @dev Ensures predefined transition criteria are met before transitioning to a new state.\n   * Executes callbacks. Emits a Transition event after a successful transition.\n   * @param fsmIndex registry index of the transitioning state machine\n   * @param toState identifier of the state to transition to\n   */\n  function transitionState(uint256 fsmIndex, bytes32 toState) public checkTransitionCriteria(fsmIndex, toState) {\n    StateMachine storage stateMachine = _registry[fsmIndex];\n    bytes32 oldState = stateMachine.currentState;\n    stateMachine.currentState = toState;\n\n    function(uint256, bytes32, bytes32) internal[] memory callbacks = getCallbackFunctionsForState(toState);\n    for (uint256 i = 0; i < callbacks.length; i++) {\n      callbacks[i](fsmIndex, oldState, toState);\n    }\n\n    _registry[fsmIndex].transitions.push(\n      Transition({fromState: oldState, toState: toState, actor: msg.sender, timestamp: block.timestamp})\n    );\n\n    emit StateTransition(fsmIndex, msg.sender, oldState, toState);\n  }\n\n  function getNextStatesForState(bytes32 state) public view virtual override returns (bytes32[] memory);\n\n  /**\n   * @notice Checks whether it's possible to transition to the given state\n   * @param fromState identifier of the state from which is being transitioned\n   * @param toState identifier of the state to which is being transitioned to\n   */\n  function checkNextStates(bytes32 fromState, bytes32 toState) internal view returns (bool hasNextState) {\n    bytes32[] memory nextStates = getNextStatesForState(fromState);\n\n    hasNextState = false;\n    for (uint256 i = 0; i < nextStates.length; i++) {\n      if (keccak256(abi.encodePacked(nextStates[i])) == keccak256(abi.encodePacked(toState))) {\n        hasNextState = true;\n        break;\n      }\n    }\n  }\n\n  function getPreconditionFunctionsForState(bytes32 state)\n    internal\n    view\n    virtual\n    override\n    returns (function(uint256, bytes32, bytes32) internal view[] memory);\n\n  /**\n   * @notice Checks all the custom preconditions that determine if it is allowed to transition to a next state\n   * @dev Make sure the preconditions require or assert their checks and have an understandable error message\n   * @param index registry index of the transitioning state machine\n   * @param fromState identifier of the state from which is being transitioned\n   * @param toState identifier of the state to which is being transitioned to\n   */\n  function checkPreConditions(\n    uint256 index,\n    bytes32 fromState,\n    bytes32 toState\n  ) private view {\n    function(uint256, bytes32, bytes32) internal view[] memory preConditions = getPreconditionFunctionsForState(\n      toState\n    );\n\n    for (uint256 i = 0; i < preConditions.length; i++) {\n      preConditions[i](index, fromState, toState);\n    }\n  }\n\n  function getAllowedRolesForState(bytes32 state) public view virtual override returns (bytes32[] memory);\n\n  /**\n   * @notice Checks if the sender has a role that is allowed to transition to a next state\n   * @param toState identifier of the state to which is being transitioned to\n   */\n  function checkAllowedRoles(bytes32 toState) private view returns (bool isAllowed) {\n    bytes32[] memory allowedRoles = getAllowedRolesForState(toState);\n\n    isAllowed = false;\n    if (allowedRoles.length == 0) {\n      isAllowed = true;\n    }\n\n    for (uint256 i = 0; i < allowedRoles.length; i++) {\n      if (canPerform(msg.sender, allowedRoles[i])) {\n        isAllowed = true;\n        break;\n      }\n    }\n  }\n\n  function getAllowedFunctionsForState(bytes32 state) public view virtual override returns (bytes4[] memory);\n\n  /**\n   * @notice Modifier to secure functions for a specific state\n   */\n  modifier checkAllowedFunction(bytes32 state) {\n    bytes4[] memory allowedFunctions = getAllowedFunctionsForState(state);\n\n    bool isAllowed = false;\n    for (uint256 i = 0; i < allowedFunctions.length; i++) {\n      if (allowedFunctions[i] == msg.sig) {\n        isAllowed = true;\n        break;\n      }\n    }\n\n    require(isAllowed, \"this function is not allowed in this state\");\n    _;\n  }\n\n  /**\n   * @notice Modifier that checks if we can trigger a transition between the current state and the next state\n   */\n  modifier checkTransitionCriteria(uint256 index, bytes32 toState) {\n    require(checkNextStates(_registry[index].currentState, toState), \"invalid to state\");\n    require(checkAllowedRoles(toState), \"transition to state not allowed\");\n    checkPreConditions(index, _registry[index].currentState, toState);\n    _;\n  }\n\n  /**\n   * @notice Modifier that checks if a state machine exists\n   */\n  modifier doesStateMachineExists(uint256 index) {\n    require(_registry[index].createdAt > 0, \"state machine does not exist\");\n    _;\n  }\n}\n"
    },
    "contracts/_library/authentication/Secured.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./GateKeeper.sol\";\nimport \"../utility/conversions/Converter.sol\";\n\n/**\n * @title Executes role-based permission checks\n */\ncontract Secured is Converter {\n  GateKeeper public gateKeeper;\n\n  modifier auth(bytes32 _role) {\n    require(canPerform(msg.sender, _role), \"Sender does not have the correct role\");\n    _;\n  }\n\n  modifier authMany(bytes32[] memory _roles) {\n    bool hasRole = false;\n    for (uint256 i = 0; i < _roles.length; i++) {\n      if (canPerform(msg.sender, _roles[i])) {\n        hasRole = true;\n        break;\n      }\n    }\n    require(hasRole == true, \"Sender does not have the correct role\");\n    _;\n  }\n\n  modifier authWithCustomReason(bytes32 _role, string memory reason) {\n    require(canPerform(msg.sender, _role), reason);\n    _;\n  }\n\n  modifier authManyWithCustomReason(bytes32[] memory _roles, string memory reason) {\n    bool hasRole = false;\n    for (uint256 i = 0; i < _roles.length; i++) {\n      if (canPerform(msg.sender, _roles[i])) {\n        hasRole = true;\n        break;\n      }\n    }\n    require(hasRole == true, reason);\n    _;\n  }\n\n  constructor(address _gateKeeper) {\n    gateKeeper = GateKeeper(_gateKeeper);\n  }\n\n  /**\n   * @notice Internal function to check if the address has the required role\n   */\n  function canPerform(address _sender, bytes32 _role) internal view returns (bool) {\n    return address(gateKeeper) == address(0x0) || gateKeeper.hasPermission(_sender, address(this), _role);\n  }\n}\n"
    },
    "contracts/_library/utility/syncing/Syncable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title The listable item should also implement\n */\nabstract contract Syncable {\n  function getIndexLength() public view virtual returns (uint256 length);\n\n  // Waiting for the time we can return structs from functions!\n  // function getByIndex(uint index) constant public returns (address key, bool hasRole){\n  // function getByKey(address _key) constant public returns (address key, bool hasRole){\n\n  // Since ABIEncoderV2 we can now return the entire registry as address list in one call\n  // function getIndex() constant public returns (address[] index) {\n\n  // Since ABIEncoderV2 we can now return the entire registry as an array of structs in one call\n  // function getContents() constant public returns (Struct[] memory items) {\n}\n"
    },
    "contracts/_library/provenance/statemachine/IFiniteStateMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\n/**\n * @title Finite State Machine interface\n */\nabstract contract IFiniteStateMachine {\n  bytes32 public constant FINITE_STATE_MACHINE = \"FINITE_STATE_MACHINE\";\n\n  event StateTransition(uint256 index, address sender, bytes32 fromState, bytes32 toState);\n\n  function initialState() public pure virtual returns (bytes32);\n\n  function allStates() public view virtual returns (bytes32[] memory);\n\n  function allRoles() public view virtual returns (bytes32[] memory);\n\n  // Finite State Machines are described by a set of functions,\n  // opposed to the legacy struct definitions you'll find in StateMachine.sol\n  // This in an attempt to reduce the byte size of our deployed contracts\n  function getNextStatesForState(bytes32 state) public view virtual returns (bytes32[] memory);\n\n  function getAllowedRolesForState(bytes32 state) public view virtual returns (bytes32[] memory);\n\n  function getAllowedFunctionsForState(bytes32 state) public view virtual returns (bytes4[] memory);\n\n  function getPreconditionsForState(bytes32 state) public view virtual returns (bytes4[] memory);\n\n  function getCallbacksForState(bytes32 state) public view virtual returns (bytes4[] memory);\n\n  function getPreFunctionForState(bytes32 state) public pure virtual returns (bytes4);\n\n  // Note that the FSM definitions all return bytes4 method signatures when it defines a list of functions\n  // however for preconditions and callbacks we do need function pointers so define those separately as internal functions\n  function getPreconditionFunctionsForState(bytes32 state)\n    internal\n    view\n    virtual\n    returns (function(uint256, bytes32, bytes32) internal view[] memory);\n\n  function getCallbackFunctionsForState(bytes32 state)\n    internal\n    virtual\n    returns (function(uint256, bytes32, bytes32) internal[] memory);\n}\n"
    },
    "contracts/_library/authentication/GateKeeper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IRoleRegistry.sol\";\n\n/**\n * @title Manages contract permissions\n */\ncontract GateKeeper {\n  bytes32 public constant CREATE_PERMISSIONS_ROLE = bytes32(\"CREATE_PERMISSIONS_ROLE\");\n  bytes32 public constant ADD_ROLEREGISTRY_ROLE = bytes32(\"ADD_ROLEREGISTRY_ROLE\");\n  bytes32 public constant ADD_KNOWNROLE_ROLE = bytes32(\"ADD_KNOWNROLE_ROLE\");\n\n  event SetPermission(address indexed entity, address indexed contractAddress, bytes32 indexed role, bool allowed);\n  event ChangePermissionManager(address indexed contractAddress, bytes32 indexed role, address indexed manager);\n\n  // whether a certain entity has a permission\n  mapping(address => mapping(address => mapping(bytes32 => bool))) permissions;\n  // who is the manager of a permission\n  mapping(address => mapping(bytes32 => address)) permissionManager;\n  // a mapping of roles to the address of their correspending role registry\n  mapping(bytes32 => address) roleToRoleRegistry;\n\n  // a list of all RoleRegistries\n  IRoleRegistry[] roleRegistries;\n\n  bytes32[] public knownRoles;\n  mapping(bytes32 => bool) private knownRole;\n\n  modifier onlyPermissionManager(address _contract, bytes32 role) {\n    require(msg.sender == getPermissionManager(_contract, role), \"Sender is not the permission manager\");\n    _;\n  }\n\n  modifier auth(bytes32 _role) {\n    require(hasPermission(msg.sender, address(this), _role), \"Sender does not have the correct permissions\");\n    _;\n  }\n\n  modifier authMany(bytes32[] memory _roles) {\n    bool hasRole = false;\n    for (uint256 i = 0; i < _roles.length; i++) {\n      if (hasPermission(msg.sender, address(this), _roles[i])) {\n        hasRole = true;\n        break;\n      }\n    }\n    require(hasRole == true, \"Sender does not have the correct permissions\");\n    _;\n  }\n\n  modifier authWithCustomReason(bytes32 _role, string memory reason) {\n    require(hasPermission(msg.sender, address(this), _role), reason);\n    _;\n  }\n\n  modifier authManyWithCustomReason(bytes32[] memory _roles, string memory reason) {\n    bool hasRole = false;\n    for (uint256 i = 0; i < _roles.length; i++) {\n      if (hasPermission(msg.sender, address(this), _roles[i])) {\n        hasRole = true;\n        break;\n      }\n    }\n    require(hasRole == true, reason);\n    _;\n  }\n\n  constructor() {\n    _createPermission(msg.sender, address(this), CREATE_PERMISSIONS_ROLE, msg.sender);\n    _createPermission(msg.sender, address(this), ADD_ROLEREGISTRY_ROLE, msg.sender);\n  }\n\n  /**\n   * @notice Adds an existing role registry to an internal collection.\n   * @dev Adds an existing role registry to an internal collection. Access is limited by the ACL.\n   * @param roleRegistry Address of the role registry to be included\n   */\n  function addRoleRegistry(address roleRegistry) external auth(ADD_ROLEREGISTRY_ROLE) {\n    roleRegistries.push(IRoleRegistry(roleRegistry));\n  }\n\n  /**\n   * @notice Creates a permission that wasn't previously set.\n   * @dev Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_contract` (setting `_manager` as parent).\n   * If a created permission is removed it is possible to reset it with createPermission. Access is limited by the ACL.\n   * @param _entity Address of the whitelisted entity that will be able to perform the role, this can be a user or a role registry\n   * @param _contract Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n   * @param _role Identifier for the group of actions allowed to perform\n   * @param _manager Entity address that will be able to grant and revoke the permission further.\n   */\n  function createPermission(\n    address _entity,\n    address _contract,\n    bytes32 _role,\n    address _manager\n  ) public auth(CREATE_PERMISSIONS_ROLE) {\n    if (!knownRole[_role]) {\n      knownRoles.push(_role);\n      knownRole[_role] = true;\n    }\n\n    _createPermission(_entity, _contract, _role, _manager);\n  }\n\n  /**\n   * @notice Grants a permission if allowed.\n   * @dev Grants `_entity` the ability to perform actions of role `_role` on `_contract`.\n   * This requires `msg.sender` to be the permission manager.\n   * @param _entity Address of the whitelisted entity that will be able to perform the role\n   * @param _contract Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n   * @param _role Identifier for the group of actions allowed to perform\n   */\n  function grantPermission(\n    address _entity,\n    address _contract,\n    bytes32 _role\n  ) public onlyPermissionManager(_contract, _role) {\n    _setPermission(_entity, _contract, _role, true);\n  }\n\n  /**\n   * @notice Revokes permission if allowed.\n   * @dev Revokes `_entity` the ability to perform actions of role `_role` on `_contract`.\n   * This requires `msg.sender` to be the parent of the permission\n   * @param _entity Address of the whitelisted entity that will be revoked access\n   * @param _contract Address of the app in which the role is revoked\n   * @param _role Identifier for the group of actions allowed to perform\n   */\n  function revokePermission(\n    address _entity,\n    address _contract,\n    bytes32 _role\n  ) public onlyPermissionManager(_contract, _role) {\n    _setPermission(_entity, _contract, _role, false);\n  }\n\n  /**\n   * @notice Sets the manager address of a permission on a contract\n   * @dev Sets `_newManager` as the manager of the permission `_role` on `_contract`\n   * This requires `msg.sender` to be the parent of the permission\n   * @param _newManager Address for the new manager\n   * @param _contract Address of the app in which the permission management is being transferred\n   * @param _role Identifier for the group of actions allowed to perform\n   */\n  function setPermissionManager(\n    address _newManager,\n    address _contract,\n    bytes32 _role\n  ) public onlyPermissionManager(_contract, _role) {\n    _setPermissionManager(_newManager, _contract, _role);\n  }\n\n  /**\n   * @notice Get manager address for a permission on a contract\n   * @dev Get manager address for the permission `_role` on `_contract`\n   * @param _contract Contract address\n   * @param _role Role identifier\n   * @return Address of the manager for the permission\n   */\n  function getPermissionManager(address _contract, bytes32 _role) public view returns (address) {\n    return permissionManager[_contract][_role];\n  }\n\n  /**\n   * @notice Lists all the permissions of an entity on a contract address\n   * @dev Lists all permissions for `_entity` on `_contract`\n   * @param _entity Entity address\n   * @param _contract Contract address\n   * @return bytes32[] List of permissions\n   */\n  function permissionsOf(address _entity, address _contract) public view returns (bytes32[] memory) {\n    uint8 counter = 0;\n    bytes32[] memory tmp = new bytes32[](knownRoles.length);\n    for (uint256 i = 0; i < knownRoles.length; i++) {\n      if (hasPermission(_entity, _contract, knownRoles[i])) {\n        tmp[counter] = knownRoles[i];\n        counter += 1;\n      }\n    }\n\n    bytes32[] memory permissionsList = new bytes32[](counter);\n    for (uint256 j = 0; j < counter; j++) {\n      permissionsList[j] = tmp[j];\n    }\n\n    return permissionsList;\n  }\n\n  /**\n   * @notice Checks ACL on kernel or permission status\n   * @dev Checks if `_entity` has permission `_role` on `_contract`\n   * @param _entity Entity address\n   * @param _contract Contract address\n   * @param _role Role identifier\n   * @return Boolean indicating whether the ACL allows the role or not\n   */\n  function hasPermission(\n    address _entity,\n    address _contract,\n    bytes32 _role\n  ) public view returns (bool) {\n    // the address passed in has the permissions themselves\n    bool personalPermission = permissions[_entity][_contract][_role];\n    if (personalPermission) {\n      return personalPermission;\n    }\n    // or we will check if any of the role registries have the permission\n    for (uint256 counter = 0; counter < roleRegistries.length; counter++) {\n      address registry = address(roleRegistries[counter]);\n      bool registryPermission = permissions[registry][_contract][_role];\n      if (registryPermission) {\n        if (roleRegistries[counter].hasRole(_entity)) {\n          return true;\n        }\n      }\n    }\n    // if, not, deny!\n    return false;\n  }\n\n  /**\n   * @notice Retrieves the role registry address for a given role\n   * @dev Retrieves the role registry for the role `_role`\n   * @param _role Identifier for the role mapped to a role registry\n   * @return address of the role registry that corresponds to the role\n   */\n  function getRoleRegistryAddress(bytes32 _role) public view returns (address) {\n    return roleToRoleRegistry[_role];\n  }\n\n  /**\n   * @notice Sets the role registry address for a given role\n   * @dev Sets the role registry for the role `_role` to `_address`. Access is limited by the ACL.\n   * @param _role Identifier for the role mapped to a role registry\n   * @param _address address of the role registry to put into the store\n   */\n  function setRoleRegistryAddress(bytes32 _role, address _address)\n    public\n    authWithCustomReason(ADD_ROLEREGISTRY_ROLE, \"Sender needs ADD_ROLEREGISTRY_ROLE\")\n  {\n    roleToRoleRegistry[_role] = _address;\n\n    if (!knownRole[_role]) {\n      knownRoles.push(_role);\n      knownRole[_role] = true;\n    }\n  }\n\n  /**\n   * @dev Internal createPermission for access inside the gatekeeper (on instantiation)\n   */\n  function _createPermission(\n    address _entity,\n    address _contract,\n    bytes32 _role,\n    address _manager\n  ) internal {\n    require(\n      permissionManager[_contract][_role] == address(0x0),\n      \"only allow permission creation when it has no manager (has not been created before)\"\n    );\n    _setPermission(_entity, _contract, _role, true);\n    _setPermissionManager(_manager, _contract, _role);\n  }\n\n  /**\n   * @dev Internal function called to actually save the permission\n   */\n  function _setPermission(\n    address _entity,\n    address _contract,\n    bytes32 _role,\n    bool _allowed\n  ) internal {\n    permissions[_entity][_contract][_role] = _allowed;\n    emit SetPermission(_entity, _contract, _role, _allowed);\n  }\n\n  /**\n   * @dev Internal function that sets management\n   */\n  function _setPermissionManager(\n    address _newManager,\n    address _contract,\n    bytes32 _role\n  ) internal {\n    require(_newManager > address(0x0), \"_newManager should be a real address\");\n\n    permissionManager[_contract][_role] = _newManager;\n    emit ChangePermissionManager(_contract, _role, _newManager);\n  }\n}\n"
    },
    "contracts/_library/utility/conversions/Converter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\ncontract Converter {\n  function addressToString(address data) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint256 i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint256(uint160(data)) / (2**(8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = char(hi);\n      s[2 * i + 1] = char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) {\n      return bytes1(uint8(b) + 0x30);\n    }\n    return bytes1(uint8(b) + 0x57);\n  }\n\n  function bytes32ToString(bytes32 x) internal pure returns (string memory) {\n    bytes memory bytesString = new bytes(32);\n    uint256 charCount = 0;\n    for (uint256 j = 0; j < 32; j++) {\n      bytes1 charr = bytes1(bytes32(uint256(x) * 2**(8 * j)));\n      if (charr != 0) {\n        bytesString[charCount] = charr;\n        charCount++;\n      }\n    }\n    bytes memory bytesStringTrimmed = new bytes(charCount);\n    for (uint256 k = 0; k < charCount; k++) {\n      bytesStringTrimmed[k] = bytesString[k];\n    }\n    return string(bytesStringTrimmed);\n  }\n\n  function uintToString(uint256 i) internal pure returns (string memory) {\n    unchecked {\n      if (i == 0) {\n        return \"0\";\n      }\n\n      uint256 j = i;\n      uint256 length;\n      while (j != 0) {\n        length++;\n        j /= 10;\n      }\n\n      uint256 ii = i;\n      bytes memory bstr = new bytes(length);\n      uint256 k = length - 1;\n      while (ii != 0) {\n        bstr[k--] = bytes1(uint8(48 + (ii % 10)));\n        ii /= 10;\n      }\n\n      return string(bstr);\n    }\n  }\n}\n"
    },
    "contracts/_library/authentication/interfaces/IRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\n/**\n * @title RoleRegistry\n * @dev The RoleRegistry contract defines the methods and data structures to\n * record if addresses have certain roles or not.\n */\nabstract contract IRoleRegistry {\n  event Designated(address _address);\n  event Discharged(address _address);\n  event RoleRegistryCreated(address _address);\n\n  /**\n   * @dev Checks if an address has a certain role\n   * @param _address The address to check for the role.\n   * @return hasTheRole A boolean that is True if the address has the role.\n   */\n  function hasRole(address _address) public view virtual returns (bool hasTheRole);\n\n  /**\n   * @dev Gives the role to an address\n   * @param _address The address to designate the role to.\n   */\n  function designate(address _address) public virtual;\n\n  /**\n   * @dev Removes the role from an address\n   * @param _address The address to discharge fromn the role.\n   */\n  function discharge(address _address) public virtual;\n}\n"
    },
    "contracts/supplypackage/Package.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\n// Also Rework Roles\n// Duration/Tenperature of an event omitted for simplicity\n// IDEA: A Settings Struct with isMedical, Tilting temperature etc in?\n// Get rid of this hideous code asap\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/FiniteStateMachine.sol\";\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/utility/ui/UIFieldDefinitions.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * @title Package Contract\n */\ncontract Package is FiniteStateMachine, IpfsFieldContainer, FileFieldContainer, UIFieldDefinitions {\n  bytes32 public constant UPGRADEABLE_REGISTRY_TARGET = \"UPGRADEABLE_REGISTRY_TARGET\";\n  bytes32 public constant CREATE_STATEMACHINE_ROLE = \"CREATE_STATEMACHINE_ROLE\";\n\n  /**\n   * Package Events\n   */\n  // Package Created event\n  event StartLoadingEvent(uint256 fsmIndex, eventInfo info);\n  event FinishLoadingEvent(uint256 fsmIndex, eventInfo info);\n  event StartTransportationEvent(uint256 fsmIndex, eventInfo info); //StateSwitch\n  event SentData(uint256 fsmIndex, eventInfo info);\n  event StartChangedCarrier(uint256 fsmIndex, eventInfo info);\n  event FinishChangedCarrier(uint256 fsmIndex, eventInfo info);\n  event ArrivedToWareHouseEvent(uint256 fsmIndex, eventInfo info);\n  event ArrivedToEndUserEvent(uint256 fsmIndex, eventInfo info);\n\n  event PackageTiltingEvent(uint256 fsmIndex, eventInfo info);\n  event CoolingMalfunctionEvent(uint256 fsmIndex, eventInfo info);\n\n  //Duration todo\n  event TrafficJamEvent(uint256 fsmIndex, eventInfo info);\n  event ItMalfunctionEvent(uint256 fsmIndex, eventInfo info);\n\n  event CheckSmartContractEvent(uint256 fsmIndex, eventInfo info, packageIssue[] issues); //, packageIssue[] issues);\n\n  /**\n   * @dev State Constants -> Possible DelayState?\n   *\n   * STATE_PACKAGE_LOADED = the Package is added, possibly with missing info\n   * STATE_PACKAGE_IN_TRANSIT =\n   * STATE_ARRIVED_TO_WAREHOUS =\n   * STATE_PACKAGE_CHANGED_CAR =\n   * STATE_ARRIVED_TO_END_USER =\n   */\n\n  //Change State names\n  bytes32 private constant STATE_PACKAGE_LOADED = \"PACKAGE_LOADED\";\n  bytes32 private constant STATE_PACKAGE_IN_TRANSIT = \"PACKAGE_IN_TRANSIT\";\n  bytes32 private constant STATE_ARRIVED_TO_WAREHOUSE = \"ARRIVED_TO_WAREHOUSE\";\n  bytes32 private constant STATE_PACKAGE_CHANGED_CARRIER = \"PACKAGE_CHANGED_CARRIER\";\n  bytes32 private constant STATE_ARRIVED_TO_END_USER = \"ARRIVED_TO_END_USER\";\n\n  /*\n   * Role Constants\n   */\n  bytes32 private constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 private constant ROLE_USER = \"ROLE_USER\";\n\n  /**\n   * Package states\n   */\n  bytes32[] public _allStates = [\n    STATE_PACKAGE_LOADED,\n    STATE_PACKAGE_IN_TRANSIT,\n    STATE_ARRIVED_TO_WAREHOUSE,\n    STATE_PACKAGE_CHANGED_CARRIER,\n    STATE_ARRIVED_TO_END_USER\n  ];\n\n  /**\n   * Package roles\n   */\n  bytes32[] public _allRoles = [ROLE_ADMIN, ROLE_USER];\n\n  /**\n   * @dev Package helper role collection\n   * specifies anyone who can edit an exponse\n   */\n  bytes32[] private _canEdit = [ROLE_ADMIN, ROLE_USER];\n\n  /**\n   * The address of the upgradeable registry this contract belongs to.\n   * Note that both this property together with the UPGRADEABLE_REGISTRY_TARGET const define a contract\n   * that is part of an upgradeable registry and provides the link to the registry if required.\n   */\n  address public _upgradeableRegistry;\n\n  /**\n   * Package Specific types\n   *\n   *\n   *\n   */\n\n  enum IssueType {\n    trafficJam,\n    coolingMalfunction,\n    tilting,\n    itMalfunction\n  }\n  // => casing in enums google\n  struct packageIssue {\n    IssueType issue;\n    uint256 timestamp;\n  }\n\n  /**\n   * @dev StateMachineMeta contains meta data for every StateMachine - seeing as struct are not composable\n   * and the base StateMachine struct is defined in the FiniteStateMachine abstract there's no other\n   * way to compose structs than having two separte arrays where the indices match.\n   *\n   * @dev Mint is aware of the above and will zip these two into a single struct so statemachines\n   * from the outside will look as a composition of both StateMachine and StateMachineMeta structs.\n   */\n  StateMachineMeta[] internal _meta;\n\n  /**\n   * @dev The index is a collection of DIDs for every state machine in the registry\n   * Usually the getIndex call returns a list of contract addresses however as FSMs are\n   * uniquely identified by their DID we return those instead\n   */\n  string[] internal _index;\n\n  /**\n   * @dev Struct defining an Package\n   * @notice Gets decorated together with the StateMachine structs and forms the Package FSM\n   */\n  struct StateMachineMeta {\n    string DID;\n    string name;\n    string comment;\n    bool isMedical;\n    bool tiltable;\n    bool temperatureIgnored; //Smaller type maybe? //skip fn\n    uint256 temperatureThreshold; //currently string ???\n    packageIssue[] issues;\n    string currentCarrier;\n    uint256 start;\n    uint256 temperature;\n    string[] gpsLocations; // lat, long\n    address owner;\n    string ipfsFieldContainerHash;\n  }\n\n  constructor(address gateKeeper, address registry) Secured(gateKeeper) {\n    require(registry != address(0x0), \"registry can not be zero\");\n    _upgradeableRegistry = registry;\n  }\n\n  //////\n  // FSM Definition Functions\n  //////\n\n  /**\n   * @notice Returns initial state\n   */\n  function initialState() public pure override returns (bytes32) {\n    return STATE_PACKAGE_LOADED;\n  }\n\n  /**\n   * @notice Returns all possible states\n   */\n  function allStates() public view override returns (bytes32[] memory) {\n    return _allStates;\n  }\n\n  /**\n   * @notice Returns all possible roles\n   */\n  function allRoles() public view override returns (bytes32[] memory) {\n    return _allRoles;\n  }\n\n  /**\n   * @notice Retrieve all possible next states for a certain state\n   * @param state state\n   */\n  function getNextStatesForState(bytes32 state) public view override returns (bytes32[] memory test) {\n    bytes32[] memory states;\n\n    if (state == STATE_PACKAGE_LOADED) {\n      states = new bytes32[](1);\n      states[0] = STATE_PACKAGE_IN_TRANSIT;\n    }\n\n    if (state == STATE_PACKAGE_IN_TRANSIT) {\n      states = new bytes32[](2);\n      states[0] = STATE_ARRIVED_TO_WAREHOUSE;\n      states[1] = STATE_ARRIVED_TO_END_USER;\n    }\n\n    if (state == STATE_ARRIVED_TO_WAREHOUSE) {\n      states = new bytes32[](1);\n      states[0] = STATE_PACKAGE_CHANGED_CARRIER;\n    }\n\n    if (state == STATE_PACKAGE_CHANGED_CARRIER) {\n      states = new bytes32[](1);\n      states[0] = STATE_PACKAGE_IN_TRANSIT;\n    }\n\n    return states;\n  }\n\n  /**\n   * @notice Retrieve all roles that are allowed to move it to the given state\n   * @param state state\n   * TODO: Roles\n   */\n  function getAllowedRolesForState(bytes32 state) public view override returns (bytes32[] memory) {\n    bytes32[] memory roles;\n\n    if (state == STATE_PACKAGE_LOADED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    if (state == STATE_PACKAGE_IN_TRANSIT) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    if (state == STATE_ARRIVED_TO_WAREHOUSE) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    if (state == STATE_PACKAGE_CHANGED_CARRIER) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    if (state == STATE_ARRIVED_TO_END_USER) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    return roles;\n  }\n\n  /**\n   * @notice Returns method signatures for functions which are allowed to execute in the given state\n   * @param state state\n   */\n  function getAllowedFunctionsForState(bytes32 state) public view override returns (bytes4[] memory) {\n    bytes4[] memory functions;\n\n    if (state == STATE_PACKAGE_LOADED) {\n      functions = new bytes4[](3);\n      functions[0] = this.startLoadingTruck.selector;\n      functions[1] = this.finishLoadingTruck.selector;\n      functions[2] = this.edit.selector; //edit function only here?\n    }\n\n    if (state == STATE_PACKAGE_IN_TRANSIT) {\n      functions = new bytes4[](6);\n      functions[0] = this.setPackageTilting.selector;\n      functions[1] = this.setCoolingMalfunction.selector;\n      functions[2] = this.setTrafficJam.selector;\n      functions[3] = this.sendData.selector;\n      functions[4] = this.arrivedToWarehouse.selector;\n      functions[5] = this.arrivedToEndUser.selector;\n    }\n\n    if (state == STATE_ARRIVED_TO_WAREHOUSE) {\n      functions = new bytes4[](2);\n      functions[0] = this.startChangeCarrier.selector;\n      functions[1] = this.setItMalfunction.selector;\n    }\n\n    if (state == STATE_PACKAGE_CHANGED_CARRIER) {\n      functions = new bytes4[](2);\n      functions[0] = this.finishChangeCarrier.selector;\n      functions[1] = this.setItMalfunction.selector;\n    }\n\n    if (state == STATE_ARRIVED_TO_END_USER) {\n      functions = new bytes4[](1);\n      functions[0] = this.checkSmartContract.selector;\n    }\n\n    return functions;\n  }\n\n  /**\n   * @notice Returns method signatures for functions that act as preconditions that must be met in order to transition to the given state\n   * @param state state\n   */\n  function getPreconditionsForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that will get called after transitioning to the given state\n   * @param state state\n   */\n  function getCallbacksForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that need to be called before transitioning to the given state\n   * @param state state\n   */\n  function getPreFunctionForState(bytes32 state) public pure override returns (bytes4) {}\n\n  //////\n  // UI Field Definition Functions\n  //////\n\n  /**\n   * @notice Set the UI field definition hash\n   * @param uiFieldDefinitionsHash IPFS hash containing the UI field definitions JSON\n   */\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash)\n    public\n    override\n    authWithCustomReason(UPDATE_UIFIELDDEFINITIONS_ROLE, \"Sender needs UPDATE_UIFIELDDEFINITIONS_ROLE\")\n  {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  /**\n   * @notice Returns the UI field definition hash\n   */\n  function getUIFieldDefinitionsHash() public view override returns (string memory) {\n    return _uiFieldDefinitionsHash;\n  }\n\n  //////\n  // Factory Functions => Rework wit hupdated stm\n  //////\n\n  /**\n   * @notice Create a new statemachine\n   * @param name Package type\n   * @param comment is the package tiltable\n   * @param isMedical is the package medical\n   * @param temperatureIgnored is the temp ignores\n   * @param temperatureThreshold tresh\n   * @param ipfsFieldContainerHash IPFS hash df the metadata fields\n   * @param owner Package owner\n   */\n  function create(\n    string memory name,\n    string memory comment,\n    bool isMedical,\n    bool tiltable,\n    bool temperatureIgnored,\n    uint256 temperatureThreshold,\n    string memory ipfsFieldContainerHash,\n    address owner\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    _registry.push();\n    StateMachine storage sm = _registry[_registry.length - 1];\n    sm.currentState = initialState();\n    sm.createdAt = block.timestamp;\n    sm.index = _registry.length - 1;\n    //This registry later?\n\n    _meta.push();\n    StateMachineMeta storage meta = _meta[_meta.length - 1];\n    meta.name = name;\n    meta.comment = comment;\n    meta.isMedical = isMedical;\n    meta.tiltable = tiltable;\n    meta.temperatureIgnored = temperatureIgnored;\n    meta.temperatureThreshold = temperatureThreshold;\n    meta.currentCarrier = \"Carrier One\";\n    meta.ipfsFieldContainerHash = ipfsFieldContainerHash;\n    meta.owner = owner;\n    meta.DID = generateDID(_meta.length - 1);\n\n    _index.push();\n    _index[_index.length - 1] = meta.DID;\n\n    //emit PackageCreated(sm.index, owner, _upgradeableRegistry); //Event maken\n  }\n\n  /**\n   * @notice Edit an existing statemachine\n   * @param name Package type\n   * @param comment is the package tiltable\n   * @param isMedical is the package tiltable\n   * @param temperatureIgnored is the temp ignores\n   * @param temperatureThreshold tresh\n   * @param ipfsFieldContainerHash IPFS hash df the metadata fields\n   */\n  function edit(\n    uint256 fsmIndex,\n    string memory name,\n    string memory comment,\n    bool isMedical,\n    bool tiltable,\n    bool temperatureIgnored,\n    uint256 temperatureThreshold,\n    string memory ipfsFieldContainerHash\n  )\n    public\n    //authManyWithCustomReason(_canEdit, 'Edit requires one of roles: ROLE_ADMIN')\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    // Verify input (copy paste of validations  we perform in the factory)\n    //require(amount > 0, 'The amount of an Package cannot be zero');\n    // require(bytes(packageName).length > 0, 'A packageName is required for all Packages');\n\n    _meta[fsmIndex].name = name;\n    _meta[fsmIndex].comment = comment;\n    _meta[fsmIndex].isMedical = isMedical; //Enum Maybe toch niet\n    _meta[fsmIndex].tiltable = tiltable;\n    _meta[fsmIndex].temperatureIgnored = temperatureIgnored;\n    _meta[fsmIndex].temperatureThreshold = temperatureThreshold;\n    _meta[fsmIndex].ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  //////\n  // Syncable Functions\n  //////\n\n  /**\n   * @notice Returns the structs composing a statemachine for given index\n   * @param fsmIndex state machine index\n   */\n  function getByIndex(uint256 fsmIndex) public view returns (StateMachine memory item, StateMachineMeta memory meta) {\n    item = _registry[fsmIndex];\n    meta = _meta[fsmIndex];\n  }\n\n  /**\n   * @notice Returns all state machines structs in a single fetch\n   */\n  function getContents() public view returns (StateMachine[] memory registry, StateMachineMeta[] memory meta) {\n    registry = _registry;\n    meta = _meta;\n  }\n\n  /**\n   * @notice Returns the (DID) index\n   */\n  function getIndex() public view returns (string[] memory index) {\n    return _index;\n  }\n\n  //////\n  // Package Functions\n  //////\n\n  struct eventInfo {\n    string name;\n    string carrier;\n    uint256 time;\n    string lat;\n    string long;\n    uint256 temp;\n  }\n\n  /**\n   * @notice StartLoading Truck\n   * @param fsmIndex state machine index\n   */\n  function startLoadingTruck(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.start = time;\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    eventInfo memory info = eventInfo({\n      name: \"START LOADING\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit StartLoadingEvent(fsmIndex, info); //carrier?\n  }\n\n  //Which functions does Package need?\n  /**\n   * @notice finish Loading Truck\n   * @param fsmIndex state machine index\n   * @param time start time of the loading\n   *\n   */\n  function finishLoadingTruck(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    eventInfo memory info = eventInfo({\n      name: \"FINISH LOADING\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit FinishLoadingEvent(fsmIndex, info); //carrier?\n    transitionState(fsmIndex, STATE_PACKAGE_IN_TRANSIT);\n  }\n\n  /**\n   * @notice setPackageTilting\n   * @param fsmIndex state machine index\n   * @param time start time of the loading\n   *\n   */\n\n  function setPackageTilting(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    meta.issues.push(packageIssue({issue: IssueType.tilting, timestamp: time}));\n    eventInfo memory info = eventInfo({\n      name: \"PACKAGE TILTING\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n\n    emit PackageTiltingEvent(fsmIndex, info);\n  }\n\n  /**\n   * @notice setCoolingMalfunction\n   * @param fsmIndex state machine index\n   * @param time start time of the loading\n   *\n   */\n\n  function setCoolingMalfunction(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long,\n    uint256 temp\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    meta.issues.push(packageIssue({issue: IssueType.coolingMalfunction, timestamp: time}));\n    meta.temperature = temp;\n    eventInfo memory info = eventInfo({\n      name: \"COOLING MALFUNCTION\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: temp\n    });\n    emit CoolingMalfunctionEvent(fsmIndex, info);\n  }\n\n  /**\n   * @notice itMalfunction function\n   * @param fsmIndex state machine index\n   * @param time start time of the loading\n   *\n   */\n\n  function setItMalfunction(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    meta.issues.push(packageIssue({issue: IssueType.itMalfunction, timestamp: time}));\n    eventInfo memory info = eventInfo({\n      name: \"IT MALFUNCTION\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit ItMalfunctionEvent(fsmIndex, info);\n  }\n\n  /**\n   * @notice finish Loading Truck event\n   * @param fsmIndex state machine index\n   */\n\n  function setTrafficJam(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    meta.issues.push(packageIssue({issue: IssueType.trafficJam, timestamp: time}));\n    eventInfo memory info = eventInfo({\n      name: \"TRAFFIC JAM\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit TrafficJamEvent(fsmIndex, info);\n  }\n\n  /**\n   * @notice finish Loading Truck event\n   * @param fsmIndex state machine index\n   * @param time time\n   *\n   */\n\n  function sendData(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long,\n    uint256 temp\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    meta.temperature = temp;\n    eventInfo memory info = eventInfo({\n      name: \"SENT DATA\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: temp\n    });\n    emit SentData(fsmIndex, info);\n  }\n\n  /**\n   * @notice finish Loading Truck event\n   * @param fsmIndex state machine index\n   * @param time time\n   */\n\n  function arrivedToWarehouse(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.gpsLocations = new string[](2);\n    meta.gpsLocations[0] = lat;\n    meta.gpsLocations[1] = long;\n    eventInfo memory info = eventInfo({\n      name: \"ARRIVED TO WAREHOUSE\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit ArrivedToWareHouseEvent(fsmIndex, info);\n    transitionState(fsmIndex, STATE_ARRIVED_TO_WAREHOUSE);\n  }\n\n  /**\n   * @notice finish Loading Truck event\n   * @param fsmIndex state machine index\n   * @param time time\n   *\n   */\n\n  function arrivedToEndUser(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    eventInfo memory info = eventInfo({\n      name: \"ARRIVED TO ENDUSER\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit ArrivedToEndUserEvent(fsmIndex, info);\n    transitionState(fsmIndex, STATE_ARRIVED_TO_END_USER);\n  }\n\n  /**\n   * @notice finish Loading Truck event\n   * @param fsmIndex state machine index\n   * @param time time\n   *\n   */\n\n  function startChangeCarrier(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long,\n    string memory newCarrier\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.currentCarrier = newCarrier;\n    eventInfo memory info = eventInfo({\n      name: \"START CHANGE CARRIER\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit StartChangedCarrier(fsmIndex, info); // new Carrier\n    transitionState(fsmIndex, STATE_PACKAGE_CHANGED_CARRIER);\n  }\n\n  /**\n   * @notice finishChangeCarrier\n   * @param fsmIndex state machine index\n   * @param time time\n   *\n   */\n  function finishChangeCarrier(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    eventInfo memory info = eventInfo({\n      name: \"FINISH CHANGE CARRIER\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit FinishChangedCarrier(fsmIndex, info);\n    transitionState(fsmIndex, STATE_PACKAGE_IN_TRANSIT);\n  }\n\n  /**\n   * @notice checkSmartContract\n   * @param fsmIndex state machine index\n   * @param time time\n   *\n   */\n  function checkSmartContract(\n    uint256 fsmIndex,\n    uint256 time,\n    string memory lat,\n    string memory long\n  ) public doesStateMachineExists(fsmIndex) checkAllowedFunction(_registry[fsmIndex].currentState) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    //issues??\n    eventInfo memory info = eventInfo({\n      name: \"CHECK SMARTCONTRACT\",\n      carrier: meta.currentCarrier,\n      time: time,\n      lat: lat,\n      long: long,\n      temp: meta.temperature\n    });\n    emit CheckSmartContractEvent(fsmIndex, info, meta.issues); //order them right?\n  }\n\n  /**\n   * @notice Returns the preconditions for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the precondition function\n   */\n  function getPreconditionFunctionsForState(bytes32 state)\n    internal\n    view\n    override\n    returns (function(uint256, bytes32, bytes32) view[] memory)\n  {}\n\n  /**\n   * @notice Returns the callbacks for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the callback function\n   */\n  function getCallbackFunctionsForState(bytes32 state)\n    internal\n    override\n    returns (function(uint256, bytes32, bytes32) internal[] memory)\n  {}\n\n  //////\n  // Helper Functions\n  //////\n\n  /**\n   * @notice Generate state machine DID\n   * @param fsmIndex state machine index\n   */\n  function generateDID(uint256 fsmIndex) internal view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:package:0x\", addressToString(address(this)), \":\", uintToString(fsmIndex)));\n  }\n}\n"
    },
    "contracts/_library/utility/ui/UIFieldDefinitions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\n// solium-disable mixedcase\npragma solidity ^0.8.0;\n\nabstract contract UIFieldDefinitions {\n  bytes32 public constant UPDATE_UIFIELDDEFINITIONS_ROLE = \"UPDATE_UIFIELDDEFINITIONS_ROLE\";\n  string internal _uiFieldDefinitionsHash;\n\n  function getUIFieldDefinitionsHash() public view virtual returns (string memory);\n\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash) public virtual;\n}\n"
    },
    "contracts/_library/utility/metadata/IpfsFieldContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\ncontract IpfsFieldContainer {\n  bytes32 public constant UPDATE_IPFSCONTAINERHASH_ROLE = \"UPDATE_IPFSCONTAINERHASH_ROLE\";\n  string public _ipfsFieldContainerHash;\n\n  function getIpfsFieldContainerHash() public view virtual returns (string memory) {\n    return _ipfsFieldContainerHash;\n  }\n\n  function setIpfsFieldContainerHash(string memory ipfsFieldContainerHash) public virtual {\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n}\n"
    },
    "contracts/_library/utility/metadata/FileFieldContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\ncontract FileFieldContainer {\n  bytes32[] internal _fileKeys;\n  mapping(bytes32 => bool) internal _knownFileKeys;\n  mapping(bytes32 => string) internal _fileFieldsMap;\n\n  function setContractFile(bytes32 key, string memory file) public {\n    if (!_knownFileKeys[key]) {\n      _fileKeys.push(key);\n      _knownFileKeys[key] = true;\n    }\n\n    _fileFieldsMap[key] = file;\n  }\n}\n"
    },
    "contracts/vehicle/Vehicle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * Vehicle\n *\n * A verhicle package exists of\n *  - a description of the verhicle where a vehicle is a device that is designed or\n *    used to transport people or cargo over land, water, air, or through space and the\n *    schema for it as defined by https://schema.org/Vehicle\n *  - a VIN number of the individual vehicle modified to fit the Decentralized ID\n *    standard defined here: https://w3c-ccg.github.io/did-spec/\n *\n * @title State machine to track a vehicle\n */\ncontract Vehicle is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_VIN_REGISTERED = \"STATE_VIN_REGISTERED\";\n  bytes32 public constant STATE_CAR_MANUFACTURED = \"STATE_CAR_MANUFACTURED\";\n  bytes32 public constant STATE_CAR_IMPORTED = \"STATE_CAR_IN_COUNTRY\";\n  bytes32 public constant STATE_LICENSE_PLATE_ASSIGNED = \"STATE_LICENSE_PLATE_ASSIGNED\";\n  bytes32 public constant STATE_VEHICLE_IN_OPERATION = \"STATE_VEHICLE_IN_OPERATION\";\n  bytes32 public constant STATE_VEHICLE_IMPOUNDED = \"STATE_VEHICLE_IMPOUNDED\";\n  bytes32 public constant STATE_VEHICLE_SCRAPPED = \"STATE_VEHICLE_SCRAPPED\";\n  bytes32 public constant STATE_VEHICLE_EXPORTED = \"STATE_VEHICLE_EXPORTED\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_MANUFACTURER = \"ROLE_MANUFACTURER\";\n  bytes32 public constant ROLE_AGENT = \"ROLE_AGENT\";\n  bytes32 public constant ROLE_REGULATOR = \"ROLE_REGULATOR\";\n  bytes32 public constant ROLE_USER = \"ROLE_USER\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_MANUFACTURER, ROLE_AGENT, ROLE_REGULATOR, ROLE_USER];\n\n  string public _uiFieldDefinitionsHash;\n  string private _vin;\n  address _owner;\n  uint256 private _mileage;\n\n  constructor(\n    address gateKeeper,\n    string memory vin,\n    address owner,\n    uint256 mileage,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _vin = vin;\n    _owner = owner;\n    _mileage = mileage;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  /**\n   * @notice Updates expense properties\n   * @param vin the vehicle's updated Vehicle Identification Number\n   * @param owner the vehicle's new owner\n   * @param mileage the vehicle's updated mileage\n   * @param ipfsFieldContainerHash ipfs hash of vehicle metadata\n   */\n  function edit(\n    string memory vin,\n    address owner,\n    uint256 mileage,\n    string memory ipfsFieldContainerHash\n  ) public {\n    _vin = vin;\n    _owner = owner;\n    _mileage = mileage;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns a DID of the vehicle\n   * @dev Returns a unique DID (Decentralized Identifier) for the vehicle.\n   * @return string representing the DID of the vehicle\n   */\n  function DID() public view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:vehicle:\", _vin));\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n    createState(STATE_VIN_REGISTERED);\n    createState(STATE_CAR_MANUFACTURED);\n    createState(STATE_CAR_IMPORTED);\n    createState(STATE_LICENSE_PLATE_ASSIGNED);\n    createState(STATE_VEHICLE_IN_OPERATION);\n    createState(STATE_VEHICLE_IMPOUNDED);\n    createState(STATE_VEHICLE_EXPORTED);\n    createState(STATE_VEHICLE_SCRAPPED);\n\n    // add properties\n    // STATE_VEHICLE_REGISTERED\n    addNextStateForState(STATE_VIN_REGISTERED, STATE_CAR_MANUFACTURED);\n\n    // STATE_VEHICLE_REGISTERED\n    addRoleForState(STATE_CAR_MANUFACTURED, ROLE_ADMIN);\n    addRoleForState(STATE_CAR_MANUFACTURED, ROLE_MANUFACTURER);\n    addNextStateForState(STATE_CAR_MANUFACTURED, STATE_CAR_IMPORTED);\n    addNextStateForState(STATE_CAR_MANUFACTURED, STATE_LICENSE_PLATE_ASSIGNED);\n\n    // STATE_VEHICLE_REGISTERED\n    addRoleForState(STATE_CAR_IMPORTED, ROLE_ADMIN);\n    addRoleForState(STATE_CAR_IMPORTED, ROLE_MANUFACTURER);\n    addRoleForState(STATE_CAR_IMPORTED, ROLE_AGENT);\n    addRoleForState(STATE_CAR_IMPORTED, ROLE_REGULATOR);\n    addNextStateForState(STATE_CAR_IMPORTED, STATE_LICENSE_PLATE_ASSIGNED);\n\n    // STATE_VEHICLE_REGISTERED\n    addRoleForState(STATE_LICENSE_PLATE_ASSIGNED, ROLE_ADMIN);\n    addRoleForState(STATE_LICENSE_PLATE_ASSIGNED, ROLE_AGENT);\n    addRoleForState(STATE_LICENSE_PLATE_ASSIGNED, ROLE_REGULATOR);\n    addNextStateForState(STATE_LICENSE_PLATE_ASSIGNED, STATE_VEHICLE_IN_OPERATION);\n\n    // STATE_VEHICLE_IN_OPERATION\n    addRoleForState(STATE_VEHICLE_IN_OPERATION, ROLE_ADMIN);\n    addRoleForState(STATE_VEHICLE_IN_OPERATION, ROLE_REGULATOR);\n    addNextStateForState(STATE_VEHICLE_IN_OPERATION, STATE_VEHICLE_SCRAPPED);\n    addNextStateForState(STATE_VEHICLE_IN_OPERATION, STATE_VEHICLE_EXPORTED);\n    addNextStateForState(STATE_VEHICLE_IN_OPERATION, STATE_VEHICLE_IMPOUNDED);\n\n    // STATE_VEHICLE_IN_OPERATION\n    addRoleForState(STATE_VEHICLE_SCRAPPED, ROLE_ADMIN);\n    addRoleForState(STATE_VEHICLE_SCRAPPED, ROLE_AGENT);\n    addRoleForState(STATE_VEHICLE_SCRAPPED, ROLE_REGULATOR);\n\n    // STATE_VEHICLE_IN_OPERATION\n    addRoleForState(STATE_VEHICLE_EXPORTED, ROLE_ADMIN);\n    addRoleForState(STATE_VEHICLE_EXPORTED, ROLE_AGENT);\n    addRoleForState(STATE_VEHICLE_EXPORTED, ROLE_REGULATOR);\n\n    addRoleForState(STATE_VEHICLE_IMPOUNDED, ROLE_ADMIN);\n    addRoleForState(STATE_VEHICLE_IMPOUNDED, ROLE_REGULATOR);\n    addNextStateForState(STATE_LICENSE_PLATE_ASSIGNED, STATE_VEHICLE_IN_OPERATION);\n\n    setInitialState(STATE_VIN_REGISTERED);\n  }\n}\n"
    },
    "contracts/_library/provenance/statemachine/StateMachine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contcontact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\n\n/**\n * @title Base contract for state machines\n */\nabstract contract StateMachine is Secured {\n  event Transition(address sender, bytes32 fromState, bytes32 toState);\n\n  struct State {\n    // a boolean to check if the state is actually created\n    bool hasBeenCreated;\n    // a mapping of functions that can be executed when in this state\n    mapping(bytes4 => bool) allowedFunctions;\n    // a list of all the roles that have been configured for this state\n    bytes32[] allowedRoles;\n    // a list of all the preconditions that have been configured for this state\n    function(bytes32, bytes32) internal view[] preConditions;\n    // a list of callbacks to execute before the state transition completes\n    function(bytes32, bytes32) internal[] callbacks;\n    // a list of states that can be transitioned to\n    bytes32[] nextStates;\n    // function that executes logic and then does a StateTransition\n    bytes4 preFunction;\n  }\n\n  struct StateTransition {\n    bytes32 fromState;\n    bytes32 toState;\n    address actor;\n    uint256 timestamp;\n  }\n\n  StateTransition[] public history;\n\n  mapping(bytes32 => State) internal states;\n  bytes32[] internal possibleStates;\n  bytes32 internal currentState;\n\n  // a list of selectors that might be allowed functions\n  bytes4[] internal knownSelectors;\n  mapping(bytes4 => bool) internal knownSelector;\n\n  /**\n   * @notice Modifier to ensure the statemachine was setup\n   */\n  modifier checkStateMachineSetup() {\n    require(possibleStates.length > 0, \"this statemachine has not been setup yet\");\n    _;\n  }\n\n  /**\n   * @notice Modifier to secure functions for a specific state\n   */\n  modifier checkAllowedFunction() {\n    require(states[currentState].allowedFunctions[msg.sig], \"this function is not allowed in this state\");\n    _;\n  }\n\n  /**\n   * @notice Modifier that checks if we can trigger a transition between the current state and the next state\n   */\n  modifier checkTransitionCriteria(bytes32 toState) {\n    checkAllTransitionCriteria(getCurrentState(), toState);\n    _;\n  }\n\n  modifier doesStateExist(bytes32 state) {\n    require(states[state].hasBeenCreated, \"the state has not been created yet\");\n    _;\n  }\n\n  /**\n   * @notice Returns the length of the history\n   */\n  function getHistoryLength() public view returns (uint256) {\n    return history.length;\n  }\n\n  /**\n   * @notice Returns history as tuple for given index.\n   * @dev Requires the index to be within the bounds of the history array\n   */\n  function getHistory(uint256 index)\n    public\n    view\n    returns (\n      bytes32 fromState,\n      bytes32 toState,\n      address actor,\n      uint256 timestamp\n    )\n  {\n    require(index >= 0 && index < history.length, \"Index out of bounds\");\n    return (history[index].fromState, history[index].toState, history[index].actor, history[index].timestamp);\n  }\n\n  /**\n   * @notice Returns the name of the current state of this object.\n   * @dev Requires the current state to be configured before calling this function\n   */\n  function getCurrentState() public view returns (bytes32 state) {\n    require(states[currentState].hasBeenCreated, \"the initial state has not been created yet\");\n    return currentState;\n  }\n\n  /**\n   * @notice Returns a list of all the possible states of this object.\n   */\n  function getAllStates() public view returns (bytes32[] memory allStates) {\n    return possibleStates;\n  }\n\n  /**\n   * @notice Returns a list of all the possible next states of the current state.\n   */\n  function getNextStates() public view returns (bytes32[] memory nextStates) {\n    return states[currentState].nextStates;\n  }\n\n  /**\n   * @notice Returns state as tuple for give state.\n   */\n  function getState(bytes32 state)\n    public\n    view\n    returns (\n      bytes32 name,\n      bytes32[] memory nextStates,\n      bytes32[] memory allowedRoles,\n      bytes4[] memory allowedFunctions,\n      bytes4 preFunction\n    )\n  {\n    State storage s = states[state]; // copy to memory\n\n    uint8 counter = 0;\n    bytes4[] memory tmp = new bytes4[](knownSelectors.length);\n    for (uint256 i = 0; i < knownSelectors.length; i++) {\n      if (states[state].allowedFunctions[knownSelectors[i]]) {\n        tmp[counter] = knownSelectors[i];\n        counter += 1;\n      }\n    }\n\n    bytes4[] memory selectors = new bytes4[](counter);\n    for (uint256 j = 0; j < counter; j++) {\n      selectors[j] = tmp[j];\n    }\n\n    return (state, s.nextStates, s.allowedRoles, selectors, s.preFunction);\n  }\n\n  /**\n   * @notice Transitions the state and executes all callbacks.\n   * @dev Emits a Transition event after a successful transition.\n   */\n  function transitionState(bytes32 toState) public checkStateMachineSetup checkTransitionCriteria(toState) {\n    bytes32 oldState = currentState;\n    currentState = toState;\n\n    function(bytes32, bytes32) internal[] storage callbacks = states[toState].callbacks;\n    for (uint256 i = 0; i < callbacks.length; i++) {\n      callbacks[i](oldState, toState);\n    }\n\n    history.push(\n      StateTransition({fromState: oldState, toState: toState, actor: msg.sender, timestamp: block.timestamp})\n    );\n\n    emit Transition(msg.sender, oldState, currentState);\n  }\n\n  /**\n   * @dev Abstract function to setup te state machine configuration\n   */\n  function setupStateMachine() internal virtual;\n\n  function createState(bytes32 stateName) internal {\n    require(!states[stateName].hasBeenCreated, \"this state has already been created\");\n    states[stateName].hasBeenCreated = true;\n    possibleStates.push(stateName);\n  }\n\n  function addRoleForState(bytes32 state, bytes32 role) internal doesStateExist(state) {\n    states[state].allowedRoles.push(role);\n  }\n\n  function addAllowedFunctionForState(bytes32 state, bytes4 allowedFunction) internal doesStateExist(state) {\n    if (!knownSelector[allowedFunction]) {\n      knownSelector[allowedFunction] = true;\n      knownSelectors.push(allowedFunction);\n    }\n    states[state].allowedFunctions[allowedFunction] = true;\n  }\n\n  function addNextStateForState(bytes32 state, bytes32 nextState)\n    internal\n    doesStateExist(state)\n    doesStateExist(nextState)\n  {\n    states[state].nextStates.push(nextState);\n  }\n\n  function addCallbackForState(bytes32 state, function(bytes32, bytes32) internal callback)\n    internal\n    doesStateExist(state)\n  {\n    states[state].callbacks.push(callback);\n  }\n\n  function addPreConditionForState(bytes32 state, function(bytes32, bytes32) internal view preCondition)\n    internal\n    doesStateExist(state)\n  {\n    states[state].preConditions.push(preCondition);\n  }\n\n  function setPreFunctionForState(bytes32 state, bytes4 functionSig) internal doesStateExist(state) {\n    states[state].preFunction = functionSig;\n  }\n\n  /**\n   * @notice Configures the initial state of an object\n   */\n  function setInitialState(bytes32 initialState) internal {\n    require(states[initialState].hasBeenCreated, \"the initial state has not been created yet\");\n    require(\n      currentState == 0,\n      \"the current state has already been set, so you cannot configure the initial state and override it\"\n    );\n    currentState = initialState;\n  }\n\n  /**\n   * @notice Function that checks if we can trigger a transition between two states\n   * @dev This checks if the states exist, if the user has a role to go to the chosen next state and\n   * @dev and if all the preconditions give the ok.\n   */\n  function checkAllTransitionCriteria(bytes32 fromState, bytes32 toState) private view {\n    require(states[fromState].hasBeenCreated, \"the from state has not been configured in this object\");\n    require(states[toState].hasBeenCreated, \"the to state has not been configured in this object\");\n    require(\n      checkNextStates(fromState, toState),\n      \"the requested next state is not an allowed next state for this transition\"\n    );\n    require(\n      checkAllowedRoles(toState),\n      \"the sender of this transaction does not have a role that allows transition between the from and to states\"\n    );\n    checkPreConditions(fromState, toState);\n  }\n\n  /**\n   * @notice Checks if it is allowed to transition between the given states\n   */\n  function checkNextStates(bytes32 fromState, bytes32 toState) private view returns (bool hasNextState) {\n    hasNextState = false;\n    bytes32[] storage nextStates = states[fromState].nextStates;\n    for (uint256 i = 0; i < nextStates.length; i++) {\n      if (keccak256(abi.encodePacked(nextStates[i])) == keccak256(abi.encodePacked(toState))) {\n        hasNextState = true;\n        break;\n      }\n    }\n  }\n\n  /**\n   * @notice Checks all the custom preconditions that determine if it is allowed to transition to a next state\n   * @dev Make sure the preconditions require or assert their checks and have an understandable error message\n   */\n  function checkPreConditions(bytes32 fromState, bytes32 toState) private view {\n    function(bytes32, bytes32) internal view[] storage preConditions = states[toState].preConditions;\n    for (uint256 i = 0; i < preConditions.length; i++) {\n      preConditions[i](fromState, toState);\n    }\n  }\n\n  /**\n   * @notice Checks if the sender has a role that is allowed to transition to a next state\n   */\n  function checkAllowedRoles(bytes32 toState) private view returns (bool isAllowed) {\n    isAllowed = false;\n    bytes32[] storage allowedRoles = states[toState].allowedRoles;\n    if (allowedRoles.length == 0) {\n      isAllowed = true;\n    }\n    for (uint256 i = 0; i < allowedRoles.length; i++) {\n      if (canPerform(msg.sender, allowedRoles[i])) {\n        isAllowed = true;\n        break;\n      }\n    }\n  }\n}\n"
    },
    "contracts/vehicle/VehicleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./Vehicle.sol\";\nimport \"./VehicleRegistry.sol\";\n\n/**\n * @title Factory contract for vehicle state machines\n */\ncontract VehicleFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, VehicleRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new vehicle\n   * @dev Factory method to create a new vehicle. Emits StateMachineCreated event.\n   * @param vin the vehicle's unique Vehicle Identification Number\n   * @param owner the vehicle's current owner\n   * @param mileage the vehicle's mileage\n   * @param ipfsFieldContainerHash ipfs hash of vehicle metadata\n   */\n  function create(\n    string memory vin,\n    address owner,\n    uint256 mileage,\n    string memory ipfsFieldContainerHash\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    bytes memory memProof = bytes(vin);\n    require(memProof.length > 0, \"A vin is required\");\n\n    Vehicle vehicle = new Vehicle(\n      address(gateKeeper),\n      vin,\n      owner,\n      mileage,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = vehicle.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(vehicle),\n        roles[i],\n        address(this)\n      );\n    }\n\n    _registry.insert(address(vehicle));\n    emit StateMachineCreated(address(vehicle));\n  }\n}\n"
    },
    "contracts/_library/provenance/statemachine/StateMachineFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\nimport \"../../utility/ui/UIFieldDefinitions.sol\";\nimport \"./StateMachine.sol\";\nimport \"./StateMachineRegistry.sol\";\n\n/**\n * @title Base contract for state machine factories\n */\ncontract StateMachineFactory is UIFieldDefinitions, Secured {\n  bytes32 public constant CREATE_STATEMACHINE_ROLE = \"CREATE_STATEMACHINE_ROLE\";\n  StateMachineRegistry internal _registry;\n\n  event StateMachineCreated(address statemachine);\n\n  constructor(GateKeeper gateKeeper, StateMachineRegistry registry) Secured(address(gateKeeper)) {\n    _registry = registry;\n  }\n\n  /**\n   * @notice Sets the value of `_uiFieldDefinitionsHash`\n   * @param uiFieldDefinitionsHash value to assign to _uiFieldDefinitionsHash\n   */\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash)\n    public\n    override\n    authWithCustomReason(UPDATE_UIFIELDDEFINITIONS_ROLE, \"Sender needs UPDATE_UIFIELDDEFINITIONS_ROLE\")\n  {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  /**\n   * @notice Retrieves the value of `_uiFieldDefinitionsHash`\n   */\n  function getUIFieldDefinitionsHash() public view override returns (string memory) {\n    return _uiFieldDefinitionsHash;\n  }\n\n  // Due to the fact that the param list is dependant on the statemachine implementation,\n  // this cannot be an abstract contract but you still have to implement the create() function.\n  // This is a good example. Make sure to emit the StateMachineCreated event.\n  //\n  // function create(\n  //   uint256 amount,\n  //   string memory proof,\n  //   string memory ipfsFieldContainerHash\n  // )\n  //   public\n  //   auth(CREATE_STATEMACHINE_ROLE)\n  // {\n  //   require(amount > 0, \"The amount of an expense cannot be zero\");\n  //   bytes memory memProof = bytes(proof);\n  //   require(memProof.length > 0, \"A proof file is required for all expenses\");\n  //\n  //   Expense expense = new Expense(\n  //     gateKeeper,\n  //     amount,\n  //     proof,\n  //     ipfsFieldContainerHash,\n  //     _uiFieldDefinitionsHash,\n  //     msg.sender\n  //   );\n\n  //   // Give every role registry a single permission on the newly created expense.\n  //   bytes32[] memory roles = expense.getRoles();\n  //   for (uint i = 0; i < roles.length; i++) {\n  //     gateKeeper.createPermission(\n  //       gateKeeper.getRoleRegistryAddress(roles[i]),\n  //       address(expense),\n  //       roles[i],\n  //       address(this)\n  //     );\n  //   }\n\n  //   _registry.insert(address(expense), msg.sender);\n  //   emit StateMachineCreated(msg.sender,address(expense),amount);\n  // }\n}\n"
    },
    "contracts/vehicle/VehicleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for vehicle state machines\n */\ncontract VehicleRegistry is StateMachineRegistry {\n  constructor(address gateKeeper) StateMachineRegistry(gateKeeper) {}\n}\n"
    },
    "contracts/_library/provenance/statemachine/StateMachineRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\nimport \"../../utility/syncing/Syncable.sol\";\nimport \"./StateMachine.sol\";\n\n/**\n * @title Base contract for state machine registries\n */\ncontract StateMachineRegistry is Secured, Syncable {\n  event StateMachineRegistered(address statemachine);\n\n  bytes32 public constant INSERT_STATEMACHINE_ROLE = \"INSERT_STATEMACHINE_ROLE\";\n\n  mapping(address => StateMachine) internal _stateMachines;\n  address[] internal _stateMachineIndex;\n\n  constructor(address gateKeeper) Secured(gateKeeper) {}\n\n  /**\n   * @notice Inserts a statemachine into the registry\n   * @dev Emits the StateMachineRegistered event after the state machine has been included to the registry\n   * @param statemachine the state machine's address\n   */\n  function insert(address statemachine)\n    public\n    authWithCustomReason(INSERT_STATEMACHINE_ROLE, \"Sender needs INSERT_STATEMACHINE_ROLE\")\n  {\n    _stateMachines[statemachine] = StateMachine(statemachine);\n    _stateMachineIndex.push(statemachine);\n    emit StateMachineRegistered(statemachine);\n  }\n\n  /**\n   * @notice Returns the length of the state machine index\n   * @dev Returns the length of the state machine index\n   * @return length the amount of items in the state machine index\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = _stateMachineIndex.length;\n  }\n\n  function getByIndex(uint256 index) public view returns (address key, address contractAddress) {\n    return getByKey(_stateMachineIndex[index]);\n  }\n\n  function getByKey(address someKey) public view returns (address key, address contractAddress) {\n    key = someKey;\n    contractAddress = address(_stateMachines[someKey]);\n  }\n\n  /**\n   * @notice Retrieves the state machine index\n   * @return index an array with the addresses of all statemachines\n   */\n  function getIndex() public view returns (address[] memory index) {\n    return _stateMachineIndex;\n  }\n}\n"
    },
    "contracts/traceability/TraceabilityRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for vehicle state machines\n */\ncontract TraceabilityRegistry is StateMachineRegistry {\n  constructor(address gatekeeper) StateMachineRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/traceability/TraceabilityFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./Traceability.sol\";\nimport \"./TraceabilityRegistry.sol\";\n\n/**\n * @title Factory contract for generic state machines\n */\ncontract TraceabilityFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, TraceabilityRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new generic instance\n   * @dev Factory method to create a new state machine. Emits StateMachineCreated event.\n   * @param harvestDate the fharvest date of  the batch\n   * @param ipfsFieldContainerHash ipfs hash of vehicle metadata\n   */\n  function create(uint256 harvestDate, string memory ipfsFieldContainerHash)\n    public\n    authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\")\n  {\n    Traceability traceability = new Traceability(\n      address(gateKeeper),\n      harvestDate,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = traceability.getRoles();\n    for (uint256 i = 0; i < 1; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(traceability),\n        roles[i],\n        address(this)\n      );\n    }\n    _registry.insert(address(traceability));\n    emit StateMachineCreated(address(traceability));\n  }\n}\n"
    },
    "contracts/traceability/Traceability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * Generic\n *\n * A generic package exists of\n *  - a description of the generic state machine\n *\n * @title Traceability machine implementation\n */\ncontract Traceability is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_ONE = \"Harvest\";\n  bytes32 public constant STATE_TWO = \"Malting\";\n  bytes32 public constant STATE_THREE = \"Brewing\";\n  bytes32 public constant STATE_FOUR = \"Fermentation\";\n  bytes32 public constant STATE_FIVE = \"Maturation\";\n  bytes32 public constant STATE_SIX = \"Bottling\";\n  bytes32 public constant STATE_SEVEN = \"Final Beer\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_ONE = \"Farmer\";\n  bytes32 public constant ROLE_TWO = \"Maltster\";\n  bytes32 public constant ROLE_THREE = \"Brewer\";\n\n  bytes32[] public _roles = [ROLE_ADMIN];\n\n  string public _uiFieldDefinitionsHash;\n  uint256 public _harvestDate;\n  uint256 public _maltingDate;\n  uint256 public _brewingDate;\n  uint256 public _fermentationDate;\n  uint256 public _maturationDate;\n  uint256 public _bottlingDate;\n\n  constructor(\n    address gateKeeper,\n    uint256 harvestDate,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _harvestDate = harvestDate;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  /**\n   * @notice Updates state machine properties\n   * @param harvestDate the first parameter of the state machine\n   * @param ipfsFieldContainerHash ipfs hash of vehicle metadata\n   */\n  function edit(uint256 harvestDate, string memory ipfsFieldContainerHash) public {\n    _harvestDate = harvestDate;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  function addMaltingDate(uint256 maltingDate) public {\n    _maltingDate = maltingDate;\n  }\n\n  function getMaltingDate() public returns (uint256) {\n    return _maltingDate;\n  }\n\n  function addBrewingDate(uint256 brewingDate) public {\n    _brewingDate = brewingDate;\n  }\n\n  function getBrewingDate() public returns (uint256) {\n    return _brewingDate;\n  }\n\n  function addFermentationDate(uint256 fermentationDate) public {\n    _fermentationDate = fermentationDate;\n  }\n\n  function getFermentationDate() public returns (uint256) {\n    return _fermentationDate;\n  }\n\n  function addMaturationDate(uint256 maturationDate) public {\n    _maturationDate = maturationDate;\n  }\n\n  function getMaturationDate() public returns (uint256) {\n    return _maturationDate;\n  }\n\n  function addBottlingDate(uint256 bottlingDate) public {\n    _bottlingDate = bottlingDate;\n  }\n\n  function getBottlingDate() public returns (uint256) {\n    return _bottlingDate;\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n    createState(STATE_ONE);\n    createState(STATE_TWO);\n    createState(STATE_THREE);\n    createState(STATE_FOUR);\n    createState(STATE_FIVE);\n    createState(STATE_SIX);\n    createState(STATE_SEVEN);\n\n    // add properties\n    // STATE_ONE\n    addNextStateForState(STATE_ONE, STATE_TWO);\n    addRoleForState(STATE_ONE, ROLE_ADMIN);\n    addRoleForState(STATE_ONE, ROLE_ONE);\n\n    // STATE_TWO\n    addNextStateForState(STATE_TWO, STATE_THREE);\n    addAllowedFunctionForState(STATE_TWO, this.addMaltingDate.selector);\n    addRoleForState(STATE_TWO, ROLE_ADMIN);\n    addRoleForState(STATE_TWO, ROLE_TWO);\n\n    // STATE_THREE\n    addNextStateForState(STATE_THREE, STATE_FOUR);\n    addAllowedFunctionForState(STATE_THREE, this.addBrewingDate.selector);\n    addRoleForState(STATE_THREE, ROLE_ADMIN);\n    addRoleForState(STATE_THREE, ROLE_THREE);\n\n    // STATE_FOUR\n    addNextStateForState(STATE_FOUR, STATE_FIVE);\n    addAllowedFunctionForState(STATE_FOUR, this.addFermentationDate.selector);\n    addRoleForState(STATE_FOUR, ROLE_ADMIN);\n    addRoleForState(STATE_FOUR, ROLE_THREE);\n\n    // STATE_FIVE\n    addNextStateForState(STATE_FIVE, STATE_SIX);\n    addAllowedFunctionForState(STATE_FIVE, this.addMaturationDate.selector);\n    addRoleForState(STATE_FIVE, ROLE_ADMIN);\n    addRoleForState(STATE_FIVE, ROLE_THREE);\n\n    // STATE_SIX\n    addNextStateForState(STATE_SIX, STATE_SEVEN);\n    addAllowedFunctionForState(STATE_SIX, this.addBottlingDate.selector);\n    addRoleForState(STATE_SIX, ROLE_ADMIN);\n    addRoleForState(STATE_SIX, ROLE_THREE);\n\n    // STATE_SEVEN\n    addRoleForState(STATE_SEVEN, ROLE_ADMIN);\n    addRoleForState(STATE_SEVEN, ROLE_THREE);\n\n    setInitialState(STATE_ONE);\n  }\n}\n"
    },
    "contracts/supplychainfinance/SupplyChainFinance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * SupplyChainFinance\n\n *\n * @title State machine for SupplyChainFinance\n */\ncontract SupplyChainFinance is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_DEMAND_GENERATED = \"DEMAND GENERATED\";\n  bytes32 public constant STATE_ORDER_PLACED = \"ORDER PLACED\";\n  bytes32 public constant STATE_ORDER_ACCEPTED = \"ACCEPTED\";\n  bytes32 public constant STATE_ORDER_ON_HOLD = \"ON HOLD\";\n  bytes32 public constant STATE_ORDER_DECLINED = \"DECLINED\";\n\n  bytes32 public constant STATE_FINANCING_REQUESTED = \"FINANCING REQUESTED\";\n  bytes32 public constant STATE_BACKGROUND_CHECK = \"BACKGROUND CHECK\";\n  bytes32 public constant STATE_KYB_AVAILABLE = \"KYB AVAILABLE\";\n  bytes32 public constant STATE_KYB_UNAVAILABLE = \"KYB UNAVAILABLE\";\n  bytes32 public constant STATE_KYB_IN_PROCESS = \"KYB IN PROCESS\";\n  bytes32 public constant STATE_KYB_APPROVED = \"KYB APPROVED\";\n  bytes32 public constant STATE_LOAN_APPROVED = \"LOAN APPROVED\";\n  bytes32 public constant STATE_MONEY_TRANSFERED = \"MONEY TRANSFERED\";\n\n  bytes32 public constant STATE_ADVANCE_REQUESTED = \"ADVANCE REQUESTED\";\n  bytes32 public constant STATE_ADVANCE_APPROVED = \"ADVANCE APPROVED\";\n  bytes32 public constant STATE_ADVANCE_RELEASED = \"ADVANCE RELEASED\";\n\n  bytes32 public constant STATE_IN_PRODUCTION = \"IN PRODUCTION\";\n  bytes32 public constant STATE_READY_FOR_DISPATCH = \"READY FOR DISPATCH\";\n  bytes32 public constant STATE_REACHED_TRANSFER_POINT = \"AT TRANSFER POINT\";\n  bytes32 public constant STATE_RECEIEVED_AT_WAREHOUSE = \"RECIEVED AT WAREHOUSE\";\n  bytes32 public constant STATE_STOCKED_AT_WAREHOUSE = \"STOCKED AT WAREHOUSE\";\n  bytes32 public constant STATE_OUT_FOR_DELIVERY = \"OUT FOR DELIVERY\";\n  bytes32 public constant STATE_RECIEVED_BY_BUYER = \"RECIEVED BY BUYER\";\n  bytes32 public constant STATE_PRODUCT_SHELVED = \"SHELVED\";\n  bytes32 public constant STATE_PRODUCT_SOLD = \"SOLD\";\n  bytes32 public constant STATE_PRODUCT_DISCARDED = \"DISCARDED\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_BUYER = \"ROLE_BUYER\";\n  bytes32 public constant ROLE_SUPPLIER = \"ROLE_SUPPLIER\";\n  bytes32 public constant ROLE_TRANSPORTER = \"ROLE_TRANSPORTER\";\n  bytes32 public constant ROLE_WAREHOUSE = \"ROLE_WAREHOUSE\";\n\n  bytes32 public constant ROLE_REGULATOR = \"ROLE_REGULATOR\";\n  bytes32 public constant ROLE_BANK = \"ROLE_BANK\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_BUYER, ROLE_SUPPLIER, ROLE_TRANSPORTER];\n\n  string public _uiFieldDefinitionsHash;\n  string public _Order_Number;\n\n  constructor(\n    address gateKeeper,\n    string memory Order_Number,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _Order_Number = Order_Number;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  /**\n   * @notice Updates expense properties\n   * @param Order_Number It is the order Identification Number\n   * @param ipfsFieldContainerHash ipfs hash of supplychainfinance metadata\n   */\n  function edit(string memory Order_Number, string memory ipfsFieldContainerHash) public {\n    _Order_Number = Order_Number;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns a DID of the supplychainfinance\n   * @dev Returns a unique DID (Decentralized Identifier) for the supplychainfinance.\n   * @return string representing the DID of the supplychainfinance\n   */\n  function DID() public view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:supplychainfinance:\", _Order_Number));\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  bytes32[] private _canEdit = [\n    ROLE_ADMIN,\n    ROLE_BUYER,\n    ROLE_SUPPLIER,\n    ROLE_TRANSPORTER,\n    ROLE_WAREHOUSE,\n    ROLE_REGULATOR,\n    ROLE_BANK\n  ];\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n\n    createState(STATE_DEMAND_GENERATED);\n    createState(STATE_ORDER_PLACED);\n    createState(STATE_ORDER_ACCEPTED);\n    createState(STATE_ORDER_ON_HOLD);\n    createState(STATE_ORDER_DECLINED);\n    createState(STATE_FINANCING_REQUESTED);\n    createState(STATE_BACKGROUND_CHECK);\n    createState(STATE_KYB_AVAILABLE);\n    createState(STATE_KYB_UNAVAILABLE);\n    createState(STATE_KYB_IN_PROCESS);\n    createState(STATE_KYB_APPROVED);\n    createState(STATE_LOAN_APPROVED);\n    createState(STATE_MONEY_TRANSFERED);\n    createState(STATE_ADVANCE_REQUESTED);\n    createState(STATE_ADVANCE_APPROVED);\n    createState(STATE_ADVANCE_RELEASED);\n    createState(STATE_IN_PRODUCTION);\n    createState(STATE_READY_FOR_DISPATCH);\n    createState(STATE_REACHED_TRANSFER_POINT);\n    createState(STATE_RECEIEVED_AT_WAREHOUSE);\n    createState(STATE_STOCKED_AT_WAREHOUSE);\n    createState(STATE_OUT_FOR_DELIVERY);\n    createState(STATE_RECIEVED_BY_BUYER);\n    createState(STATE_PRODUCT_SHELVED);\n    createState(STATE_PRODUCT_SOLD);\n    createState(STATE_PRODUCT_DISCARDED);\n\n    // add properties\n\n    addNextStateForState(STATE_DEMAND_GENERATED, STATE_ORDER_PLACED);\n    addNextStateForState(STATE_ORDER_PLACED, STATE_ORDER_ACCEPTED);\n    addNextStateForState(STATE_ORDER_PLACED, STATE_ORDER_ON_HOLD);\n    addNextStateForState(STATE_ORDER_PLACED, STATE_ORDER_DECLINED);\n    addNextStateForState(STATE_ORDER_ACCEPTED, STATE_IN_PRODUCTION);\n    addNextStateForState(STATE_IN_PRODUCTION, STATE_READY_FOR_DISPATCH);\n    addNextStateForState(STATE_READY_FOR_DISPATCH, STATE_REACHED_TRANSFER_POINT);\n    addNextStateForState(STATE_REACHED_TRANSFER_POINT, STATE_RECEIEVED_AT_WAREHOUSE);\n    addNextStateForState(STATE_RECEIEVED_AT_WAREHOUSE, STATE_STOCKED_AT_WAREHOUSE);\n    addNextStateForState(STATE_STOCKED_AT_WAREHOUSE, STATE_OUT_FOR_DELIVERY);\n    addNextStateForState(STATE_OUT_FOR_DELIVERY, STATE_RECIEVED_BY_BUYER);\n    addNextStateForState(STATE_RECIEVED_BY_BUYER, STATE_PRODUCT_SHELVED);\n    addNextStateForState(STATE_RECIEVED_BY_BUYER, STATE_PRODUCT_SOLD);\n    addNextStateForState(STATE_RECIEVED_BY_BUYER, STATE_PRODUCT_DISCARDED);\n\n    addNextStateForState(STATE_ORDER_ON_HOLD, STATE_FINANCING_REQUESTED);\n    addNextStateForState(STATE_FINANCING_REQUESTED, STATE_BACKGROUND_CHECK);\n    addNextStateForState(STATE_BACKGROUND_CHECK, STATE_KYB_AVAILABLE);\n    addNextStateForState(STATE_BACKGROUND_CHECK, STATE_KYB_UNAVAILABLE);\n    addNextStateForState(STATE_KYB_UNAVAILABLE, STATE_KYB_IN_PROCESS);\n    addNextStateForState(STATE_KYB_IN_PROCESS, STATE_KYB_AVAILABLE);\n    addNextStateForState(STATE_KYB_AVAILABLE, STATE_LOAN_APPROVED);\n    addNextStateForState(STATE_LOAN_APPROVED, STATE_MONEY_TRANSFERED);\n    addNextStateForState(STATE_MONEY_TRANSFERED, STATE_ORDER_ACCEPTED);\n\n    addNextStateForState(STATE_ORDER_ON_HOLD, STATE_ADVANCE_REQUESTED);\n    addNextStateForState(STATE_ADVANCE_REQUESTED, STATE_BACKGROUND_CHECK);\n    addNextStateForState(STATE_KYB_AVAILABLE, STATE_ADVANCE_APPROVED);\n    addNextStateForState(STATE_ADVANCE_APPROVED, STATE_ADVANCE_RELEASED);\n    addNextStateForState(STATE_ADVANCE_RELEASED, STATE_ORDER_ACCEPTED);\n\n    addRoleForState(STATE_DEMAND_GENERATED, ROLE_BUYER);\n    addRoleForState(STATE_ORDER_PLACED, ROLE_BUYER);\n    addRoleForState(STATE_ORDER_ACCEPTED, ROLE_SUPPLIER);\n    addRoleForState(STATE_ORDER_ON_HOLD, ROLE_SUPPLIER);\n    addRoleForState(STATE_ORDER_DECLINED, ROLE_SUPPLIER);\n    addRoleForState(STATE_IN_PRODUCTION, ROLE_SUPPLIER);\n    addRoleForState(STATE_READY_FOR_DISPATCH, ROLE_SUPPLIER);\n    addRoleForState(STATE_REACHED_TRANSFER_POINT, ROLE_TRANSPORTER);\n    addRoleForState(STATE_RECEIEVED_AT_WAREHOUSE, ROLE_WAREHOUSE);\n    addRoleForState(STATE_STOCKED_AT_WAREHOUSE, ROLE_WAREHOUSE);\n    addRoleForState(STATE_OUT_FOR_DELIVERY, ROLE_TRANSPORTER);\n    addRoleForState(STATE_RECIEVED_BY_BUYER, ROLE_BUYER);\n    addRoleForState(STATE_PRODUCT_SHELVED, ROLE_BUYER);\n    addRoleForState(STATE_PRODUCT_SOLD, ROLE_BUYER);\n    addRoleForState(STATE_PRODUCT_DISCARDED, ROLE_BUYER);\n\n    addRoleForState(STATE_FINANCING_REQUESTED, ROLE_SUPPLIER);\n    addRoleForState(STATE_BACKGROUND_CHECK, ROLE_REGULATOR);\n    addRoleForState(STATE_KYB_AVAILABLE, ROLE_REGULATOR);\n    addRoleForState(STATE_KYB_UNAVAILABLE, ROLE_REGULATOR);\n    addRoleForState(STATE_KYB_IN_PROCESS, ROLE_SUPPLIER);\n    addRoleForState(STATE_KYB_AVAILABLE, ROLE_REGULATOR);\n    addRoleForState(STATE_LOAN_APPROVED, ROLE_BANK);\n    addRoleForState(STATE_MONEY_TRANSFERED, ROLE_BANK);\n    addRoleForState(STATE_ORDER_ACCEPTED, ROLE_SUPPLIER);\n    addRoleForState(STATE_ADVANCE_REQUESTED, ROLE_SUPPLIER);\n    addRoleForState(STATE_ADVANCE_APPROVED, ROLE_BUYER);\n    addRoleForState(STATE_ADVANCE_RELEASED, ROLE_BUYER);\n\n    addRoleForState(STATE_DEMAND_GENERATED, ROLE_ADMIN);\n    addRoleForState(STATE_ORDER_PLACED, ROLE_ADMIN);\n    addRoleForState(STATE_ORDER_ACCEPTED, ROLE_ADMIN);\n    addRoleForState(STATE_ORDER_ON_HOLD, ROLE_ADMIN);\n    addRoleForState(STATE_ORDER_DECLINED, ROLE_ADMIN);\n    addRoleForState(STATE_IN_PRODUCTION, ROLE_ADMIN);\n    addRoleForState(STATE_READY_FOR_DISPATCH, ROLE_ADMIN);\n    addRoleForState(STATE_REACHED_TRANSFER_POINT, ROLE_ADMIN);\n    addRoleForState(STATE_RECEIEVED_AT_WAREHOUSE, ROLE_ADMIN);\n    addRoleForState(STATE_STOCKED_AT_WAREHOUSE, ROLE_ADMIN);\n    addRoleForState(STATE_OUT_FOR_DELIVERY, ROLE_ADMIN);\n    addRoleForState(STATE_RECIEVED_BY_BUYER, ROLE_ADMIN);\n    addRoleForState(STATE_PRODUCT_SHELVED, ROLE_ADMIN);\n    addRoleForState(STATE_PRODUCT_SOLD, ROLE_ADMIN);\n    addRoleForState(STATE_PRODUCT_DISCARDED, ROLE_ADMIN);\n\n    addRoleForState(STATE_FINANCING_REQUESTED, ROLE_ADMIN);\n    addRoleForState(STATE_BACKGROUND_CHECK, ROLE_ADMIN);\n    addRoleForState(STATE_KYB_AVAILABLE, ROLE_ADMIN);\n    addRoleForState(STATE_KYB_UNAVAILABLE, ROLE_ADMIN);\n    addRoleForState(STATE_KYB_IN_PROCESS, ROLE_ADMIN);\n    addRoleForState(STATE_KYB_AVAILABLE, ROLE_ADMIN);\n    addRoleForState(STATE_LOAN_APPROVED, ROLE_ADMIN);\n    addRoleForState(STATE_MONEY_TRANSFERED, ROLE_ADMIN);\n    addRoleForState(STATE_ADVANCE_REQUESTED, ROLE_ADMIN);\n    addRoleForState(STATE_BACKGROUND_CHECK, ROLE_ADMIN);\n    addRoleForState(STATE_ADVANCE_APPROVED, ROLE_ADMIN);\n    addRoleForState(STATE_ADVANCE_RELEASED, ROLE_ADMIN);\n\n    setInitialState(STATE_DEMAND_GENERATED);\n  }\n}\n"
    },
    "contracts/supplychainfinance/SupplyChainFinanceFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./SupplyChainFinance.sol\";\nimport \"./SupplyChainFinanceRegistry.sol\";\n\n/**\n * @title Factory contract for supplychainfinance state machines\n */\ncontract SupplyChainFinanceFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, SupplyChainFinanceRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new supplychainfinance\n   * @dev Factory method to create a new supplychainfinance. Emits StateMachineCreated event.\n   * @param Order_Number is unique SupplyChainFinance Identification Number\n   * @param ipfsFieldContainerHash ipfs hash of supplychainfinance metadata\n   */\n  function create(string memory Order_Number, string memory ipfsFieldContainerHash)\n    public\n    authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\")\n  {\n    bytes memory memProof = bytes(Order_Number);\n    require(memProof.length > 0, \"A Order_Number is required\");\n\n    SupplyChainFinance supplychainfinance = new SupplyChainFinance(\n      address(gateKeeper),\n      Order_Number,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = supplychainfinance.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(supplychainfinance),\n        roles[i],\n        address(this)\n      );\n    }\n\n    _registry.insert(address(supplychainfinance));\n    emit StateMachineCreated(address(supplychainfinance));\n  }\n}\n"
    },
    "contracts/supplychainfinance/SupplyChainFinanceRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for supplychainfinance state machines\n */\ncontract SupplyChainFinanceRegistry is StateMachineRegistry {\n  constructor(address gateKeeper) StateMachineRegistry(gateKeeper) {}\n}\n"
    },
    "contracts/supplychain/SupplyChainFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./SupplyChain.sol\";\nimport \"./SupplyChainRegistry.sol\";\n\n/**\n * @title Factory contract for supplychain state machines\n */\ncontract SupplyChainFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, SupplyChainRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new supplychain\n   * @dev Factory method to create a new supplychain. Emits StateMachineCreated event.\n   * @param Order_Number Unique Identification Number\n\n   * @param ipfsFieldContainerHash ipfs hash of supplychain metadata\n   */\n  function create(string memory Order_Number, string memory ipfsFieldContainerHash)\n    public\n    authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\")\n  {\n    bytes memory memProof = bytes(Order_Number);\n    require(memProof.length > 0, \"A Order_Number is required\");\n\n    SupplyChain supplychain = new SupplyChain(\n      address(gateKeeper),\n      Order_Number,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = supplychain.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(supplychain),\n        roles[i],\n        address(this)\n      );\n    }\n\n    _registry.insert(address(supplychain));\n    emit StateMachineCreated(address(supplychain));\n  }\n}\n"
    },
    "contracts/supplychain/SupplyChain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n//import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * SupplyChain\n\n *\n * @title State machine for SupplyChain\n */\ncontract SupplyChain is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n\n  //IERC20 private _token = IERC20(TokenAddress);\n\n  bytes32 public constant WHOLESALE_ORDER_FULFILLED = \"WHOLESALE_ORDER_FULFILLED\";\n  bytes32 public constant WOOL_TESTED = \"WOOL_TESTED\";\n  bytes32 public constant WOOL_TEST_GRADE_FEEDBACK = \"WOOL_TEST_GRADE_FEEDBACK\";\n  bytes32 public constant WOOL_GRADED = \"WOOL_GRADED\";\n  bytes32 public constant RETAIL_ORDER_PLACED = \"RETAIL_ORDER_PLACED\";\n  bytes32 public constant RETAIL_ORDER_UNFULFILLED = \"RETAIL_ORDER_UNFULFILLED\";\n  bytes32 public constant RETAIL_ORDER_FULFILLED = \"RETAIL_ORDER_FULFILLED\";\n  bytes32 public constant ORDER_CANCELLED = \"ORDER_CANCELLED\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_CONGLOMERATE = \"ROLE_CONGLOMERATE\";\n  bytes32 public constant ROLE_RETAILER = \"ROLE_RETAILER\";\n  bytes32 public constant ROLE_AWTA = \"ROLE_AWTA\";\n  bytes32 public constant ROLE_AWEX = \"ROLE_AWEX\";\n  bytes32 public constant ROLE_WHOLESALER = \"ROLE_WHOLESALER\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_WHOLESALER,ROLE_CONGLOMERATE, ROLE_RETAILER, ROLE_AWTA, ROLE_AWEX ];\n\n  string public _uiFieldDefinitionsHash;\n  string public _Order_Number;\n\n  constructor(\n    address gateKeeper,\n    string memory Order_Number,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _Order_Number = Order_Number;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  /**\n   * @notice Updates expense properties\n   * @param Order_Number It is the order Identification Number\n   * @param ipfsFieldContainerHash ipfs hash of supplychainfinance metadata\n   */\n  function edit(string memory Order_Number, string memory ipfsFieldContainerHash) public {\n    _Order_Number = Order_Number;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns a DID of the supplychainfinance\n   * @dev Returns a unique DID (Decentralized Identifier) for the supplychainfinance.\n   * @return string representing the DID of the supplychainfinance\n   */\n  function DID() public view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:supplychainfinance:\", _Order_Number));\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n\n    createState(WHOLESALE_ORDER_FULFILLED);\n    createState(WOOL_TESTED);\n    createState(WOOL_TEST_GRADE_FEEDBACK);\n    createState(WOOL_GRADED);\n    createState(RETAIL_ORDER_PLACED);\n    createState(RETAIL_ORDER_UNFULFILLED);\n    createState(RETAIL_ORDER_FULFILLED);\n\n    // add properties\n\n     addNextStateForState(WHOLESALE_ORDER_FULFILLED, WOOL_TESTED);\n    addNextStateForState(WOOL_TESTED, WOOL_TEST_GRADE_FEEDBACK);\n\n    addNextStateForState(WOOL_TEST_GRADE_FEEDBACK, ORDER_CANCELLED);\n    addNextStateForState(WOOL_TEST_GRADE_FEEDBACK, RETAIL_ORDER_FULFILLED);\n    addNextStateForState(WOOL_TESTED, WOOL_GRADED);\n    addNextStateForState(WOOL_GRADED, RETAIL_ORDER_PLACED);\n    addNextStateForState(RETAIL_ORDER_PLACED, RETAIL_ORDER_UNFULFILLED);\n    addNextStateForState(RETAIL_ORDER_UNFULFILLED, WOOL_TESTED);\n    addNextStateForState(RETAIL_ORDER_PLACED, RETAIL_ORDER_FULFILLED);\n\n    addRoleForState(WHOLESALE_ORDER_FULFILLED, ROLE_WHOLESALER);\n    addRoleForState(WOOL_TESTED, ROLE_AWTA);\n    addRoleForState(WOOL_GRADED, ROLE_AWEX);\n    addRoleForState(RETAIL_ORDER_PLACED, ROLE_RETAILER);\n    addRoleForState(RETAIL_ORDER_UNFULFILLED, ROLE_RETAILER);\n    //addRoleForState(WOOL_TEST_GRADE_FEEDBACK, ROLE_AWEX& ROLE_AWTA, adminAddress);\n    addRoleForState(RETAIL_ORDER_FULFILLED, ROLE_RETAILER);\n    setInitialState(WHOLESALE_ORDER_FULFILLED);\n  }\n}\n"
    },
    "contracts/supplychain/SupplyChainRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for supplychain state machines\n */\ncontract SupplyChainRegistry is StateMachineRegistry {\n  constructor(address gateKeeper) StateMachineRegistry(gateKeeper) {}\n}\n"
    },
    "contracts/statefulbonds/StatefulBond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\nimport \"../_library/tokens/ERC20/ERC20Token.sol\";\n\n/**\n * StatefulBond\n *\nA screen to create a bond as an asset on the platform with the following attributes:\nIssuance Date\nLaunch Date\nMaturity Date\nCoupon Rate\nCoupon Payment Frequency\nISIN\nBond Name\nBind Currency\n\nOperator 1 can create the bond, and Operator 2 will approve the bond creation.\n\nA screen which shows the amount of bonds which the client is holding with SCB (Maximum Bond field which Rod\nmentioned earlier and this field can be updated as and when the client buy more bonds in the real world).\nFrom this screen, Operator 1 can choose to tokenize the number of bonds and the number of tokens they want\nto create. Operator 2 will approve the request and the tokens will be minted to a client wallet which Operator 2\nwill select from a list of wallets.\n\nA screen to transfer tokens from the client wallet to other wallets and vice versa.\n\nA screen for Coupon Payout with the following details:\nCoupon Rate\nCoupon Payment $Amount per Token\nTotal Coupon Payment $Amount\n“Payment in Currency Token” Button\n“Payment in Fiat Currency” Button\n\nOperator 1 will clicked on either (d) or (e) button after confirming the details on the screen. When Operator 1\nclicked on the button in (d), currency tokens will be paid out to the respective investor wallets. When Operator 1\nclicked on the button in (e), an instruction will be sent to an external payment system. No need to have any external\nconnection, just need to show a pop-up etc to say that “Coupon Payment Instruction sent”\n\nBonus:\n\nIn-Flight Bonds – Bonds which are purchased by client in the real world but not yet settled. Client wants these in-flight bonds to be tokenized as well so that they can start to sell those tokens. When the actual bonds are settled in the real world, the in-flight bonds and the in-flight bond tokens become normal bonds and normal tokens through a change of status or any other logical way.\n\nThanks!\n\n\n\n\nFully manual yet stateful bond\n\nStates:\n\n  - Created (ops1)\n      - Issuance Date\n      - Launch Date\n      - Maturity Date\n      - Coupon Rate\n      - Coupon Payment Frequency\n      - ISIN\n      - Bond Name\n      - Bind Currency\n  - Approved (ops2)\n  - Tokenization request (ops1)\n      - max supply check\n  - Tokenization approved (ops2)\n      - mints to client\n\nFunctions:\n  - updateMaxSupplyFromBackend()\n  - createCoupon()\n\n  - couponCheckpoints\n\nCoupon\n\nStates:\n  - Created (ops1)\n      - Coupon Rate\n      - Coupon Payment $Amount per Token\n      - Total Coupon Payment $Amount\n      - “Payment in Currency Token” Button\n      - “Payment in Fiat Currency” Button\n *\n * @title State machine to track a stateful bond\n */\ncontract StatefulBond is Converter, StateMachine, FileFieldContainer, ERC20Token {\n  // State Machine config\n  bytes32 public constant STATE_CREATED = \"CREATED\";\n  bytes32 public constant STATE_TO_REVIEW = \"TO REVIEW\";\n  bytes32 public constant STATE_CHANGES_NEEDED = \"CHANGES NEEDED\";\n  bytes32 public constant STATE_READY_FOR_TOKENIZATION = \"READY FOR TOKENIZATION\";\n  bytes32 public constant STATE_TOKENIZATION_REQUEST = \"TOKENIZATION REQUEST\";\n  bytes32 public constant STATE_TOKENIZATION_APPROVED = \"TOKENIZATION APPROVED\";\n  bytes32 public constant STATE_TOKENIZATION_DENIED = \"TOKENIZATION DENIED\";\n  bytes32 public constant STATE_MATURED = \"MATURED\";\n  bytes32 public constant STATE_CONVERTED = \"CONVERTED\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_MAKER = \"ROLE_MAKER\";\n  bytes32 public constant ROLE_CHECKER = \"ROLE_CHECKER\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_MAKER, ROLE_CHECKER];\n  bytes32[] private _canEdit = [ROLE_ADMIN, ROLE_MAKER];\n\n  // Data fields\n  uint256 public _parValue;\n  uint256 public _couponRate;\n  uint256 public _launchDate;\n  uint256 public _tokenizationAmount;\n  address public _tokenizationRecipient;\n  bytes32 public _inFlight;\n  bytes32 public _frequency;\n  uint8 internal _parValueDecimal;\n  uint8 internal _couponRateDecimal;\n\n  constructor(\n    string memory name,\n    uint256 parValue,\n    uint256 couponRate,\n    uint8 decimals,\n    bytes32 inFlight,\n    bytes32 frequency,\n    GateKeeper gateKeeper,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) ERC20Token(name, decimals, address(gateKeeper), uiFieldDefinitionsHash) {\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _parValue = parValue;\n    _couponRate = couponRate;\n    _inFlight = inFlight;\n    _frequency = frequency;\n    _parValueDecimal = 2;\n    _couponRateDecimal = 2;\n    setupStateMachine();\n  }\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  function getDecimalsFor(bytes memory fieldName) public view override returns (uint256) {\n    if (keccak256(fieldName) == keccak256(\"_parValue\") || keccak256(fieldName) == keccak256(\"payment\")) {\n      return _parValueDecimal;\n    }\n    if (keccak256(fieldName) == keccak256(\"_couponRate\")) {\n      return _couponRateDecimal;\n    }\n    if (\n      keccak256(fieldName) == keccak256(\"amount\") ||\n      keccak256(fieldName) == keccak256(\"balance\") ||\n      keccak256(fieldName) == keccak256(\"totalSupply\") ||\n      keccak256(fieldName) == keccak256(\"value\") ||\n      keccak256(fieldName) == keccak256(\"tokenizationAmount\") ||\n      keccak256(fieldName) == keccak256(\"_tokenizationAmount\") ||\n      keccak256(fieldName) == keccak256(\"holderBalance\")\n    ) {\n      return _decimals;\n    }\n    return 0;\n  }\n\n  function edit(\n    string memory name,\n    uint256 parValue,\n    uint256 couponRate,\n    uint8 decimals,\n    bytes32 inFlight,\n    bytes32 frequency,\n    string memory ipfsFieldContainerHash\n  ) public authManyWithCustomReason(_canEdit, \"Edit requires one of roles: ROLE_ADMIN, ROLE_MAKER\") {\n    _name = name;\n    _decimals = decimals;\n    _parValue = parValue;\n    _couponRate = couponRate;\n    _inFlight = inFlight;\n    _frequency = frequency;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Releases the issuance to investors at a certain date and time\n   *\n   * @param launchDate the launch date or announcement date is the date at which the details regarding a new issue\n   *                   are released to investors.\n   */\n  function launch(uint256 launchDate) public {\n    require(_launchDate == 0, \"This bond is already launched\");\n    _launchDate = launchDate;\n  }\n\n  function requestTokenization(uint256 amount) public checkAllowedFunction {\n    _tokenizationAmount = amount;\n    _tokenizationRecipient = msg.sender;\n  }\n\n  function tokenize(bytes32 fromState, bytes32 toState) public checkAllowedFunction {\n    mint(_tokenizationRecipient, _tokenizationAmount);\n    reset(fromState, toState);\n  }\n\n  event PaymentCommand(address to, uint256 holderBalance, uint256 payment);\n\n  function mature(\n    bytes32, /* fromState */\n    bytes32 /* toState */\n  ) public {\n    for (uint256 j = 0; j < tokenHolders.length; j++) {\n      uint256 holderBalance = balances[tokenHolders[j]].balance;\n      burn(tokenHolders[j], holderBalance);\n      uint256 payment = (holderBalance * _parValue) / (10**uint256(getDecimalsFor(\"holderBalance\")));\n      emit PaymentCommand(tokenHolders[j], holderBalance, payment);\n    }\n  }\n\n  function convert(\n    bytes32, /* fromState */\n    bytes32 /* toState */\n  ) public {\n    _inFlight = \"NO\";\n    transitionState(STATE_READY_FOR_TOKENIZATION);\n  }\n\n  function coupon() public checkAllowedFunction {\n    bytes32 semi = \"SEMI\";\n    // .mul(1000) is used to avoid rounding issues. .div(1000) is done below in the payment calculation\n    uint256 couponValue = (((_parValue * 1000) * _couponRate) / 100) / (10**uint256(getDecimalsFor(\"_couponRate\")));\n    if (_frequency == semi) {\n      couponValue = couponValue / 2;\n    }\n    for (uint256 j = 0; j < tokenHolders.length; j++) {\n      uint256 holderBalance = balances[tokenHolders[j]].balance;\n      uint256 payment = (holderBalance * couponValue) / (10**uint256(getDecimalsFor(\"holderBalance\"))) / 1000;\n      emit PaymentCommand(tokenHolders[j], holderBalance, payment);\n    }\n  }\n\n  function reset(\n    bytes32, /* fromState */\n    bytes32 /* toState */\n  ) public checkAllowedFunction {\n    _tokenizationAmount = 0;\n    _tokenizationRecipient = address(0x0);\n    transitionState(STATE_READY_FOR_TOKENIZATION);\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n    createState(STATE_CREATED);\n    createState(STATE_TO_REVIEW);\n    createState(STATE_READY_FOR_TOKENIZATION);\n    createState(STATE_CHANGES_NEEDED);\n    createState(STATE_TOKENIZATION_REQUEST);\n    createState(STATE_TOKENIZATION_DENIED);\n    createState(STATE_TOKENIZATION_APPROVED);\n    if (_inFlight == \"YES\") {\n      createState(STATE_CONVERTED);\n    }\n    createState(STATE_MATURED);\n\n    // STATE_CREATED\n    addNextStateForState(STATE_CREATED, STATE_TO_REVIEW);\n    addAllowedFunctionForState(STATE_CREATED, this.edit.selector);\n\n    // STATE_TO_REVIEW\n    addRoleForState(STATE_TO_REVIEW, ROLE_ADMIN);\n    addRoleForState(STATE_TO_REVIEW, ROLE_MAKER);\n    addNextStateForState(STATE_TO_REVIEW, STATE_READY_FOR_TOKENIZATION);\n    addNextStateForState(STATE_TO_REVIEW, STATE_CHANGES_NEEDED);\n\n    // STATE_CHANGES_NEEDED\n    addRoleForState(STATE_CHANGES_NEEDED, ROLE_ADMIN);\n    addRoleForState(STATE_CHANGES_NEEDED, ROLE_CHECKER);\n    addNextStateForState(STATE_CHANGES_NEEDED, STATE_TO_REVIEW);\n    addAllowedFunctionForState(STATE_CHANGES_NEEDED, this.edit.selector);\n\n    // STATE_READY_FOR_TOKENIZATION\n    setPreFunctionForState(STATE_READY_FOR_TOKENIZATION, this.launch.selector);\n    addRoleForState(STATE_READY_FOR_TOKENIZATION, ROLE_ADMIN);\n    addRoleForState(STATE_READY_FOR_TOKENIZATION, ROLE_CHECKER);\n    addNextStateForState(STATE_READY_FOR_TOKENIZATION, STATE_TOKENIZATION_REQUEST);\n    if (_inFlight == \"YES\") {\n      addNextStateForState(STATE_READY_FOR_TOKENIZATION, STATE_CONVERTED);\n    }\n    addNextStateForState(STATE_READY_FOR_TOKENIZATION, STATE_MATURED);\n    addAllowedFunctionForState(STATE_READY_FOR_TOKENIZATION, this.requestTokenization.selector);\n    addAllowedFunctionForState(STATE_READY_FOR_TOKENIZATION, this.coupon.selector);\n    addAllowedFunctionForState(STATE_READY_FOR_TOKENIZATION, this.transfer.selector);\n\n    // STATE_TOKENIZATION_REQUEST\n    setPreFunctionForState(STATE_TOKENIZATION_REQUEST, this.requestTokenization.selector);\n    addRoleForState(STATE_TOKENIZATION_REQUEST, ROLE_ADMIN);\n    addRoleForState(STATE_TOKENIZATION_REQUEST, ROLE_MAKER);\n    addNextStateForState(STATE_TOKENIZATION_REQUEST, STATE_TOKENIZATION_APPROVED);\n    addAllowedFunctionForState(STATE_TOKENIZATION_REQUEST, this.transfer.selector);\n    addNextStateForState(STATE_TOKENIZATION_REQUEST, STATE_TOKENIZATION_DENIED);\n\n    // STATE_TOKENIZATION_DENIED // auto advance\n    addRoleForState(STATE_TOKENIZATION_DENIED, ROLE_ADMIN);\n    addRoleForState(STATE_TOKENIZATION_DENIED, ROLE_CHECKER);\n    addNextStateForState(STATE_TOKENIZATION_DENIED, STATE_READY_FOR_TOKENIZATION);\n    addCallbackForState(STATE_TOKENIZATION_DENIED, reset);\n    addAllowedFunctionForState(STATE_TOKENIZATION_DENIED, this.transfer.selector);\n    addAllowedFunctionForState(STATE_TOKENIZATION_DENIED, this.reset.selector);\n    addAllowedFunctionForState(STATE_TOKENIZATION_DENIED, this.transitionState.selector);\n\n    // STATE_TOKENIZATION_APPROVED // auto advance\n    addRoleForState(STATE_TOKENIZATION_APPROVED, ROLE_ADMIN);\n    addRoleForState(STATE_TOKENIZATION_APPROVED, ROLE_CHECKER);\n    addNextStateForState(STATE_TOKENIZATION_APPROVED, STATE_READY_FOR_TOKENIZATION);\n    addCallbackForState(STATE_TOKENIZATION_APPROVED, tokenize);\n    addAllowedFunctionForState(STATE_TOKENIZATION_APPROVED, this.tokenize.selector);\n    addAllowedFunctionForState(STATE_TOKENIZATION_APPROVED, this.mint.selector);\n    addAllowedFunctionForState(STATE_TOKENIZATION_APPROVED, this.transitionState.selector);\n    addAllowedFunctionForState(STATE_TOKENIZATION_APPROVED, this.transfer.selector);\n    addAllowedFunctionForState(STATE_TOKENIZATION_APPROVED, this.mature.selector);\n    addAllowedFunctionForState(STATE_TOKENIZATION_APPROVED, this.reset.selector);\n\n    if (_inFlight == \"YES\") {\n      // STATE_CONVERTED\n      addRoleForState(STATE_CONVERTED, ROLE_ADMIN);\n      addRoleForState(STATE_CONVERTED, ROLE_CHECKER);\n      addCallbackForState(STATE_CONVERTED, convert);\n      addAllowedFunctionForState(STATE_CONVERTED, this.convert.selector);\n      addAllowedFunctionForState(STATE_CONVERTED, this.burn.selector);\n      addNextStateForState(STATE_CONVERTED, STATE_READY_FOR_TOKENIZATION);\n    }\n\n    // STATE_MATURED\n    addRoleForState(STATE_MATURED, ROLE_ADMIN);\n    addRoleForState(STATE_MATURED, ROLE_CHECKER);\n    addCallbackForState(STATE_MATURED, mature);\n    addAllowedFunctionForState(STATE_MATURED, this.burn.selector);\n\n    setInitialState(STATE_CREATED);\n  }\n\n  /**\n   * @notice Returns the amount of bond holders.\n   * @dev Gets the amount of bond holders, used by the middleware to build a cache you can query.\n   *      You should not need this function in general since iteration this way clientside is very slow.\n   *\n   * @return length An uint256 representing the amount of tokenholders recorded in this contract.\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenHolders.length;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by index\n   * @dev Gets balance of an individual bond holder, used by the middleware to build a cache you can query.\n   *      You should not need this function in general since iteration this way clientside is very slow.\n   *\n   * @param index       used to access the tokenHolders array\n   * @return holder     holder's address\n   * @return balance    the holder's balance\n   */\n  function getByIndex(uint256 index) public view returns (address holder, uint256 balance) {\n    holder = tokenHolders[index];\n    balance = balances[tokenHolders[index]].balance;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by address\n   * @dev Gets balance of an individual bond holder, used by the middleware to build a cache you can query.\n   *      You should not need this function in general since iteration this way clientside is very slow.\n   *\n   * @param key         used to access the token's balances\n   * @return holder     holder's address and balance\n   * @return balance    the holder's balance\n   */\n  function getByKey(address key) public view returns (address holder, uint256 balance) {\n    holder = key;\n    balance = balances[key].balance;\n  }\n}\n"
    },
    "contracts/_library/tokens/ERC20/ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Token.sol\";\nimport \"../IApproveAndCallable.sol\";\nimport \"../IWithDecimalFields.sol\";\nimport \"../../authentication/RoleRegistry.sol\";\n\nabstract contract ERC20Token is IERC20Token, IWithDecimalFields {\n  struct TokenAccount {\n    uint256 balance;\n    uint256 firstTransaction;\n  }\n\n  mapping(address => TokenAccount) balances;\n  address[] tokenHolders;\n  mapping(address => mapping(address => uint256)) internal allowed;\n  uint256 public totalSupply;\n\n  string public _uiFieldDefinitionsHash;\n\n  constructor(\n    string memory name,\n    uint8 decimals,\n    address gateKeeper,\n    string memory uiFieldDefinitionsHash\n  ) IERC20Token(name, decimals, gateKeeper) {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  function mint(address to, uint256 amount)\n    public\n    virtual\n    override\n    authWithCustomReason(MINT_ROLE, \"Sender needs the MINT__ROLE\")\n    returns (bool success)\n  {\n    if (balances[to].firstTransaction == 0) {\n      balances[to].firstTransaction = block.timestamp;\n      tokenHolders.push(to);\n    }\n    totalSupply += amount;\n    balances[to].balance += amount;\n    emit Mint(to, amount);\n    emit Transfer(address(0x0), to, amount);\n    return true;\n  }\n\n  function mintToRoleRegistry(address roleRegistryAddress, uint256 amount)\n    public\n    virtual\n    override\n    authWithCustomReason(MINT_ROLE, \"Sender needs the MINT__ROLE\")\n    returns (bool success)\n  {\n    RoleRegistry roleRegistry = RoleRegistry(roleRegistryAddress);\n    uint256 numberOfUsers = roleRegistry.getIndexLength();\n    for (uint256 counter = 0; counter < numberOfUsers; counter++) {\n      address holder;\n      bool hasRole;\n      (holder, hasRole) = roleRegistry.getByIndex(counter);\n      if (hasRole) {\n        mint(holder, amount);\n      }\n    }\n    return true;\n  }\n\n  function burn(address from, uint256 amount)\n    public\n    virtual\n    override\n    authWithCustomReason(BURN_ROLE, \"Sender needs the BURN_ROLE\")\n    returns (bool success)\n  {\n    require(amount > 0, \"amount should be bigger than 0\");\n    require(amount <= balances[from].balance, \"amount should be less than balance\");\n    balances[from].balance -= amount;\n    totalSupply -= amount;\n    emit Burn(from, amount);\n    emit Transfer(from, address(0x0), amount);\n    return true;\n  }\n\n  function burnFromRoleRegistry(address roleRegistryAddress, uint256 amount)\n    public\n    virtual\n    override\n    authWithCustomReason(BURN_ROLE, \"Sender needs the BURN_ROLE\")\n    returns (bool success)\n  {\n    RoleRegistry roleRegistry = RoleRegistry(roleRegistryAddress);\n    uint256 numberOfUsers = roleRegistry.getIndexLength();\n    for (uint256 counter = 0; counter < numberOfUsers; counter++) {\n      address holder;\n      bool hasRole;\n      (holder, hasRole) = roleRegistry.getByIndex(counter);\n      if (hasRole) {\n        burn(holder, amount);\n      }\n    }\n    return true;\n  }\n\n  function transfer(address to, uint256 value) public virtual override returns (bool success) {\n    require(to != address(0), \"to should not be 0\");\n    require(value <= balances[msg.sender].balance, \"value should be less than balance\");\n\n    if (balances[to].firstTransaction == 0) {\n      balances[to].firstTransaction = block.timestamp;\n      tokenHolders.push(to);\n    }\n\n    balances[msg.sender].balance -= value;\n    balances[to].balance += value;\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function transferWithData(\n    address to,\n    uint256 value,\n    bytes memory data\n  ) public virtual override returns (bool success) {\n    require(transfer(to, value), \"transfer failed\");\n    emit TransferData(msg.sender, to, data);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) public virtual override returns (bool success) {\n    require(to != address(0), \"to should not be null\");\n    require(value <= balances[from].balance, \"value should be less than balance\");\n    require(value <= allowed[from][msg.sender], \"value should be less than allowance\");\n\n    if (balances[to].firstTransaction == 0) {\n      balances[to].firstTransaction = block.timestamp;\n      tokenHolders.push(to);\n    }\n\n    balances[from].balance -= value;\n    balances[to].balance += value;\n    allowed[from][msg.sender] -= value;\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n  function transferFromWithData(\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data\n  ) public virtual override returns (bool success) {\n    require(transferFrom(from, to, value), \"transfer failed\");\n    emit TransferData(from, to, data);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public virtual override returns (bool) {\n    allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev ApproveAndCall the passed address to spend the specified amount of tokens on behalf of msg.sender and call\n   * the receiveApproval function on that contract. This allows users to use their tokens to interact with\n   * contracts in one function call instead of two.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   * @param data Extra data to be sent along the call.\n   */\n  function approveAndCall(\n    address spender,\n    uint256 value,\n    bytes memory data\n  ) public returns (bool success) {\n    require(approve(spender, value), \"Could not approve amount for spender\");\n    IApproveAndCallable(spender).receiveApproval(msg.sender, value, address(this), data);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param owner The address which owns the funds.\n   * @param spender The address which will spend the funds.\n   * @return remaining A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address owner, address spender) public view override returns (uint256 remaining) {\n    return allowed[owner][spender];\n  }\n\n  /**\n   * @dev approve should be called when allowed[spender] == 0. To increment\n   * allowed value it's better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined).\n   * From MonolithDAO ERC20Token.sol\n   */\n  function increaseApproval(address spender, uint256 addedValue) public override returns (bool success) {\n    allowed[msg.sender][spender] += addedValue;\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseApproval(address spender, uint256 subtractedValue) public override returns (bool success) {\n    uint256 oldValue = allowed[msg.sender][spender];\n    if (subtractedValue > oldValue) {\n      allowed[msg.sender][spender] = 0;\n    } else {\n      allowed[msg.sender][spender] = oldValue - subtractedValue;\n    }\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param owner The address to query the the balance of.\n   * @return balance An uint256 representing the amount owned by the passed address.\n   */\n  function balanceOf(address owner) public view override returns (uint256 balance) {\n    return balances[owner].balance;\n  }\n\n  function setIpfsFieldContainerHash(string memory ipfsHash)\n    public\n    override\n    authWithCustomReason(UPDATE_IPFSCONTAINERHASH_ROLE, \"Sender needs UPDATE_IPFSCONTAINERHASH_ROLE\")\n  {\n    super.setIpfsFieldContainerHash(ipfsHash);\n  }\n}\n"
    },
    "contracts/_library/tokens/ERC20/IERC20Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../utility/syncing/Syncable.sol\";\nimport \"../../authentication/Secured.sol\";\nimport \"../../utility/metadata/IpfsFieldContainer.sol\";\n\nabstract contract IERC20Token is Secured, Syncable, IpfsFieldContainer {\n  bytes32 public constant MINT_ROLE = \"MINT_ROLE\";\n  bytes32 public constant BURN_ROLE = \"BURN_ROLE\";\n\n  string public _name;\n  uint8 public _decimals;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event TransferData(address indexed from, address indexed to, bytes data);\n  event Mint(address indexed to, uint256 amount);\n  event Burn(address indexed from, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  constructor(\n    string memory name,\n    uint8 decimals,\n    address gateKeeper\n  ) Secured(gateKeeper) {\n    _name = name;\n    _decimals = decimals;\n  }\n\n  function mint(address to, uint256 amount) public virtual returns (bool success);\n\n  function mintToRoleRegistry(address roleRegistryAddress, uint256 amount) public virtual returns (bool success);\n\n  function burn(address from, uint256 amount) public virtual returns (bool success);\n\n  function burnFromRoleRegistry(address roleRegistryAddress, uint256 amount) public virtual returns (bool success);\n\n  function transfer(address to, uint256 value) public virtual returns (bool success);\n\n  function transferWithData(\n    address to,\n    uint256 value,\n    bytes memory data\n  ) public virtual returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) public virtual returns (bool success);\n\n  function transferFromWithData(\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data\n  ) public virtual returns (bool success);\n\n  function approve(address spender, uint256 value) public virtual returns (bool);\n\n  function allowance(address owner, address spender) public view virtual returns (uint256 remaining);\n\n  function increaseApproval(address spender, uint256 addedValue) public virtual returns (bool success);\n\n  function decreaseApproval(address spender, uint256 subtractedValue) public virtual returns (bool success);\n\n  function balanceOf(address owner) public view virtual returns (uint256 balance);\n}\n"
    },
    "contracts/_library/tokens/IApproveAndCallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nabstract contract IApproveAndCallable {\n  event ReceivedApproval(address from, uint256 amount, address token, bytes _data);\n\n  function receiveApproval(\n    address _from,\n    uint256 _amount,\n    address _token,\n    bytes memory _data\n  ) public virtual;\n}\n"
    },
    "contracts/_library/tokens/IWithDecimalFields.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nabstract contract IWithDecimalFields {\n  function getDecimalsFor(bytes memory fieldName) public view virtual returns (uint256);\n}\n"
    },
    "contracts/_library/authentication/RoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IRoleRegistry.sol\";\nimport \"./Secured.sol\";\nimport \"../utility/syncing/Syncable.sol\";\n\n/**\n * @title Base contract for role registries\n * @dev The RoleRegistry contract defines the methods and data structures to\n * record if addresses have certain roles or not.\n */\ncontract RoleRegistry is IRoleRegistry, Syncable, Secured {\n  bytes32 public constant DESIGNATE_ROLE = bytes32(\"DESIGNATE_ROLE\");\n\n  struct RoleHolderContainer {\n    bool roleDesignated;\n    uint256 creationDate;\n  }\n\n  mapping(address => RoleHolderContainer) private roleHolders;\n  address[] private roleHoldersIndex;\n\n  constructor(address _gateKeeper) Secured(_gateKeeper) {\n    emit RoleRegistryCreated(address(this));\n  }\n\n  /**\n   * @notice Returns a list of all the holders of this role.\n   * @dev Returns a list of all the holders of this role.\n   * @return allRoleHolders array with all role holders' addresses\n   */\n  function getRoleHolders() public view returns (address[] memory allRoleHolders) {\n    return roleHoldersIndex;\n  }\n\n  /**\n   * @notice Checks if an address has this role\n   * @dev Checks if `_address` has given the role managed by this role registry\n   * @param _address The address to check for the role.\n   * @return hasTheRole A boolean that is True if the address has the role.\n   */\n  function hasRole(address _address) public view override returns (bool hasTheRole) {\n    hasTheRole = roleHolders[_address].roleDesignated;\n  }\n\n  /**\n   * @notice Gives the role to an address\n   * @dev Gives the role managed by this role registry to `_address`. Access is limited by the ACL.\n   * @param _address The address to designate the role to.\n   */\n  function designate(address _address)\n    public\n    override\n    authWithCustomReason(DESIGNATE_ROLE, \"Sender needs DESIGNATE_ROLE\")\n  {\n    if (roleHolders[_address].creationDate == 0) {\n      roleHoldersIndex.push(_address);\n      roleHolders[_address].creationDate = block.timestamp;\n    }\n    roleHolders[_address].roleDesignated = true;\n    emit Designated(_address);\n  }\n\n  /**\n   * @notice Removes the role from an address\n   * @dev Removes the role from `_address`. Access is limited by the ACL.\n   * @param _address The address to discharge fromn the role.\n   */\n  function discharge(address _address)\n    public\n    override\n    authWithCustomReason(DESIGNATE_ROLE, \"Sender needs DESIGNATE_ROLE\")\n  {\n    require(roleHolders[_address].creationDate > 0, \"This address was never designated to this role\");\n\n    uint256 i = 0;\n    while (roleHoldersIndex[i] != _address) {\n      i++;\n    }\n    for (uint256 j = i; j < roleHoldersIndex.length - 1; j++) {\n      roleHoldersIndex[j] = roleHoldersIndex[j + 1];\n    }\n    roleHoldersIndex.pop();\n\n    roleHolders[_address].roleDesignated = false;\n    emit Discharged(_address);\n  }\n\n  /**\n   * @notice Returns the length of the index array\n   * @dev Returns the length of the index array\n   * @return length the amount of items in the index array\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = roleHoldersIndex.length;\n  }\n\n  /**\n   * @notice Returns the information for the key at a given index\n   * @dev Returns the information for the key at index `_index`\n   * @param _index The index of the key in the key array\n   * @return key the information for the key on a certain index\n   */\n  function getByIndex(uint256 _index) public view returns (address key, bool hasTheRole) {\n    key = roleHoldersIndex[_index];\n    hasTheRole = roleHolders[roleHoldersIndex[_index]].roleDesignated;\n  }\n\n  /**\n   * @notice Returns the information for the key\n   * @dev Returns the information for the key `_key`\n   * @param _key The key to get the info for\n   * @return key the information for the key\n   */\n  function getByKey(address _key) public view returns (address key, bool hasTheRole) {\n    key = _key;\n    hasTheRole = roleHolders[_key].roleDesignated;\n  }\n}\n"
    },
    "contracts/statefulbonds/StatefulBondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"../_library/tokens/IWithDecimalFields.sol\";\nimport \"./StatefulBond.sol\";\nimport \"./StatefulBondRegistry.sol\";\n\n/**\n * @title Factory contract for stateful bond state machines\n */\ncontract StatefulBondFactory is StateMachineFactory, IWithDecimalFields {\n  uint8 internal _parValueDecimal;\n  uint8 internal _couponRateDecimal;\n\n  constructor(GateKeeper gateKeeper, StatefulBondRegistry registry) StateMachineFactory(gateKeeper, registry) {\n    _parValueDecimal = 2;\n    _couponRateDecimal = 2;\n  }\n\n  event TokenCreated(address _address, string _name);\n\n  /**\n   * @notice Create new stateful bond\n   * @dev Factory method to create a new stateful bond. Emits StateMachineCreated event.\n   */\n  function create(\n    string memory name,\n    uint256 parValue,\n    uint256 couponRate,\n    uint8 decimals,\n    bytes32 inFlight,\n    bytes32 frequency,\n    string memory ipfsFieldContainerHash\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    StatefulBond statefulBond = new StatefulBond(\n      name,\n      parValue,\n      couponRate,\n      decimals,\n      inFlight,\n      frequency,\n      gateKeeper,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = statefulBond.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(statefulBond),\n        roles[i],\n        address(this)\n      );\n    }\n\n    gateKeeper.createPermission(msg.sender, address(statefulBond), bytes32(\"MINT_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(statefulBond), bytes32(\"BURN_ROLE\"), msg.sender);\n\n    _registry.insert(address(statefulBond));\n    emit StateMachineCreated(address(statefulBond));\n    emit TokenCreated(address(statefulBond), name);\n  }\n\n  function getDecimalsFor(bytes memory fieldName) public view override returns (uint256) {\n    if (keccak256(fieldName) == keccak256(\"_parValue\")) {\n      return _parValueDecimal;\n    }\n    if (keccak256(fieldName) == keccak256(\"_couponRate\")) {\n      return _couponRateDecimal;\n    }\n    return 0;\n  }\n}\n"
    },
    "contracts/statefulbonds/StatefulBondRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for stateful bond state machines\n */\ncontract StatefulBondRegistry is StateMachineRegistry {\n  constructor(address gateKeeper) StateMachineRegistry(gateKeeper) {}\n}\n"
    },
    "contracts/share/Share.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20Token.sol\";\n\n/**\n * @title A fungible, ERC20-based token\n */\ncontract Share is ERC20Token {\n  constructor(\n    string memory name,\n    uint8 decimals,\n    address gateKeeper,\n    string memory uiFieldDefinitionsHash\n  ) ERC20Token(name, decimals, gateKeeper, uiFieldDefinitionsHash) {}\n\n  bytes32 public constant EDIT_ROLE = \"EDIT_ROLE\";\n\n  function getDecimalsFor(\n    bytes memory /*fieldName*/\n  ) public view override returns (uint256) {\n    return _decimals;\n  }\n\n  /**\n   * @notice Updates the token's name and number of decimals\n   * @dev Restricted to user with the \"EDIT_ROLE\" permission\n   * @param name the token's new name\n   * @param decimals the token's new number of decimals\n   */\n  function edit(string memory name, uint8 decimals) public auth(EDIT_ROLE) {\n    _name = name;\n    _decimals = decimals;\n  }\n\n  /**\n   * @notice Returns the amount of tokenholders recorded in this contract\n   * @dev Gets the amount of token holders, used by the middleware to build a cache you can query. You should not need this function in general since iteration this way clientside is very slow.\n   * @return length An uint256 representing the amount of tokenholders recorded in this contract.\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenHolders.length;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by index\n   * @param index used to access the tokenHolders array\n   * @return holder holder's address and balance\n   */\n  function getByIndex(uint256 index) public view returns (address holder, uint256 balance) {\n    holder = tokenHolders[index];\n    balance = balances[tokenHolders[index]].balance;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by address\n   * @param key used to access the token's balances\n   * @return holder holder's address and balance\n   */\n  function getByKey(address key) public view returns (address holder, uint256 balance) {\n    holder = key;\n    balance = balances[key].balance;\n  }\n}\n"
    },
    "contracts/share/ShareFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenFactory.sol\";\nimport \"./Share.sol\";\n\n/**\n * @title Factory contract for ERC20-based tokens\n */\ncontract ShareFactory is ERC20TokenFactory {\n  constructor(address registry, address gk) ERC20TokenFactory(registry, gk) {}\n\n  /**\n   * @notice Factory method to create new ERC20-based tokens.\n   * @dev Factory method to create new ERC20-based tokens. Access is limited by the ACL.\n   * @param name the token's name\n   * @param decimals the token's number of decimals\n   */\n  function createToken(string memory name, uint8 decimals)\n    public\n    authWithCustomReason(CREATE_TOKEN_ROLE, \"Sender needs CREATE_TOKEN_ROLE\")\n  {\n    Share newToken = new Share(name, decimals, address(gateKeeper), _uiFieldDefinitionsHash);\n    _tokenRegistry.addToken(name, address(newToken));\n    emit TokenCreated(address(newToken), name);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"MINT_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"BURN_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"UPDATE_METADATA_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"EDIT_ROLE\"), msg.sender);\n  }\n}\n"
    },
    "contracts/_library/tokens/ERC20/ERC20TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Token.sol\";\nimport \"./IERC20TokenRegistry.sol\";\nimport \"./IERC20TokenFactory.sol\";\nimport \"../../utility/ui/UIFieldDefinitions.sol\";\n\nabstract contract ERC20TokenFactory is UIFieldDefinitions, IERC20TokenFactory {\n  constructor(address registry, address gateKeeper) IERC20TokenFactory(registry, gateKeeper) {}\n\n  // NOT IMPLEMENTED IN HERE BECAUSE THE IMPLEMENTATION IS OFTEN DIFFERENT\n  // function createToken(string memory name, uint8 decimals) public virtual;\n\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash)\n    public\n    override\n    authWithCustomReason(UPDATE_UIFIELDDEFINITIONS_ROLE, \"Sender needs UPDATE_UIFIELDDEFINITIONS_ROLE\")\n  {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  function getUIFieldDefinitionsHash() public view override returns (string memory) {\n    return _uiFieldDefinitionsHash;\n  }\n}\n"
    },
    "contracts/_library/tokens/ERC20/IERC20TokenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../utility/syncing/Syncable.sol\";\nimport \"../../authentication/Secured.sol\";\nimport \"./IERC20Token.sol\";\n\nabstract contract IERC20TokenRegistry is Secured, Syncable {\n  bytes32 public constant LIST_TOKEN_ROLE = \"LIST_TOKEN_ROLE\";\n\n  mapping(string => IERC20Token) public tokens;\n  string[] public tokenIndex;\n\n  constructor(address gateKeeper) Secured(gateKeeper) {}\n\n  function addToken(string memory name, address token) public virtual;\n}\n"
    },
    "contracts/_library/tokens/ERC20/IERC20TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\nimport \"./IERC20Token.sol\";\nimport \"./IERC20TokenRegistry.sol\";\n\ncontract IERC20TokenFactory is Secured {\n  bytes32 public constant CREATE_TOKEN_ROLE = \"CREATE_TOKEN_ROLE\";\n  IERC20TokenRegistry internal _tokenRegistry;\n\n  event TokenCreated(address _address, string _name);\n\n  constructor(address tokenRegistry, address gateKeeper) Secured(gateKeeper) {\n    _tokenRegistry = IERC20TokenRegistry(tokenRegistry);\n  }\n}\n"
    },
    "contracts/loyaltypoint/LoyaltyPointFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenFactory.sol\";\nimport \"./LoyaltyPoint.sol\";\n\n/**\n * @title Factory contract for ERC20-based LoyaltyPoint token\n */\ncontract LoyaltyPointFactory is ERC20TokenFactory {\n  constructor(address registry, address gk) ERC20TokenFactory(registry, gk) {}\n\n  /**\n   * @notice Factory method to create new LoyaltyPoint token.\n   * @dev Restricted to user with the \"CREATE_TOKEN_ROLE\" permission.\n   * @param name the token's name\n   * @param decimals the token's number of decimals\n   */\n  function createToken(string memory name, uint8 decimals)\n    public\n    authWithCustomReason(CREATE_TOKEN_ROLE, \"Sender needs CREATE_TOKEN_ROLE\")\n  {\n    LoyaltyPoint newToken = new LoyaltyPoint(name, decimals, address(gateKeeper), _uiFieldDefinitionsHash);\n    _tokenRegistry.addToken(name, address(newToken));\n    emit TokenCreated(address(newToken), name);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"MINT_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"BURN_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"UPDATE_METADATA_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"EDIT_ROLE\"), msg.sender);\n  }\n}\n"
    },
    "contracts/loyaltypoint/LoyaltyPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20Token.sol\";\n\n/**\n * @title A fungible, ERC20-based token\n */\ncontract LoyaltyPoint is ERC20Token {\n  constructor(\n    string memory name,\n    uint8 decimals,\n    address gateKeeper,\n    string memory uiFieldDefinitionsHash\n  ) ERC20Token(name, decimals, gateKeeper, uiFieldDefinitionsHash) {}\n\n  bytes32 public constant EDIT_ROLE = \"EDIT_ROLE\";\n\n  function getDecimalsFor(\n    bytes memory /*fieldName*/\n  ) public view override returns (uint256) {\n    return _decimals;\n  }\n\n  /**\n   * @notice Updates the token's name and number of decimals\n   * @dev Restricted to user with the \"EDIT_ROLE\" permission\n   * @param name the token's new name\n   * @param decimals the token's new number of decimals\n   */\n  function edit(string memory name, uint8 decimals) public auth(EDIT_ROLE) {\n    _name = name;\n    _decimals = decimals;\n  }\n\n  /**\n   * @notice Returns the amount of tokenholders recorded in this contract\n   * @dev Gets the amount of token holders, used by the middleware to build a cache you can query. You should not need this function in general since iteration this way clientside is very slow.\n   * @return length An uint256 representing the amount of tokenholders recorded in this contract.\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenHolders.length;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by index\n   * @param index used to access the tokenHolders array\n   * @return holder holder's address and balance\n   */\n  function getByIndex(uint256 index) public view returns (address holder, uint256 balance) {\n    holder = tokenHolders[index];\n    balance = balances[tokenHolders[index]].balance;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by address\n   * @param key used to access the token's balances\n   * @return holder holder's address and balance\n   */\n  function getByKey(address key) public view returns (address holder, uint256 balance) {\n    holder = key;\n    balance = balances[key].balance;\n  }\n}\n"
    },
    "contracts/loan/LoanFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenFactory.sol\";\nimport \"./Loan.sol\";\n\n/**\n * @title Factory contract for ERC20-based Loan token\n */\ncontract LoanFactory is ERC20TokenFactory {\n  constructor(address registry, address gk) ERC20TokenFactory(registry, gk) {}\n\n  /**\n   * @notice Factory method to create new ERC20-based Loan token.\n   * @dev Restricted to user with the \"CREATE_TOKEN_ROLE\" permission.\n   * @param name the token's name\n   * @param decimals the token's number of decimals\n   */\n  function createToken(string memory name, uint8 decimals)\n    public\n    authWithCustomReason(CREATE_TOKEN_ROLE, \"Sender needs CREATE_TOKEN_ROLE\")\n  {\n    Loan newToken = new Loan(name, decimals, address(gateKeeper), _uiFieldDefinitionsHash);\n    _tokenRegistry.addToken(name, address(newToken));\n    emit TokenCreated(address(newToken), name);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"REPAY_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"MINT_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"BURN_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"UPDATE_METADATA_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"EDIT_ROLE\"), msg.sender);\n  }\n}\n"
    },
    "contracts/loan/Loan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20Token.sol\";\n\n/**\n * @title Fungible token that records repayments.\n */\ncontract Loan is ERC20Token {\n  constructor(\n    string memory name,\n    uint8 decimals,\n    address gateKeeper,\n    string memory uiFieldDefinitionsHash\n  ) ERC20Token(name, decimals, gateKeeper, uiFieldDefinitionsHash) {}\n\n  struct LoanMetrics {\n    uint256 loaned;\n    uint256 repayed;\n  }\n\n  mapping(address => LoanMetrics) public loans;\n\n  bytes32 public constant REPAY_ROLE = \"REPAY_ROLE\";\n  bytes32 public constant EDIT_ROLE = \"EDIT_ROLE\";\n\n  event Repayment(address from, uint256 value);\n\n  function getDecimalsFor(\n    bytes memory /*fieldName*/\n  ) public view override returns (uint256) {\n    return _decimals;\n  }\n\n  /**\n   * @notice Updates the token's name and number of decimals\n   * @dev Restricted to user with the \"EDIT_ROLE\" permission\n   * @param name the token's new name\n   * @param decimals the token's new number of decimals\n   */\n  function edit(string memory name, uint8 decimals) public auth(EDIT_ROLE) {\n    _name = name;\n    _decimals = decimals;\n  }\n\n  /**\n   * @notice Increases the amount borrowed for an address\n   * @param to the address of the borrower\n   * @param amount the amount borrowed\n   * @return success a boolean value indicating success or failure\n   */\n  function mint(address to, uint256 amount) public override auth(MINT_ROLE) returns (bool success) {\n    loans[to].loaned = loans[to].loaned + amount;\n    return super.mint(to, amount);\n  }\n\n  /**\n   * @notice Increases the amount repayed for an address\n   * @param from the address of the borrower\n   * @param amount the amount repayed\n   * @return success a boolean value indicating success or failure\n   */\n  function repay(address from, uint256 amount) public auth(REPAY_ROLE) returns (bool success) {\n    loans[from].repayed = loans[from].repayed + amount;\n    emit Repayment(from, amount);\n    return true;\n  }\n\n  /**\n   * @notice Returns the outstanding amount borrowed for an address\n   * @param owner the address of the borrower\n   * @return outstanding the outstanding amount borrowed\n   */\n  function outstandingOf(address owner) public view returns (int256 outstanding) {\n    return int256(loans[owner].loaned - loans[owner].repayed);\n  }\n\n  /**\n   * @notice Returns the amount of tokenholders recorded in this contract\n   * @dev Gets the amount of token holders, used by the middleware to build a cache you can query. You should not need this function in general since iteration this way clientside is very slow.\n   * @return length An uint256 representing the amount of tokenholders recorded in this contract.\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenHolders.length;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by index\n   * @param index used to access the tokenHolders array\n   * @return holder holder's address, balance, amount loaned and amount repayed\n   */\n  function getByIndex(uint256 index)\n    public\n    view\n    returns (\n      address holder,\n      uint256 balance,\n      uint256 loaned,\n      uint256 repayed\n    )\n  {\n    holder = tokenHolders[index];\n    balance = balances[tokenHolders[index]].balance;\n    loaned = loans[tokenHolders[index]].loaned;\n    repayed = loans[tokenHolders[index]].repayed;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by address\n   * @param key used to access the token's balances and loans properties\n   * @return holder holder's address, balance, amount loaned and amount repayed\n   */\n  function getByKey(address key)\n    public\n    view\n    returns (\n      address holder,\n      uint256 balance,\n      uint256 loaned,\n      uint256 repayed\n    )\n  {\n    holder = key;\n    balance = balances[key].balance;\n    loaned = loans[key].loaned;\n    repayed = loans[key].repayed;\n  }\n}\n"
    },
    "contracts/currency/CurrencyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenFactory.sol\";\nimport \"./Currency.sol\";\n\n/**\n * @title Factory contract for ERC20-based currency token\n */\ncontract CurrencyFactory is ERC20TokenFactory {\n  constructor(address registry, address gk) ERC20TokenFactory(registry, gk) {}\n\n  /**\n   * @notice Factory method to create new ERC20-based currency token.\n   * @dev Restricted to user with the \"CREATE_TOKEN_ROLE\" permission.\n   * @param name bytes32\n   * @param decimals bytes32\n   */\n  function createToken(string memory name, uint8 decimals)\n    public\n    authWithCustomReason(CREATE_TOKEN_ROLE, \"Sender needs CREATE_TOKEN_ROLE\")\n  {\n    Currency newToken = new Currency(name, decimals, address(gateKeeper), _uiFieldDefinitionsHash);\n    _tokenRegistry.addToken(name, address(newToken));\n    emit TokenCreated(address(newToken), name);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"MINT_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"BURN_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"UPDATE_METADATA_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"EDIT_ROLE\"), msg.sender);\n  }\n}\n"
    },
    "contracts/currency/Currency.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20Token.sol\";\n\n/**\n * @title Fungible coin without restrictions\n */\ncontract Currency is ERC20Token {\n  constructor(\n    string memory name,\n    uint8 decimals,\n    address gateKeeper,\n    string memory uiFieldDefinitionsHash\n  ) ERC20Token(name, decimals, gateKeeper, uiFieldDefinitionsHash) {}\n\n  bytes32 public constant EDIT_ROLE = \"EDIT_ROLE\";\n\n  function getDecimalsFor(\n    bytes memory /*fieldName*/\n  ) public view override returns (uint256) {\n    return _decimals;\n  }\n\n  /**\n   * @notice Update the currency's name and number of decimals\n   * @dev Set new values for the currency's name and number of decimals. Restricted to users with \"EDIT_ROLE\" permissions\n   * @param name bytes32 Updated name\n   * @param decimals uint8 Updated decimals\n   */\n  function edit(string memory name, uint8 decimals) public auth(EDIT_ROLE) {\n    _name = name;\n    _decimals = decimals;\n  }\n\n  /**\n   * @notice Returns the amount of tokenholders recorded in this contract\n   * @dev Gets the amount of token holders, used by the middleware to build a cache you can query. You should not need this function in general since iteration this way clientside is very slow.\n   * @return length An uint256 representing the amount of tokenholders recorded in this contract.\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenHolders.length;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by index\n   * @param index used to access the tokenHolders array\n   * @return holder holder's address and balance\n   */\n  function getByIndex(uint256 index) public view returns (address holder, uint256 balance) {\n    holder = tokenHolders[index];\n    balance = balances[tokenHolders[index]].balance;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by address\n   * @param key used to access the token's balances\n   * @return holder holder's address and balance\n   */\n  function getByKey(address key) public view returns (address holder, uint256 balance) {\n    holder = key;\n    balance = balances[key].balance;\n  }\n}\n"
    },
    "contracts/bonds/Bond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../currency/Currency.sol\";\nimport \"../_library/tokens/ERC20/ERC20Token.sol\";\n\n/**\n * IPFS Fields\n * - isin             ISIN are unique serial numbers for all bond offerings issued by the ISIN organization. ISIN is\n *                    a global catalogue of bonds and other securities.\n * - issuer           Issuer is the entity that is raising capital in the primary debt market.\n */\n\n/**\n * @title Bond\n * @notice A bond is a debt security that corporations and governments use to raise capital. It provides an investor\n *         the means to loan money to an issuer for a defined period of time. In return, the investor will receive variable\n *         or fixed interest payments periodically throughout the loaning period.\n */\ncontract Bond is ERC20Token {\n  bytes32 public constant EDIT_ROLE = \"EDIT_ROLE\";\n\n  uint256 public _parValue;\n  Currency public _parCurrency;\n  uint256 public _issuanceDate;\n  uint256 public _maturityPeriod;\n  uint256 public _couponRate;\n  uint256 private _couponAmountPerBondPerSixMonths;\n  uint256 public _couponPeriod;\n  uint256 private _numSixMonthsPerCoupon;\n  uint256 public _launchDate;\n  uint256 public _maturityDate;\n  uint256 private month = 4 * 7 * 24 * 3600;\n  uint256 private parDecimals;\n\n  struct Coupon {\n    bool inititated;\n    uint256 totalCouponAmount;\n    uint256 redeemedCouponAmount;\n    address[] holdersAtCouponDate; // the list of addresses that held the bond at this coupon date\n    uint256[] amountsAtCouponDate;\n  }\n\n  Coupon[] public _coupons;\n  uint256[] public _couponDates;\n\n  /**\n   * @notice Creates a new bond\n   *\n   * @param name             A clear name of for the bond for humans.\n   * @param parValue         The principal amount is the amount paid out to the holder of the bond at its maturity date.\n   *                         It is also known as the “par value”. The principal amount is the reference amount used to\n   *                         calculate interest payments. (amount * 10^decimals of the currency)\n   * @param parCurrency      The currency of the par value\n   * @param maturityPeriod   The maturity period is an amount of months after the issuance date when the bond matures and the\n   *                         bond issuer must pay the principal amount to bondholders. (number of months after the issuance date)\n   * @param couponRate       The coupon rate is the annual rate of interest (expressed as a percentage) the bond issuer\n   *                         pays out to bondholders on the principal amount of the bond at each coupon payment date. Coupon\n   *                         payments compensate investors for the risk of loaning capital to the issuer. (percentage * 100)\n   * @param couponPeriod     The coupon period is the frequency that the bond issuer will make coupon payments to bondholders.\n   *                         Typically, this is either semi-annual or annual. (number of months between coupons)\n   * @param decimals         The granularity into which a single bond can be tokenized.\n   * @param gateKeeper       The gatekeeper is the smart contract which handles the permissions on this bond.\n   * @param ipfsFieldContainerHash The IPFS hash to all the fields that are not on chain.\n   * @param uiFieldDefinitionsHash The IPFS hash to the field definitions for the UI\n   */\n  constructor(\n    string memory name,\n    uint256 parValue,\n    Currency parCurrency,\n    uint256 maturityPeriod,\n    uint256 couponRate,\n    uint256 couponPeriod,\n    uint8 decimals,\n    GateKeeper gateKeeper,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) ERC20Token(name, decimals, address(gateKeeper), uiFieldDefinitionsHash) {\n    require(\n      (maturityPeriod / couponPeriod) * couponPeriod == maturityPeriod,\n      \"The maturity period needs to be a multiple of the coupon period\"\n    );\n    _name = name;\n    _parValue = parValue;\n    _parCurrency = parCurrency;\n    parDecimals = _parCurrency._decimals();\n    _maturityPeriod = maturityPeriod;\n    _couponRate = couponRate;\n    _couponPeriod = couponPeriod;\n    _numSixMonthsPerCoupon = couponPeriod / 6;\n    _couponAmountPerBondPerSixMonths = (parValue * (couponRate / 2)) / 100;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  function getDecimalsFor(bytes memory fieldName) public view override returns (uint256) {\n    if (keccak256(fieldName) == keccak256(\"parValue\")) {\n      return parDecimals;\n    } else {\n      return _decimals;\n    }\n  }\n\n  /**\n   * @notice Updates most of the settings of a bond if the bond has not launched yet and the user had the EDIT_ROLE.\n   *\n   * @param name             A clear name of for the bond for humans.\n   * @param parValue         The principal amount is the amount paid out to the holder of the bond at its maturity date.\n   *                         It is also known as the “par value”. The principal amount is the reference amount used to\n   *                         calculate interest payments. (amount * 10^decimals of the currency)\n   * @param parCurrency      The currency of the par value\n   * @param maturityPeriod   The maturity period is an amount of months after the issuance date when the bond matures and the\n   *                         bond issuer must pay the principal amount to bondholders. (number of months after the issuance date)\n   * @param couponRate       The coupon rate is the annual rate of interest (expressed as a percentage) the bond issuer\n   *                         pays out to bondholders on the principal amount of the bond at each coupon payment date. Coupon\n   *                         payments compensate investors for the risk of loaning capital to the issuer. (percentage * 100)\n   * @param couponPeriod     The coupon period is the frequency that the bond issuer will make coupon payments to bondholders.\n   *                         Typically, this is either semi-annual or annual. (number of months between coupons)\n   * @param decimals         The granularity into which a single bond can be tokenized.\n   * @param ipfsFieldContainerHash The IPFS hash to all the fields that are not on chain.\n   */\n  function edit(\n    string memory name,\n    uint256 parValue,\n    Currency parCurrency,\n    uint256 maturityPeriod,\n    uint256 couponRate,\n    uint256 couponPeriod,\n    uint8 decimals,\n    string memory ipfsFieldContainerHash\n  ) public auth(EDIT_ROLE) {\n    require(\n      _launchDate == 0 || block.timestamp < _launchDate,\n      \"It is forbidden to edit a bond after it has been launched to the investors\"\n    );\n    require(\n      maturityPeriod % 6 == 0 && couponPeriod % 6 == 0,\n      \"The maturity and coupon period needs to be a multiple of the 6 months\"\n    );\n    require(\n      maturityPeriod >= couponPeriod,\n      \"The maturityPeriod period needs to be at least as long as the coupon period\"\n    );\n\n    _name = name;\n    _parValue = parValue;\n    _parCurrency = parCurrency;\n    parDecimals = _parCurrency._decimals();\n    _maturityPeriod = maturityPeriod;\n    _couponRate = couponRate;\n    _couponPeriod = couponPeriod;\n    _numSixMonthsPerCoupon = couponPeriod / 6;\n    _couponAmountPerBondPerSixMonths = (parValue * (couponRate / 2)) / 10**parDecimals;\n    _decimals = decimals;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    if (_issuanceDate > 0) {\n      _maturityDate = _issuanceDate + _maturityPeriod * month;\n    }\n  }\n\n  /**\n   * @param issuanceDate     The date the bond is officially issued. This marks the start of the maturityPeriod (unix timestamp)\n   */\n  function setIssuanceDate(uint256 issuanceDate) public {\n    require(\n      _launchDate == 0 || block.timestamp < _launchDate,\n      \"It is forbidden to edit a bond after it has been launched to the investors\"\n    );\n    _issuanceDate = issuanceDate;\n    _maturityDate = issuanceDate + _maturityPeriod * month;\n  }\n\n  /**\n   * @notice Releases the issuance to investors at a certain date and time\n   *\n   * @param launchDate the launch date or announcement date is the date at which the details regarding a new issue\n   *                   are released to investors.\n   */\n  function launch(uint256 launchDate) public {\n    require(_launchDate == 0, \"This bond is already launched\");\n    require(_launchDate <= _issuanceDate, \"A bond can only be launched after or on the issuance date\");\n    _launchDate = launchDate;\n    createCoupons();\n  }\n\n  /**\n   * @notice Create the entries for the coupons.\n   */\n  function createCoupons() private {\n    require(_coupons.length == 0, \"Coupons are already initialized, re-initialization is not allowed\");\n    uint256 amountOfCoupons = _maturityPeriod / _couponPeriod;\n    for (uint256 i = 1; i <= amountOfCoupons; i++) {\n      uint256 couponDate = _issuanceDate + i * (month * _couponPeriod);\n      _couponDates.push(couponDate);\n      _coupons.push();\n    }\n  }\n\n  /**\n   * @notice Function to run on each transfer, mint, burn and mature (action that changes the holders) to update the coupons\n   *         with the holders at that time. It does not matter if there is no movement, because then it will be the current\n   *         holder list.\n   */\n  function updateCoupons() public {\n    for (uint256 i = 0; i < _couponDates.length; i++) {\n      uint256 couponDate = _couponDates[i];\n      Coupon storage coupon = _coupons[i];\n      if (couponDate < block.timestamp && !coupon.inititated) {\n        coupon.inititated = true;\n        coupon.holdersAtCouponDate = tokenHolders;\n        for (uint256 j = 0; j < tokenHolders.length; j++) {\n          uint256 holderBalance = balances[tokenHolders[j]].balance;\n          uint256 couponAmount = (holderBalance / uint256(10)**parDecimals) *\n            _couponAmountPerBondPerSixMonths *\n            _numSixMonthsPerCoupon;\n          coupon.totalCouponAmount = coupon.totalCouponAmount + couponAmount;\n          coupon.amountsAtCouponDate.push(couponAmount);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Redeems the coupons for the supplied holder that have not been redeemed yet and have vested.\n   * @dev Note that this will fail when the contract has not enough currency balance to pay out the entire un-redeemed\n   *      balance of the coupon.\n   * @param holder The address of the account to redeem all unredeemed and vested coupons for.\n   */\n  function redeemCoupons(address holder) public {\n    updateCoupons();\n    for (uint256 i = 0; i < _couponDates.length; i++) {\n      uint256 couponDate = _couponDates[i];\n      if (couponDate < block.timestamp) {\n        Coupon storage coupon = _coupons[i];\n        uint256 totalCouponAmount = coupon.totalCouponAmount;\n        require(\n          _parCurrency.balanceOf(address(this)) >= totalCouponAmount - coupon.redeemedCouponAmount,\n          \"There are not enough funds in the currency assigned to this bond to pay out coupons\"\n        );\n        for (uint256 j = 0; j < coupon.holdersAtCouponDate.length; j++) {\n          if (coupon.holdersAtCouponDate[j] == holder) {\n            uint256 couponAmount = coupon.amountsAtCouponDate[j];\n            require(couponAmount > 0, \"No coupon value to redeem\");\n            coupon.redeemedCouponAmount = coupon.redeemedCouponAmount + couponAmount;\n            coupon.amountsAtCouponDate[j] = 0;\n            require(_parCurrency.transfer(holder, couponAmount), \"Transfer of the par currency to the holder failed\");\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the principal amount to the holder and burns the bond tokens\n   * @dev Note that this will fail when the contract has not enough currency balance to pay out the entire un-claimed\n   *      principal balance.\n   * @param holder The address of the account to send  the principal amount to.\n   */\n  function claimPar(address holder) public {\n    updateCoupons();\n    require(_maturityDate >= block.timestamp, \"The par value can only be claimed after the maturity date has passed\");\n    require(\n      _parCurrency.balanceOf(address(this)) >= totalSupply * (_parValue / (10**parDecimals)),\n      \"There are not enough funds in the currency assigned to this bond to pay out all par values\"\n    );\n    redeemCoupons(holder);\n    require(\n      _parCurrency.transfer(holder, (balanceOf(holder) * _parValue) / (10**parDecimals)),\n      \"Transfer of the par currency to the holder failed\"\n    );\n    require(burn(holder, balanceOf(holder)), \"Burning the bond tokens failed\");\n  }\n\n  function coupons() public view returns (Coupon[] memory) {\n    return _coupons;\n  }\n\n  function couponDates() public view returns (uint256[] memory) {\n    return _couponDates;\n  }\n\n  function mint(address to, uint256 amount) public override returns (bool success) {\n    updateCoupons();\n    return super.mint(to, amount);\n  }\n\n  function burn(address from, uint256 amount) public override returns (bool success) {\n    updateCoupons();\n    return super.burn(from, amount);\n  }\n\n  function transfer(address to, uint256 value) public virtual override returns (bool success) {\n    updateCoupons();\n    return super.transfer(to, value);\n  }\n\n  // function to calculate how much money needs to be there\n  // override transfer, mint and burn\n\n  /**\n   * @notice Returns the amount of bond holders.\n   * @dev Gets the amount of bond holders, used by the middleware to build a cache you can query.\n   *      You should not need this function in general since iteration this way clientside is very slow.\n   *\n   * @return length An uint256 representing the amount of tokenholders recorded in this contract.\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenHolders.length;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by index\n   * @dev Gets balance of an individual bond holder, used by the middleware to build a cache you can query.\n   *      You should not need this function in general since iteration this way clientside is very slow.\n   *\n   * @param index       used to access the tokenHolders array\n   * @return holder     holder's address\n   * @return balance    the holder's balance\n   */\n  function getByIndex(uint256 index) public view returns (address holder, uint256 balance) {\n    holder = tokenHolders[index];\n    balance = balances[tokenHolders[index]].balance;\n  }\n\n  /**\n   * @notice Returns the address and balance of the tokenholder by address\n   * @dev Gets balance of an individual bond holder, used by the middleware to build a cache you can query.\n   *      You should not need this function in general since iteration this way clientside is very slow.\n   *\n   * @param key         used to access the token's balances\n   * @return holder     holder's address and balance\n   * @return balance    the holder's balance\n   */\n  function getByKey(address key) public view returns (address holder, uint256 balance) {\n    holder = key;\n    balance = balances[key].balance;\n  }\n}\n"
    },
    "contracts/bonds/BondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenFactory.sol\";\nimport \"./Bond.sol\";\n\n/**\n * @title Factory contract for ERC20-based currency token\n */\ncontract BondFactory is ERC20TokenFactory {\n  constructor(address registry, address gk) ERC20TokenFactory(registry, gk) {}\n\n  /**\n   * @notice Factory method to create new ERC20-based currency token.\n   * @dev Restricted to user with the \"CREATE_TOKEN_ROLE\" permission.\n   * @param name bytes32\n   * @param decimals bytes32\n   */\n  function createToken(\n    string memory name,\n    uint256 parValue,\n    Currency parCurrency,\n    uint256 maturityPeriod,\n    uint256 couponRate,\n    uint256 couponPeriod,\n    uint8 decimals,\n    string memory ipfsFieldContainerHash\n  ) public authWithCustomReason(CREATE_TOKEN_ROLE, \"Sender needs CREATE_TOKEN_ROLE\") {\n    Bond newToken = new Bond(\n      name,\n      parValue,\n      parCurrency,\n      maturityPeriod,\n      couponRate,\n      couponPeriod,\n      decimals,\n      gateKeeper,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n    _tokenRegistry.addToken(name, address(newToken));\n    emit TokenCreated(address(newToken), name);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"MINT_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"BURN_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"UPDATE_METADATA_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"EDIT_ROLE\"), msg.sender);\n  }\n}\n"
    },
    "contracts/orders/Orders.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/FiniteStateMachine.sol\";\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/ui/UIFieldDefinitions.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * @title BillOfLading Contract\n */\ncontract Orders is FiniteStateMachine, IpfsFieldContainer, FileFieldContainer, UIFieldDefinitions {\n  bytes32 public constant CREATE_STATEMACHINE_ROLE = \"CREATE_STATEMACHINE_ROLE\";\n\n  /**\n   * SupplierContract Events\n   */\n  event OrderCreated(uint256 fsmIndex, address owner, address registry);\n  // event BillOfLadingSubmitted(address owner, address expense, uint256 amount);\n  // event BillOfLadingSubmittedWithException(address owner, address expense, uint256 amount, string comment);\n  // event BillOfLadingReviewed(address owner, address expense, uint256 amount);\n  // event BillOfLadingNeedsUpdate(address owner, address expense, uint256 amount, string comment);\n  // event BillOfLadingAccepted(address owner, address expense, uint256 amount);\n  // event BillOfLadingRejected(address owner, address expense, uint256 amount, string comment);\n  // event BillOfLadingForceApproved(address owner, address expense, uint256 amount, string comment);\n  // event AmountChanged(address sender, uint256 fromAmount, uint256 toAmount);\n  // event ProofChanged(address sender, string fromProof, string toProof);\n\n  /**\n   * @dev State Constants\n   */\n  bytes32 private constant STATE_ORDER_PLACED = \"ORDER_PLACED\";\n  bytes32 private constant STATE_ORDER_ACCEPTED = \"ORDER_ACCEPTED\";\n  bytes32 private constant STATE_ORDER_DENIED = \"ORDER_DENIED\";\n  bytes32 private constant STATE_ORDER_SHIPPED = \"ORDER_SHIPPED\";\n  bytes32 private constant STATE_SHIPMENT_RECEIVED = \"SHIPMENT_RECEIVED\";\n  bytes32 private constant STATE_SHIPMENT_ACCEPTED = \"SHIPMENT_ACCEPTED\";\n  bytes32 private constant STATE_SHIPMENT_DENIED = \"SHIPMENT_DENIED\";\n  bytes32 private constant STATE_BILL_SENT = \"BILL_SENT\";\n  bytes32 private constant STATE_BILL_RECEIVED = \"BILL_RECEIVED\";\n  bytes32 private constant STATE_BILL_ACCEPTED = \"BILL_ACCEPTED\";\n  bytes32 private constant STATE_BILL_DENIED = \"BILL_DENIED\";\n  bytes32 private constant STATE_BILLED_TO_BUSINESS_UNIT = \"BILLED_TO_BUSINESS_UNIT\";\n  bytes32 private constant STATE_PAYMENT_ISSUED = \"PAYMENT_ISSUED\";\n  bytes32 private constant STATE_PAYMENT_RECEIVED = \"STATE_PAYMENT_RECEIVED\";\n\n  /**\n   * @dev Role Constants\n   */\n  bytes32 private constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 private constant ROLE_SUPPLIER = \"ROLE_SUPPLIER\";\n  bytes32 private constant ROLE_SSC = \"ROLE_SSC\";\n  bytes32 private constant ROLE_BU = \"ROLE_BU\";\n\n  /**\n   * @dev BillOfLading states\n   */\n  bytes32[] public _allStates = [\n    STATE_ORDER_PLACED,\n    STATE_ORDER_ACCEPTED,\n    STATE_ORDER_DENIED,\n    STATE_ORDER_SHIPPED,\n    STATE_SHIPMENT_RECEIVED,\n    STATE_SHIPMENT_ACCEPTED,\n    STATE_SHIPMENT_DENIED,\n    STATE_BILL_SENT,\n    STATE_BILL_RECEIVED,\n    STATE_BILL_ACCEPTED,\n    STATE_BILL_DENIED,\n    STATE_BILLED_TO_BUSINESS_UNIT,\n    STATE_PAYMENT_ISSUED,\n    STATE_PAYMENT_RECEIVED\n  ];\n\n  /**\n   * @dev BillOfLading roles\n   */\n  bytes32[] public _allRoles = [ROLE_ADMIN, ROLE_SUPPLIER, ROLE_SSC, ROLE_BU];\n\n  /**\n   * @dev BillOfLading helper role collection\n   * specifies anyone who can edit an exponse\n   */\n  bytes32[] private _canEdit = [ROLE_ADMIN, ROLE_SSC];\n\n  /**\n   * The address of the upgradeable registry this contract belongs to.\n   * Note that both this property together with the UPGRADEABLE_REGISTRY_TARGET const define a contract\n   * that is part of an upgradeable registry and provides the link to the registry if required.\n   */\n  address public _upgradeableRegistry;\n\n  /**\n   * @dev StateMachineMeta contains meta data for every StateMachine - seeing as struct are not composable\n   * and the base StateMachine struct is defined in the FiniteStateMachine abstract there's no other\n   * way to compose structs than having two separte arrays where the indices match.\n   *\n   * @dev Mint is aware of the above and will zip these two into a single struct so statemachines\n   * from the outside will look as a composition of both StateMachine and StateMachineMeta structs.\n   */\n  StateMachineMeta[] internal _meta;\n\n  /**\n   * @dev The index is a collection of DIDs for every state machine in the registry\n   * Usually the getIndex call returns a list of contract addresses however as FSMs are\n   * uniquely identified by their DID we return those instead\n   */\n  string[] internal _index;\n\n  /**\n   * @dev Struct defining an BillOfLading\n   * @notice Gets decorated together with the StateMachine structs and forms the BillOfLading FSM\n   */\n  struct StateMachineMeta {\n    string DID;\n    address businessUnit;\n    uint256 InBoneChickenPerKg;\n    uint256 InBoneChickenTotal;\n    uint256 WokForTwoPerPackage;\n    uint256 WokForTwoTotal;\n    uint256 FreeRangeChickenPerChicken;\n    uint256 FreeRangeChickenTotal;\n    uint256 PastaSaladPerPackage;\n    uint256 PastaSaladTotal;\n    uint256 orderTotal;\n    string ipfsFieldContainerHash;\n  }\n\n  mapping(string => uint256) public prices;\n\n  constructor(address gateKeeper, address registry) Secured(gateKeeper) {\n    require(registry != address(0x0), \"registry can not be zero\");\n    _upgradeableRegistry = registry;\n\n    prices[\"InBoneChickenPerKg\"] = 199;\n    prices[\"WokForTwoPerPackage\"] = 349;\n    prices[\"FreeRangeChickenPerChicken\"] = 499;\n    prices[\"PastaSaladPerPackage\"] = 299;\n  }\n\n  //////\n  // FSM Definition Functions\n  //////\n\n  /**\n   * @notice Returns initial state\n   */\n  function initialState() public pure override returns (bytes32) {\n    return STATE_ORDER_PLACED;\n  }\n\n  /**\n   * @notice Returns all possible states\n   */\n  function allStates() public view override returns (bytes32[] memory) {\n    return _allStates;\n  }\n\n  /**\n   * @notice Returns all possible roles\n   */\n  function allRoles() public view override returns (bytes32[] memory) {\n    return _allRoles;\n  }\n\n  /**\n   * @notice Retrieve all possible next states for a certain state\n   * @param state state\n   */\n  function getNextStatesForState(bytes32 state) public pure override returns (bytes32[] memory test) {\n    bytes32[] memory states;\n\n    if (state == STATE_ORDER_PLACED) {\n      states = new bytes32[](2);\n      states[0] = STATE_ORDER_ACCEPTED;\n      states[1] = STATE_ORDER_DENIED;\n    }\n    if (state == STATE_ORDER_ACCEPTED) {\n      states = new bytes32[](1);\n      states[0] = STATE_ORDER_SHIPPED;\n    }\n    if (state == STATE_ORDER_SHIPPED) {\n      states = new bytes32[](1);\n      states[0] = STATE_SHIPMENT_RECEIVED;\n    }\n    if (state == STATE_SHIPMENT_RECEIVED) {\n      states = new bytes32[](2);\n      states[0] = STATE_SHIPMENT_ACCEPTED;\n      states[1] = STATE_SHIPMENT_DENIED;\n    }\n    if (state == STATE_SHIPMENT_ACCEPTED) {\n      states = new bytes32[](1);\n      states[0] = STATE_BILL_SENT;\n    }\n    if (state == STATE_BILL_SENT) {\n      states = new bytes32[](1);\n      states[0] = STATE_BILL_RECEIVED;\n    }\n    if (state == STATE_BILL_RECEIVED) {\n      states = new bytes32[](2);\n      states[0] = STATE_BILL_ACCEPTED;\n      states[1] = STATE_BILL_DENIED;\n    }\n    if (state == STATE_BILL_ACCEPTED) {\n      states = new bytes32[](1);\n      states[0] = STATE_BILLED_TO_BUSINESS_UNIT;\n    }\n    if (state == STATE_BILLED_TO_BUSINESS_UNIT) {\n      states = new bytes32[](1);\n      states[0] = STATE_PAYMENT_ISSUED;\n    }\n    if (state == STATE_PAYMENT_ISSUED) {\n      states = new bytes32[](1);\n      states[0] = STATE_PAYMENT_RECEIVED;\n    }\n\n    return states;\n  }\n\n  /**\n   * @notice Retrieve all roles that are allowed to move it to the given state\n   * @param state state\n   */\n  function getAllowedRolesForState(bytes32 state) public pure override returns (bytes32[] memory) {\n    bytes32[] memory roles;\n\n    if (state == STATE_ORDER_PLACED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_BU;\n    }\n    if (state == STATE_ORDER_ACCEPTED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SUPPLIER;\n    }\n    if (state == STATE_ORDER_DENIED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SUPPLIER;\n    }\n    if (state == STATE_ORDER_SHIPPED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SUPPLIER;\n    }\n    if (state == STATE_SHIPMENT_RECEIVED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_BU;\n    }\n    if (state == STATE_SHIPMENT_ACCEPTED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_BU;\n    }\n    if (state == STATE_SHIPMENT_DENIED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_BU;\n    }\n    if (state == STATE_BILL_SENT) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SUPPLIER;\n    }\n    if (state == STATE_BILL_RECEIVED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SSC;\n    }\n    if (state == STATE_BILL_ACCEPTED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SSC;\n    }\n    if (state == STATE_BILL_DENIED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SSC;\n    }\n    if (state == STATE_BILLED_TO_BUSINESS_UNIT) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SSC;\n    }\n    if (state == STATE_PAYMENT_ISSUED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SSC;\n    }\n    if (state == STATE_PAYMENT_RECEIVED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_SUPPLIER;\n    }\n\n    return roles;\n  }\n\n  /**\n   * @notice Returns method signatures for functions which are allowed to execute in the given state\n   * @param state state\n   */\n  function getAllowedFunctionsForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that act as preconditions that must be met in order to transition to the given state\n   * @param state state\n   */\n  function getPreconditionsForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that will get called after transitioning to the given state\n   * @param state state\n   */\n  function getCallbacksForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that need to be called before transitioning to the given state\n   * @param state state\n   */\n  function getPreFunctionForState(bytes32 state) public pure override returns (bytes4) {}\n\n  //////\n  // Factory Functions\n  //////\n\n  /**\n   * @notice Create a new statemachine\n   * @param ipfsFieldContainerHash IPFS hash of the metadata fields\n   */\n  function create(\n    address businessUnit,\n    uint256 InBoneChickenPerKg,\n    uint256 WokForTwoPerPackage,\n    uint256 FreeRangeChickenPerChicken,\n    uint256 PastaSaladPerPackage,\n    string memory ipfsFieldContainerHash\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    _registry.push();\n    StateMachine storage sm = _registry[_registry.length - 1];\n    sm.currentState = initialState();\n    sm.createdAt = block.timestamp;\n    sm.index = _registry.length - 1;\n\n    _meta.push();\n    StateMachineMeta storage meta = _meta[_meta.length - 1];\n    meta.businessUnit = businessUnit;\n    meta.ipfsFieldContainerHash = ipfsFieldContainerHash;\n    meta.InBoneChickenPerKg = InBoneChickenPerKg;\n    meta.InBoneChickenTotal = InBoneChickenPerKg * prices[\"InBoneChickenPerKg\"];\n    meta.WokForTwoPerPackage = WokForTwoPerPackage;\n    meta.WokForTwoTotal = WokForTwoPerPackage * prices[\"WokForTwoPerPackage\"];\n    meta.FreeRangeChickenPerChicken = FreeRangeChickenPerChicken;\n    meta.FreeRangeChickenTotal = FreeRangeChickenPerChicken * prices[\"FreeRangeChickenPerChicken\"];\n    meta.PastaSaladPerPackage = PastaSaladPerPackage;\n    meta.PastaSaladTotal = PastaSaladPerPackage * prices[\"PastaSaladPerPackage\"];\n    meta.DID = generateDID(_meta.length - 1);\n    meta.orderTotal = meta.InBoneChickenTotal + meta.WokForTwoTotal + meta.FreeRangeChickenTotal + meta.PastaSaladTotal;\n\n    _index.push();\n    _index[_index.length - 1] = meta.DID;\n\n    emit OrderCreated(sm.index, msg.sender, _upgradeableRegistry);\n  }\n\n  /**\n   * @notice Edit an existing statemachine\n   * @param fsmIndex registry index of the statemachine struct\n   * @param ipfsFieldContainerHash IPFS hash of the metadata fields\n   */\n  function edit(\n    uint256 fsmIndex,\n    address businessUnit,\n    uint256 InBoneChickenPerKg,\n    uint256 WokForTwoPerPackage,\n    uint256 FreeRangeChickenPerChicken,\n    uint256 PastaSaladPerPackage,\n    string memory ipfsFieldContainerHash\n  )\n    public\n    authManyWithCustomReason(_canEdit, \"Edit requires one of roles: ROLE_ADMIN\")\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.businessUnit = businessUnit;\n    meta.ipfsFieldContainerHash = ipfsFieldContainerHash;\n    meta.businessUnit = businessUnit;\n    meta.ipfsFieldContainerHash = ipfsFieldContainerHash;\n    meta.InBoneChickenPerKg = InBoneChickenPerKg;\n    meta.InBoneChickenTotal = InBoneChickenPerKg * prices[\"InBoneChickenPerKg\"];\n    meta.WokForTwoPerPackage = WokForTwoPerPackage;\n    meta.WokForTwoTotal = WokForTwoPerPackage * prices[\"WokForTwoPerPackage\"];\n    meta.FreeRangeChickenPerChicken = FreeRangeChickenPerChicken;\n    meta.FreeRangeChickenTotal = FreeRangeChickenPerChicken * prices[\"FreeRangeChickenPerChicken\"];\n    meta.PastaSaladPerPackage = PastaSaladPerPackage;\n    meta.PastaSaladTotal = PastaSaladPerPackage * prices[\"PastaSaladPerPackage\"];\n    meta.orderTotal = meta.InBoneChickenTotal + meta.WokForTwoTotal + meta.FreeRangeChickenTotal + meta.PastaSaladTotal;\n  }\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  //////\n  // Syncable Functions\n  //////\n\n  /**\n   * @notice Returns the structs composing a statemachine for given index\n   * @param fsmIndex state machine index\n   */\n  function getByIndex(uint256 fsmIndex) public view returns (StateMachine memory item, StateMachineMeta memory meta) {\n    item = _registry[fsmIndex];\n    meta = _meta[fsmIndex];\n  }\n\n  /**\n   * @notice Returns all state machines structs in a single fetch\n   */\n  function getContents() public view returns (StateMachine[] memory registry, StateMachineMeta[] memory meta) {\n    registry = _registry;\n    meta = _meta;\n  }\n\n  /**\n   * @notice Returns the (DID) index\n   */\n  function getIndex() public view returns (string[] memory index) {\n    return _index;\n  }\n\n  //////\n  // BillOfLading Functions\n  //////\n\n  /**\n   * @notice Returns the preconditions for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the precondition function\n   */\n  function getPreconditionFunctionsForState(bytes32 state)\n    internal\n    view\n    override\n    returns (function(uint256, bytes32, bytes32) view[] memory)\n  {}\n\n  /**\n   * @notice Returns the callbacks for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the callback function\n   */\n  function getCallbackFunctionsForState(bytes32 state)\n    internal\n    override\n    returns (function(uint256, bytes32, bytes32) internal[] memory)\n  {}\n\n  //////\n  // UI Field Definition Functions\n  //////\n\n  /**\n   * @notice Set the UI field definition hash\n   * @param uiFieldDefinitionsHash IPFS hash containing the UI field definitions JSON\n   */\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash)\n    public\n    override\n    authWithCustomReason(UPDATE_UIFIELDDEFINITIONS_ROLE, \"Sender needs UPDATE_UIFIELDDEFINITIONS_ROLE\")\n  {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  /**\n   * @notice Returns the UI field definition hash\n   */\n  function getUIFieldDefinitionsHash() public view override returns (string memory) {\n    return _uiFieldDefinitionsHash;\n  }\n\n  //////\n  // Helper Functions\n  //////\n\n  /**\n   * @notice Generate state machine DID\n   * @param fsmIndex state machine index\n   */\n  function generateDID(uint256 fsmIndex) internal view returns (string memory) {\n    return string(abi.encodePacked(\"did:order:orders:0x\", addressToString(address(this)), \":\", uintToString(fsmIndex)));\n  }\n}\n"
    },
    "contracts/plot/Plot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\n//TODO: Hoe Eigendom registreren op naam?\n\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\n\ncontract Plot is StateMachine, IpfsFieldContainer {\n  event PlotOwnerShipTransfered(address indexed from, address indexed to, address indexed plot, string caPaKey);\n  event PlotOwnershipTransferRefused(address indexed from, address indexed to, address indexed plot, string caPaKey);\n  event PlotApproved(address indexed plot, address indexed owner, string indexed caPaKey);\n  event PlotDisapproved(address indexed plot, address indexed owner, string indexed caPaKey);\n  event PlotSplitApproved(address indexed plot, address indexed owner, string indexed caPaKey);\n  event PloSplitRefused(address indexed plot, address indexed owner, string indexed caPaKey);\n\n  bytes32 public constant STATE_PLOT_SUBMITTED = \"STATE_PLOT_SUBMITTED\";\n  bytes32 public constant STATE_PLOT_APPROVED = \"STATE_PLOT_APPROVED\";\n  bytes32 public constant STATE_PLOT_NEEDS_UPDATE = \"STATE_PLOT_NEEDS_UPDATE\";\n  bytes32 public constant STATE_PLOT_DISAPPROVED = \"STATE_PLOT_DISAPPROVED\";\n  bytes32 public constant STATE_PLOT_REVIEWED = \"STATE_PLOT_REVIEWED\";\n  bytes32 public constant STATE_TRANSFER_OWNER_REQUEST = \"STATE_TRANSFER_OWNER_REQUEST\";\n  bytes32 public constant STATE_TRANSFER_OWNER_REVIEWED = \"STATE_TRANSFER_OWNER_REVIEWED\";\n  bytes32 public constant STATE_TRANSFER_OWNER_NEEDS_UPD = \"STATE_TRANSFER_OWNER_NEEDS_UPD\";\n  bytes32 public constant STATE_TRANSFER_OWNER_DISAPPROV = \"STATE_TRANSFER_OWNER_DISAPPROV\";\n  bytes32 public constant STATE_SPLIT_REQUEST = \"STATE_SPLIT_REQUEST\";\n  bytes32 public constant STATE_SPLIT_REVIEWED = \"STATE_SPLIT_REVIEWED\";\n  bytes32 public constant STATE_SPLIT_NEEDS_UPDATE = \"STATE_SPLIT_NEEDS_UPDATE\";\n  bytes32 public constant STATE_SPLIT_APPROVED = \"STATE_SPLIT_APPROVED\";\n  bytes32 public constant STATE_SPLIT_DISAPPROVED = \"STATE_SPLIT_DISAPPROVED\";\n\n  bytes32 public constant ROLE_LAND_REGISTRAR = \"ROLE_LAND_REGISTRAR\";\n  bytes32 public constant ROLE_NOTARY = \"ROLE_NOTARY\";\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_LAND_REGISTRAR, ROLE_NOTARY];\n\n  string public _uiFieldDefinitionsHash;\n  address public _owner;\n  string public _name;\n  string public _caPaKey;\n  string public _plotRejectionReason;\n  string public _ownershipRejectionReason;\n  string public _splitRejectionReason;\n\n  constructor(\n    address gateKeeper,\n    string memory name,\n    string memory caPaKey,\n    address owner,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _name = name;\n    _caPaKey = caPaKey;\n    _owner = owner;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  function edit(\n    string memory name,\n    string memory caPaKey,\n    address owner,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) public {\n    _name = name;\n    _caPaKey = caPaKey;\n    _owner = owner;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setPlotNeedsUpdateRejectionReason(string memory rejectionReason) public checkAllowedFunction {\n    setPlotRejectionReason(rejectionReason, STATE_PLOT_NEEDS_UPDATE);\n  }\n\n  function setPlotRejectedRejectionReason(string memory rejectionReason) public checkAllowedFunction {\n    setPlotRejectionReason(rejectionReason, STATE_PLOT_DISAPPROVED);\n  }\n\n  function setTransferOwnershipRejectionReason(string memory rejectionReason) public checkAllowedFunction {\n    setOwnerShipRejectionReason(rejectionReason, STATE_TRANSFER_OWNER_NEEDS_UPD);\n  }\n\n  function setSplitNeedsUpdateRejectionReason(string memory rejectionReason) public checkAllowedFunction {\n    setPlotRejectionReason(rejectionReason, STATE_SPLIT_NEEDS_UPDATE);\n  }\n\n  function setSplitRejectedRejectionReason(string memory rejectionReason) public checkAllowedFunction {\n    setPlotRejectionReason(rejectionReason, STATE_PLOT_APPROVED);\n  }\n\n  function DID() public view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:plot:\", _caPaKey));\n  }\n\n  function setupStateMachine() internal override {\n    // Create all states\n    createState(STATE_PLOT_SUBMITTED);\n    createState(STATE_PLOT_APPROVED);\n    createState(STATE_PLOT_NEEDS_UPDATE);\n    createState(STATE_PLOT_DISAPPROVED);\n    createState(STATE_PLOT_REVIEWED);\n    createState(STATE_TRANSFER_OWNER_REQUEST);\n    createState(STATE_TRANSFER_OWNER_REVIEWED);\n    createState(STATE_TRANSFER_OWNER_NEEDS_UPD);\n    createState(STATE_TRANSFER_OWNER_DISAPPROV);\n    createState(STATE_SPLIT_REQUEST);\n    createState(STATE_SPLIT_REVIEWED);\n    createState(STATE_SPLIT_NEEDS_UPDATE);\n    createState(STATE_SPLIT_APPROVED);\n    createState(STATE_SPLIT_DISAPPROVED);\n\n    // Add properties\n    // STATE_PLOT_SUBMITTED\n    addRoleForState(STATE_PLOT_SUBMITTED, ROLE_ADMIN);\n    addRoleForState(STATE_PLOT_SUBMITTED, ROLE_NOTARY);\n    addNextStateForState(STATE_PLOT_SUBMITTED, STATE_PLOT_REVIEWED);\n\n    // STATE_PLOT_APPROVED\n    addRoleForState(STATE_PLOT_APPROVED, ROLE_ADMIN);\n    addRoleForState(STATE_PLOT_APPROVED, ROLE_LAND_REGISTRAR);\n    addNextStateForState(STATE_PLOT_APPROVED, STATE_TRANSFER_OWNER_REQUEST);\n    addNextStateForState(STATE_PLOT_APPROVED, STATE_SPLIT_REQUEST);\n\n    // STATE_PLOT_NEEDS_UPDATE\n    addRoleForState(STATE_PLOT_NEEDS_UPDATE, ROLE_ADMIN);\n    addRoleForState(STATE_PLOT_NEEDS_UPDATE, ROLE_LAND_REGISTRAR);\n    addNextStateForState(STATE_PLOT_NEEDS_UPDATE, STATE_PLOT_SUBMITTED);\n    addPreConditionForState(STATE_PLOT_NEEDS_UPDATE, hasPlotRejectionReason);\n\n    // STATE_PLOT_DISAPPROVED\n    addRoleForState(STATE_PLOT_DISAPPROVED, ROLE_ADMIN);\n    addRoleForState(STATE_PLOT_DISAPPROVED, ROLE_LAND_REGISTRAR);\n    addPreConditionForState(STATE_PLOT_DISAPPROVED, hasPlotRejectionReason);\n\n    // STATE_PLOT_REVIEWED\n    addRoleForState(STATE_PLOT_REVIEWED, ROLE_ADMIN);\n    addRoleForState(STATE_PLOT_REVIEWED, ROLE_LAND_REGISTRAR);\n    addAllowedFunctionForState(STATE_PLOT_REVIEWED, this.setPlotNeedsUpdateRejectionReason.selector);\n    addAllowedFunctionForState(STATE_PLOT_REVIEWED, this.setPlotRejectedRejectionReason.selector);\n    addNextStateForState(STATE_PLOT_REVIEWED, STATE_PLOT_APPROVED);\n    addNextStateForState(STATE_PLOT_REVIEWED, STATE_PLOT_NEEDS_UPDATE);\n    addNextStateForState(STATE_PLOT_REVIEWED, STATE_PLOT_DISAPPROVED);\n\n    // STATE_TRANSFER_OWNER_REQUEST\n    addRoleForState(STATE_TRANSFER_OWNER_REQUEST, ROLE_ADMIN);\n    addRoleForState(STATE_TRANSFER_OWNER_REQUEST, ROLE_NOTARY);\n    addNextStateForState(STATE_TRANSFER_OWNER_REQUEST, STATE_TRANSFER_OWNER_REVIEWED);\n\n    // STATE_TRANSFER_OWNER_REVIEWED\n    addRoleForState(STATE_TRANSFER_OWNER_REVIEWED, ROLE_ADMIN);\n    addRoleForState(STATE_TRANSFER_OWNER_REVIEWED, ROLE_LAND_REGISTRAR);\n    addAllowedFunctionForState(STATE_TRANSFER_OWNER_REVIEWED, this.setTransferOwnershipRejectionReason.selector);\n    addNextStateForState(STATE_TRANSFER_OWNER_REVIEWED, STATE_TRANSFER_OWNER_NEEDS_UPD);\n    addNextStateForState(STATE_TRANSFER_OWNER_REVIEWED, STATE_TRANSFER_OWNER_DISAPPROV);\n\n    // STATE_TRANSFER_OWNER_NEEDS_UPD\n    addRoleForState(STATE_TRANSFER_OWNER_NEEDS_UPD, ROLE_ADMIN);\n    addRoleForState(STATE_TRANSFER_OWNER_NEEDS_UPD, ROLE_LAND_REGISTRAR);\n    addNextStateForState(STATE_TRANSFER_OWNER_NEEDS_UPD, STATE_TRANSFER_OWNER_REQUEST);\n    addNextStateForState(STATE_TRANSFER_OWNER_NEEDS_UPD, STATE_PLOT_APPROVED);\n    addPreConditionForState(STATE_TRANSFER_OWNER_NEEDS_UPD, hasOwnershipRejectionReason);\n\n    // STATE_TRANSFER_OWNER_DISAPPROV\n    addRoleForState(STATE_TRANSFER_OWNER_DISAPPROV, ROLE_ADMIN);\n    addRoleForState(STATE_TRANSFER_OWNER_DISAPPROV, ROLE_LAND_REGISTRAR);\n    addNextStateForState(STATE_TRANSFER_OWNER_DISAPPROV, STATE_PLOT_APPROVED);\n    addPreConditionForState(STATE_TRANSFER_OWNER_DISAPPROV, hasOwnershipRejectionReason);\n\n    // STATE_SPLIT_REQUEST\n    addRoleForState(STATE_SPLIT_REQUEST, ROLE_ADMIN);\n    addRoleForState(STATE_SPLIT_REQUEST, ROLE_NOTARY);\n    addNextStateForState(STATE_SPLIT_REQUEST, STATE_SPLIT_REVIEWED);\n\n    // STATE_SPLIT_REVIEWED\n    addRoleForState(STATE_SPLIT_REVIEWED, ROLE_ADMIN);\n    addRoleForState(STATE_SPLIT_REVIEWED, ROLE_LAND_REGISTRAR);\n    addAllowedFunctionForState(STATE_SPLIT_REVIEWED, this.setPlotNeedsUpdateRejectionReason.selector);\n    addAllowedFunctionForState(STATE_SPLIT_REVIEWED, this.setPlotRejectedRejectionReason.selector);\n    addNextStateForState(STATE_SPLIT_REVIEWED, STATE_SPLIT_NEEDS_UPDATE);\n    addNextStateForState(STATE_SPLIT_REVIEWED, STATE_SPLIT_APPROVED);\n    addNextStateForState(STATE_SPLIT_REVIEWED, STATE_SPLIT_DISAPPROVED);\n\n    // STATE_SPLIT_NEEDS_UPDATE\n    addRoleForState(STATE_SPLIT_NEEDS_UPDATE, ROLE_ADMIN);\n    addRoleForState(STATE_SPLIT_NEEDS_UPDATE, ROLE_LAND_REGISTRAR);\n    addPreConditionForState(STATE_SPLIT_NEEDS_UPDATE, hasSplittRejectionReason);\n    addNextStateForState(STATE_SPLIT_NEEDS_UPDATE, STATE_SPLIT_REQUEST);\n    addNextStateForState(STATE_SPLIT_NEEDS_UPDATE, STATE_PLOT_APPROVED);\n\n    // STATE_SPLIT_APPROVED\n    // Once a plot has been split it cannot be used again\n    addRoleForState(STATE_SPLIT_APPROVED, ROLE_ADMIN);\n    addRoleForState(STATE_SPLIT_APPROVED, ROLE_LAND_REGISTRAR);\n\n    // STATE_SPLIT_DISAPPROVED\n    addRoleForState(STATE_SPLIT_DISAPPROVED, ROLE_ADMIN);\n    addRoleForState(STATE_SPLIT_DISAPPROVED, ROLE_LAND_REGISTRAR);\n    addPreConditionForState(STATE_SPLIT_DISAPPROVED, hasSplittRejectionReason);\n    addNextStateForState(STATE_SPLIT_DISAPPROVED, STATE_PLOT_APPROVED);\n\n    setInitialState(STATE_PLOT_SUBMITTED);\n  }\n\n  /**\n   * Precondition functions\n   */\n  function hasPlotRejectionReason(\n    bytes32, /* fromState */\n    bytes32 /*toState*/\n  ) internal view {\n    bytes memory reasonForRejection = bytes(_plotRejectionReason);\n    require(reasonForRejection.length > 0, \"A reason for a rejection is required\");\n  }\n\n  function setPlotRejectionReason(string memory rejectionReason, bytes32 nextState) private {\n    bytes memory bytesRejectionReason = bytes(_plotRejectionReason);\n    require(bytesRejectionReason.length > 0, \"The rejection reason is required\");\n    _plotRejectionReason = rejectionReason;\n    transitionState(nextState);\n  }\n\n  function hasOwnershipRejectionReason(\n    bytes32, /* fromState */\n    bytes32 /*toState*/\n  ) internal view {\n    bytes memory reasonForRejection = bytes(_ownershipRejectionReason);\n    require(reasonForRejection.length > 0, \"A reason for a rejection is required\");\n  }\n\n  function setOwnerShipRejectionReason(string memory rejectionReason, bytes32 nextState) private {\n    bytes memory bytesRejectionReason = bytes(_ownershipRejectionReason);\n    require(bytesRejectionReason.length > 0, \"The rejection reason is required\");\n    _ownershipRejectionReason = rejectionReason;\n    transitionState(nextState);\n  }\n\n  function hasSplittRejectionReason(\n    bytes32, /* fromState */\n    bytes32 /*toState*/\n  ) internal view {\n    bytes memory reasonForRejection = bytes(_splitRejectionReason);\n    require(reasonForRejection.length > 0, \"A reason for a rejection is required\");\n  }\n\n  function setSplitRejectionReason(string memory rejectionReason, bytes32 nextState) private {\n    bytes memory bytesRejectionReason = bytes(_splitRejectionReason);\n    require(bytesRejectionReason.length > 0, \"The rejection reason is required\");\n    _splitRejectionReason = rejectionReason;\n    transitionState(nextState);\n  }\n}\n"
    },
    "contracts/plot/PlotFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./Plot.sol\";\nimport \"./PlotRegistry.sol\";\n\ncontract PlotFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, PlotRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  function create(\n    string memory name,\n    string memory caPaKey,\n    address owner,\n    string memory ipfsFieldContainerHash\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    bytes memory memProof = bytes(name);\n    require(memProof.length > 0, \"A name is required\");\n    Plot plot = new Plot(address(gateKeeper), name, caPaKey, owner, ipfsFieldContainerHash, _uiFieldDefinitionsHash);\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = plot.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(gateKeeper.getRoleRegistryAddress(roles[i]), address(plot), roles[i], address(this));\n    }\n\n    _registry.insert(address(plot));\n    emit StateMachineCreated(address(plot));\n  }\n}\n"
    },
    "contracts/plot/PlotRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\ncontract PlotRegistry is StateMachineRegistry {\n  constructor(address gatekeeper) StateMachineRegistry(address(gateKeeper)) {}\n}\n"
    },
    "contracts/knowyourcustomer/KnowYourCustomer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * KnowYourCustomer\n\n *\n * @title State machine for KnowYourCustomer\n */\ncontract KnowYourCustomer is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_CREATED = \"CREATED\";\n  bytes32 private constant STATE_IN_REVIEW = \"IN_REVIEW\";\n  bytes32 private constant STATE_INCOMPLETE = \"INCOMPLETE\";\n  bytes32 private constant STATE_EXCEPTION_GRANTED = \"EXCEPTION_GRANTED\";\n  bytes32 public constant STATE_APPROVED = \"APPROVED\";\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_REQUESTER = \"ROLE_REQUESTER\";\n  bytes32 public constant ROLE_APPROVER = \"ROLE_APPROVER\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_REQUESTER, ROLE_APPROVER];\n  bytes32[] private _canEdit = [ROLE_ADMIN, ROLE_REQUESTER];\n\n  string public _uiFieldDefinitionsHash;\n  string public _Name;\n\n  constructor(\n    address gateKeeper,\n    string memory name,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _Name = name;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  /**\n   * @notice Updates expense properties\n   * @param name It is the order Identification Number\n   * @param ipfsFieldContainerHash ipfs hash of knowyourcustomer metadata\n   */\n  function edit(string memory name, string memory ipfsFieldContainerHash) public {\n    _Name = name;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns a DID of the knowyourcustomer\n   * @dev Returns a unique DID (Decentralized Identifier) for the knowyourcustomer.\n   * @return string representing the DID of the knowyourcustomer\n   */\n  function DID() public view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:knowyourcustomer:\", _Name));\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n    createState(STATE_CREATED);\n    createState(STATE_IN_REVIEW);\n    createState(STATE_INCOMPLETE);\n    createState(STATE_EXCEPTION_GRANTED);\n    createState(STATE_APPROVED);\n\n    // add properties\n\n    addNextStateForState(STATE_CREATED, STATE_IN_REVIEW);\n    addAllowedFunctionForState(STATE_CREATED, this.edit.selector);\n\n    addNextStateForState(STATE_IN_REVIEW, STATE_INCOMPLETE);\n    addNextStateForState(STATE_IN_REVIEW, STATE_APPROVED);\n    addNextStateForState(STATE_INCOMPLETE, STATE_IN_REVIEW);\n    addNextStateForState(STATE_INCOMPLETE, STATE_EXCEPTION_GRANTED);\n\n    addNextStateForState(STATE_EXCEPTION_GRANTED, STATE_APPROVED);\n\n    addRoleForState(STATE_CREATED, ROLE_REQUESTER);\n    addRoleForState(STATE_IN_REVIEW, ROLE_REQUESTER);\n\n    addRoleForState(STATE_INCOMPLETE, ROLE_APPROVER);\n    addRoleForState(STATE_EXCEPTION_GRANTED, ROLE_APPROVER);\n    addRoleForState(STATE_APPROVED, ROLE_APPROVER);\n\n    //addRoleForState(STATE_CREATED,ROLE_ADMIN);\n    //addRoleForState(STATE_IN_REVIEW,ROLE_ADMIN);\n    //addRoleForState(STATE_INCOMPLETE,ROLE_ADMIN);\n    //addRoleForState(STATE_EXCEPTION_GRANTED,ROLE_ADMIN);\n    //addRoleForState(STATE_APPROVED,ROLE_ADMIN);\n    setInitialState(STATE_CREATED);\n  }\n}\n"
    },
    "contracts/knowyourcustomer/KnowYourCustomerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./KnowYourCustomer.sol\";\nimport \"./KnowYourCustomerRegistry.sol\";\n\n/**\n * @title Factory contract for knowyourcustomer state machines\n */\ncontract KnowYourCustomerFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, KnowYourCustomerRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new knowyourcustomer\n   * @dev Factory method to create a new knowyourcustomer. Emits StateMachineCreated event.\n   * @param name Customer Name\n\n   * @param ipfsFieldContainerHash ipfs hash of knowyourcustomer metadata\n   */\n  function create(string memory name, string memory ipfsFieldContainerHash)\n    public\n    authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\")\n  {\n    bytes memory memProof = bytes(name);\n    require(memProof.length > 0, \"A Name is required\");\n\n    KnowYourCustomer knowyourcustomer = new KnowYourCustomer(\n      address(gateKeeper),\n      name,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = knowyourcustomer.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(knowyourcustomer),\n        roles[i],\n        address(this)\n      );\n    }\n\n    _registry.insert(address(knowyourcustomer));\n    emit StateMachineCreated(address(knowyourcustomer));\n  }\n}\n"
    },
    "contracts/knowyourcustomer/KnowYourCustomerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for supplychainfinance state machines\n */\ncontract KnowYourCustomerRegistry is StateMachineRegistry {\n  constructor(address gatekeeper) StateMachineRegistry(address(gateKeeper)) {}\n}\n"
    },
    "contracts/knowyourbusiness/KnowYourBusiness.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * KnowYourBusiness\n\n *\n * @title State machine for KnowYourBusiness\n */\ncontract KnowYourBusiness is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_KYB_REQUESTED = \"SUBMITTED\";\n  bytes32 public constant STATE_KYB_APPROVED = \"APPROVED\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_REQUESTER = \"ROLE_REQUESTER\";\n  bytes32 public constant ROLE_APPROVER = \"ROLE_APPROVER\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_REQUESTER, ROLE_APPROVER];\n\n  string public _uiFieldDefinitionsHash;\n  string public _Name;\n\n  constructor(\n    address gateKeeper,\n    string memory Name,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _Name = Name;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  /**\n   * @notice Updates expense properties\n   * @param Name It is the order Identification Number\n   * @param ipfsFieldContainerHash ipfs hash of supplychainfinance metadata\n   */\n  function edit(string memory Name, string memory ipfsFieldContainerHash) public {\n    _Name = Name;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns a DID of the supplychainfinance\n   * @dev Returns a unique DID (Decentralized Identifier) for the supplychainfinance.\n   * @return string representing the DID of the supplychainfinance\n   */\n  function DID() public view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:supplychainfinance:\", _Name));\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n\n    createState(STATE_KYB_REQUESTED);\n    createState(STATE_KYB_APPROVED);\n\n    // add properties\n\n    addNextStateForState(STATE_KYB_REQUESTED, STATE_KYB_APPROVED);\n    addRoleForState(STATE_KYB_REQUESTED, ROLE_REQUESTER);\n    addRoleForState(STATE_KYB_APPROVED, ROLE_APPROVER);\n    addRoleForState(STATE_KYB_REQUESTED, ROLE_ADMIN);\n    addRoleForState(STATE_KYB_APPROVED, ROLE_ADMIN);\n\n    setInitialState(STATE_KYB_REQUESTED);\n  }\n}\n"
    },
    "contracts/knowyourbusiness/KnowYourBusinessFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./KnowYourBusiness.sol\";\nimport \"./KnowYourBusinessRegistry.sol\";\n\n/**\n * @title Factory contract for knowyourbusiness state machines\n */\ncontract KnowYourBusinessFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, KnowYourBusinessRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new knowyourbusiness\n   * @dev Factory method to create a new knowyourbusiness. Emits StateMachineCreated event.\n   * @param Name Business Name\n\n   * @param ipfsFieldContainerHash ipfs hash of knowyourbusiness metadata\n   */\n  function create(string memory Name, string memory ipfsFieldContainerHash)\n    public\n    authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\")\n  {\n    bytes memory memProof = bytes(Name);\n    require(memProof.length > 0, \"A Name is required\");\n\n    KnowYourBusiness knowyourbusiness = new KnowYourBusiness(\n      address(gateKeeper),\n      Name,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = knowyourbusiness.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(knowyourbusiness),\n        roles[i],\n        address(this)\n      );\n    }\n\n    _registry.insert(address(knowyourbusiness));\n    emit StateMachineCreated(address(knowyourbusiness));\n  }\n}\n"
    },
    "contracts/knowyourbusiness/KnowYourBusinessRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for supplychainfinance state machines\n */\ncontract KnowYourBusinessRegistry is StateMachineRegistry {\n  constructor(address gatekeeper) StateMachineRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/genericstatemachine/Generic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * Generic\n *\n * A generic package exists of\n *  - a description of the generic state machine\n *\n * @title Generic State machine implementation\n */\ncontract Generic is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_ONE = \"CHANGE_HERE_STATE_ONE\";\n  bytes32 public constant STATE_TWO = \"CHANGE_HERE_STATE_TWO\";\n  bytes32 public constant STATE_THREE = \"CHANGE_HERE_STATE_THREE\";\n  bytes32 public constant STATE_FOUR = \"CHANGE_HERE_STATE_FOUR\";\n  bytes32 public constant STATE_FIVE = \"CHANGE_HERE_STATE_FIVE\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_ONE = \"CHANGE_HERE_ROLE_ONE\";\n  bytes32 public constant ROLE_TWO = \"CHANGE_HERE_ROLE_TWO\";\n  bytes32 public constant ROLE_THREE = \"CHANGE_HERE_ROLE_THREE\";\n  bytes32 public constant ROLE_FOUR = \"CHANGE_HERE_ROLE_FOUR\";\n\n  bytes32[] public _roles = [ROLE_ADMIN];\n\n  string public _uiFieldDefinitionsHash;\n  string private _param1;\n  address _param2;\n  uint256 private _param3;\n\n  constructor(\n    address gateKeeper,\n    string memory param1,\n    address param2,\n    uint256 param3,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _param1 = param1;\n    _param2 = param2;\n    _param3 = param3;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  /**\n   * @notice Updates state machine properties\n   * @param param1 the first parameter of the state machine\n   * @param param2 the second parameter of the state machine\n   * @param param3 the third parameter of the state machine\n   * @param ipfsFieldContainerHash ipfs hash of vehicle metadata\n   */\n  function edit(\n    string memory param1,\n    address param2,\n    uint256 param3,\n    string memory ipfsFieldContainerHash\n  ) public {\n    _param1 = param1;\n    _param2 = param2;\n    _param3 = param3;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n    createState(STATE_ONE);\n    createState(STATE_TWO);\n    createState(STATE_THREE);\n    createState(STATE_FOUR);\n    createState(STATE_FIVE);\n\n    // add properties\n    // STATE_ONE\n    addNextStateForState(STATE_ONE, STATE_TWO);\n    addRoleForState(STATE_ONE, ROLE_ADMIN);\n\n    // STATE_TWO\n    addNextStateForState(STATE_TWO, STATE_THREE);\n    addRoleForState(STATE_TWO, ROLE_ADMIN);\n    addRoleForState(STATE_TWO, ROLE_ONE);\n\n    // STATE_THREE\n    addNextStateForState(STATE_THREE, STATE_FOUR);\n    addRoleForState(STATE_THREE, ROLE_ADMIN);\n    addRoleForState(STATE_THREE, ROLE_TWO);\n\n    // STATE_FOUR\n    addNextStateForState(STATE_FOUR, STATE_FIVE);\n    addRoleForState(STATE_FOUR, ROLE_ADMIN);\n    addRoleForState(STATE_FOUR, ROLE_THREE);\n\n    // STATE_FIVE\n    addRoleForState(STATE_FIVE, ROLE_FOUR);\n\n    setInitialState(STATE_ONE);\n  }\n}\n"
    },
    "contracts/genericstatemachine/GenericFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./Generic.sol\";\nimport \"./GenericRegistry.sol\";\n\n/**\n * @title Factory contract for generic state machines\n */\ncontract GenericFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, GenericRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new generic instance\n   * @dev Factory method to create a new state machine. Emits StateMachineCreated event.\n   * @param param1 the first parameter of the state machine\n   * @param param2 the second parameter of the state machine\n   * @param param3 the third parameter of the state machine\n   * @param ipfsFieldContainerHash ipfs hash of vehicle metadata\n   */\n  function create(\n    string memory param1,\n    address param2,\n    uint256 param3,\n    string memory ipfsFieldContainerHash\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    bytes memory memProof = bytes(param1);\n    require(memProof.length > 0, \"A param1 is required\");\n\n    Generic generic = new Generic(\n      address(gateKeeper),\n      param1,\n      param2,\n      param3,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = generic.getRoles();\n    for (uint256 i = 0; i < 1; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(generic),\n        roles[i],\n        address(this)\n      );\n    }\n    _registry.insert(address(generic));\n    emit StateMachineCreated(address(generic));\n  }\n}\n"
    },
    "contracts/genericstatemachine/GenericRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for vehicle state machines\n */\ncontract GenericRegistry is StateMachineRegistry {\n  constructor(address gatekeeper) StateMachineRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/drugpackage/DrugPackage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * DrugPackage\n *\n * A drug package exists of\n *  - a description of the drug in the package where a DrugPackage is defined as a chemical or biologic\n *    substance, used as a medical therapy, that has a physiological effect on an organism and the\n *    schema for it as defined by https://schema.org/DrugPackage\n *  - a serialized National Drug Code (sNDC) of the individual package containing the labeler code,\n *    product code, package code and a unique serial number for this packet. The definition of this\n *    sNDC by the FDA is as follows: https://www.fda.gov/regulatory-information/search-fda-guidance-documents/standards-securing-drug-supply-chain-standardized-numerical-identification-prescription-drug\n *    A slight variation is applied here where the sNDC is modified to comply with the Decentralized ID\n *    standard defined here: https://w3c-ccg.github.io/did-spec/\n *\n * @title State machine to track a drug package\n */\ncontract DrugPackage is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_PACKAGED_LABELED = \"STATE_PACKAGED_LABELED\";\n  bytes32 public constant STATE_IN_TRANSIT_M2R = \"STATE_IN_TRANSIT_M2R\";\n  bytes32 public constant STATE_AT_RESELLER = \"STATE_AT_RESELLER\";\n  bytes32 public constant STATE_IN_TRANSIT_R2P = \"STATE_IN_TRANSIT_R2P\";\n  bytes32 public constant STATE_IN_TRANSIT_R2R = \"STATE_IN_TRANSIT_R2R\";\n  bytes32 public constant STATE_AT_PHARMACY = \"STATE_AT_PHARMACY\";\n  bytes32 public constant STATE_FULLFILLED_TO_PATIENT = \"STATE_FULLFILLED_TO_PATIENT\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_MANUFACTURER = \"ROLE_MANUFACTURER\";\n  bytes32 public constant ROLE_RESELLER = \"ROLE_RESELLER\";\n  bytes32 public constant ROLE_PHARMACY = \"ROLE_PHARMACY\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_MANUFACTURER, ROLE_RESELLER, ROLE_PHARMACY];\n\n  string public _uiFieldDefinitionsHash;\n  string public _labellerCode;\n  string public _productCode;\n  string public _packageCode;\n\n  constructor(\n    address gateKeeper,\n    string memory labellerCode,\n    string memory productCode,\n    string memory packageCode,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _labellerCode = labellerCode;\n    _productCode = productCode;\n    _packageCode = packageCode;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  /**\n   * @notice Updates drug package properties\n   * @param labellerCode new labeller code\n   * @param productCode new product code\n   * @param packageCode new package code\n   * @param ipfsFieldContainerHash new hash for the drug package metadata\n   */\n  function edit(\n    string memory labellerCode,\n    string memory productCode,\n    string memory packageCode,\n    string memory ipfsFieldContainerHash\n  ) public {\n    _labellerCode = labellerCode;\n    _productCode = productCode;\n    _packageCode = packageCode;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns a DID of the expense.\n   * @dev Returns a unique DID (Decentralized Identifier) for the expense.\n   * @return string representing the DID of the expense\n   */\n  function DID() public view returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\n          \"did:demo:pharmapack:\",\n          _labellerCode,\n          _productCode,\n          _packageCode,\n          addressToString(address(this))\n        )\n      );\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n    createState(STATE_PACKAGED_LABELED);\n    createState(STATE_IN_TRANSIT_M2R);\n    createState(STATE_AT_RESELLER);\n    createState(STATE_IN_TRANSIT_R2R);\n    createState(STATE_IN_TRANSIT_R2P);\n    createState(STATE_AT_PHARMACY);\n    createState(STATE_FULLFILLED_TO_PATIENT);\n\n    // add properties\n    // STATE_PACKAGED_LABELED\n    addNextStateForState(STATE_PACKAGED_LABELED, STATE_IN_TRANSIT_M2R);\n\n    // STATE_IN_TRANSIT_M2R\n    addRoleForState(STATE_IN_TRANSIT_M2R, ROLE_ADMIN);\n    addRoleForState(STATE_IN_TRANSIT_M2R, ROLE_MANUFACTURER);\n    addNextStateForState(STATE_IN_TRANSIT_M2R, STATE_AT_RESELLER);\n\n    // STATE_AT_RESELLER\n    addRoleForState(STATE_AT_RESELLER, ROLE_ADMIN);\n    addRoleForState(STATE_AT_RESELLER, ROLE_RESELLER);\n    addNextStateForState(STATE_AT_RESELLER, STATE_IN_TRANSIT_R2R);\n    addNextStateForState(STATE_AT_RESELLER, STATE_IN_TRANSIT_R2P);\n\n    // STATE_IN_TRANSIT_R2R\n    addRoleForState(STATE_IN_TRANSIT_R2R, ROLE_ADMIN);\n    addRoleForState(STATE_IN_TRANSIT_R2R, ROLE_RESELLER);\n    addNextStateForState(STATE_IN_TRANSIT_R2R, STATE_AT_RESELLER);\n\n    // STATE_IN_TRANSIT_R2R\n    addRoleForState(STATE_IN_TRANSIT_R2P, ROLE_ADMIN);\n    addRoleForState(STATE_IN_TRANSIT_R2P, ROLE_RESELLER);\n    addNextStateForState(STATE_IN_TRANSIT_R2P, STATE_AT_PHARMACY);\n\n    // STATE_IN_TRANSIT_R2R\n    addRoleForState(STATE_AT_PHARMACY, ROLE_ADMIN);\n    addRoleForState(STATE_AT_PHARMACY, ROLE_PHARMACY);\n    addNextStateForState(STATE_AT_PHARMACY, STATE_FULLFILLED_TO_PATIENT);\n\n    addRoleForState(STATE_FULLFILLED_TO_PATIENT, ROLE_ADMIN);\n    addRoleForState(STATE_FULLFILLED_TO_PATIENT, ROLE_PHARMACY);\n\n    setInitialState(STATE_PACKAGED_LABELED);\n  }\n}\n"
    },
    "contracts/drugpackage/DrugPackageFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./DrugPackage.sol\";\nimport \"./DrugPackageRegistry.sol\";\n\n/**\n * @title Factory contract for drug package state machines\n */\ncontract DrugPackageFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, DrugPackageRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new drug package\n   * @dev Factory method to create a new drug package. Emits StateMachineCreated event.\n   * @param labellerCode identifying the package labeller\n   * @param productCode identifying the product inside the package\n   * @param packageCode identifying the package itself\n   * @param ipfsFieldContainerHash ipfs hash of drug package metadata\n   */\n  function create(\n    string memory labellerCode,\n    string memory productCode,\n    string memory packageCode,\n    string memory ipfsFieldContainerHash\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    bytes memory memProof = bytes(labellerCode);\n    require(memProof.length > 0, \"A labellerCode is required\");\n    memProof = bytes(productCode);\n    require(memProof.length > 0, \"A productCode is required\");\n    memProof = bytes(packageCode);\n    require(memProof.length > 0, \"A packageCode is required\");\n\n    DrugPackage drugPackage = new DrugPackage(\n      address(gateKeeper),\n      labellerCode,\n      productCode,\n      packageCode,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = drugPackage.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(drugPackage),\n        roles[i],\n        address(this)\n      );\n    }\n\n    _registry.insert(address(drugPackage));\n    emit StateMachineCreated(address(drugPackage));\n  }\n}\n"
    },
    "contracts/drugpackage/DrugPackageRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for drug package state machines\n */\ncontract DrugPackageRegistry is StateMachineRegistry {\n  constructor(address gatekeeper) StateMachineRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/bankguarantee/BankGuarantee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/provenance/statemachine/StateMachine.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * BankGuarantee\n\n *\n * @title State machine for BankGuarantee\n */\ncontract BankGuarantee is Converter, StateMachine, IpfsFieldContainer, FileFieldContainer {\n  bytes32 public constant STATE_INITIATED = \"INITIATED\";\n  bytes32 public constant STATE_IN_REVIEW = \"IN-REVIEW\";\n  bytes32 public constant STATE_INCOMPLETE = \"INCOMPLETE\";\n  bytes32 public constant STATE_APPROVED = \"e-STAMP\";\n  bytes32 public constant STATE_ISSUED = \"ISSUED\";\n  bytes32 public constant STATE_ACCEPTED = \"ACCEPTED\";\n  bytes32 public constant STATE_INVOKED = \"INVOKED\";\n  bytes32 public constant STATE_AMENDMENT = \"AMENDMENT\";\n  bytes32 public constant STATE_REJECTED_BANK = \"REJECTED-BANK\";\n  bytes32 public constant STATE_REJECTED_BENEFICIARY = \"REJECTED-BENEFICIARY\";\n  bytes32 public constant STATE_FINISHED = \"FINISHED\";\n\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 public constant ROLE_BANK = \"ROLE_BANK\";\n  bytes32 public constant ROLE_BENEFICIARY = \"ROLE_BENEFICIARY\";\n  bytes32 public constant ROLE_APPLICANT = \"ROLE_APPLICANT\";\n\n  bytes32[] public _roles = [ROLE_ADMIN, ROLE_BANK, ROLE_BENEFICIARY, ROLE_APPLICANT];\n  bytes32[] private _canEdit = [ROLE_ADMIN, ROLE_BANK, ROLE_APPLICANT];\n\n  string public _uiFieldDefinitionsHash;\n  string public _Name;\n\n  constructor(\n    address gateKeeper,\n    string memory Name,\n    string memory ipfsFieldContainerHash,\n    string memory uiFieldDefinitionsHash\n  ) Secured(gateKeeper) {\n    _Name = Name;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n    setupStateMachine();\n  }\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  /**\n   * @notice Updates expense properties\n   * @param Name It is the order Identification Number\n   * @param ipfsFieldContainerHash ipfs hash of bankgurantee metadata\n   */\n  function edit(string memory Name, string memory ipfsFieldContainerHash) public {\n    _Name = Name;\n    _ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  /**\n   * @notice Returns a DID of the bankgurantee\n   * @dev Returns a unique DID (Decentralized Identifier) for the bankgurantee.\n   * @return string representing the DID of the bankgurantee\n   */\n  function DID() public view returns (string memory) {\n    return string(abi.encodePacked(\"did:demo:bankgurantee:\", _Name));\n  }\n\n  /**\n   * @notice Returns all the roles for this contract\n   * @return bytes32[] array of raw bytes representing the roles\n   */\n  function getRoles() public view returns (bytes32[] memory) {\n    return _roles;\n  }\n\n  function setupStateMachine() internal override {\n    //create all states\n    createState(STATE_INITIATED);\n    createState(STATE_IN_REVIEW);\n    createState(STATE_INCOMPLETE);\n    createState(STATE_APPROVED);\n    createState(STATE_ISSUED);\n    createState(STATE_ACCEPTED);\n    createState(STATE_INVOKED);\n    createState(STATE_AMENDMENT);\n    createState(STATE_REJECTED_BANK);\n    createState(STATE_REJECTED_BENEFICIARY);\n    createState(STATE_FINISHED);\n\n    setInitialState(STATE_INITIATED);\n\n    addRoleForState(STATE_INITIATED, ROLE_BANK);\n    addRoleForState(STATE_INITIATED, ROLE_APPLICANT);\n\n    addRoleForState(STATE_IN_REVIEW, ROLE_APPLICANT);\n\n    addAllowedFunctionForState(STATE_INITIATED, this.edit.selector);\n    addAllowedFunctionForState(STATE_APPROVED, this.edit.selector);\n\n    addRoleForState(STATE_ISSUED, ROLE_BANK);\n    addRoleForState(STATE_INCOMPLETE, ROLE_BANK);\n    addRoleForState(STATE_APPROVED, ROLE_BANK);\n    addRoleForState(STATE_REJECTED_BANK, ROLE_BANK);\n    addRoleForState(STATE_FINISHED, ROLE_BANK);\n\n    addRoleForState(STATE_REJECTED_BENEFICIARY, ROLE_BENEFICIARY);\n    addRoleForState(STATE_ACCEPTED, ROLE_BENEFICIARY);\n    addRoleForState(STATE_INVOKED, ROLE_BENEFICIARY);\n    addRoleForState(STATE_AMENDMENT, ROLE_BENEFICIARY);\n\n    //addRoleForState(STATE_INITIATED,ROLE_ADMIN);\n    //addRoleForState(STATE_READY,ROLE_ADMIN);\n    //addRoleForState(STATE_IN_REVIEW,ROLE_ADMIN);\n    //addRoleForState(STATE_INCOMPLETE,ROLE_ADMIN);\n    //addRoleForState(STATE_APPROVED,ROLE_ADMIN);\n    //addRoleForState(STATE_ISSUED,ROLE_ADMIN);\n    //addRoleForState(STATE_ACCEPTED,ROLE_ADMIN);\n    //addRoleForState(STATE_INVOKED,ROLE_ADMIN);\n    //addRoleForState(STATE_AMENDMENT,ROLE_ADMIN);\n    //addRoleForState(STATE_REJECTED_BANK,ROLE_ADMIN);\n    //addRoleForState(STATE_FINISHED,ROLE_ADMIN);\n\n    // add properties\n\n    addNextStateForState(STATE_INITIATED, STATE_IN_REVIEW);\n\n    addNextStateForState(STATE_IN_REVIEW, STATE_INCOMPLETE);\n    addNextStateForState(STATE_IN_REVIEW, STATE_APPROVED);\n    addNextStateForState(STATE_IN_REVIEW, STATE_REJECTED_BANK);\n\n    addNextStateForState(STATE_INCOMPLETE, STATE_IN_REVIEW);\n    addNextStateForState(STATE_APPROVED, STATE_ISSUED);\n    addNextStateForState(STATE_REJECTED_BANK, STATE_FINISHED);\n\n    addNextStateForState(STATE_ISSUED, STATE_REJECTED_BENEFICIARY);\n    addNextStateForState(STATE_ISSUED, STATE_ACCEPTED);\n\n    addNextStateForState(STATE_ACCEPTED, STATE_INVOKED);\n    addNextStateForState(STATE_ACCEPTED, STATE_AMENDMENT);\n\n    addNextStateForState(STATE_AMENDMENT, STATE_ISSUED);\n    addNextStateForState(STATE_AMENDMENT, STATE_REJECTED_BANK);\n\n    addNextStateForState(STATE_INVOKED, STATE_FINISHED);\n\n    addNextStateForState(STATE_REJECTED_BENEFICIARY, STATE_FINISHED);\n  }\n}\n"
    },
    "contracts/bankguarantee/BankGuaranteeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineFactory.sol\";\nimport \"./BankGuarantee.sol\";\nimport \"./BankGuaranteeRegistry.sol\";\n\n/**\n * @title Factory contract for bankguarantee state machines\n */\ncontract BankGuaranteeFactory is StateMachineFactory {\n  constructor(GateKeeper gateKeeper, BankGuaranteeRegistry registry) StateMachineFactory(gateKeeper, registry) {}\n\n  /**\n   * @notice Create new bankguarantee\n   * @dev Factory method to create a new bankguarantee. Emits StateMachineCreated event.\n   * @param Name Customer Name\n\n   * @param ipfsFieldContainerHash ipfs hash of bankguarantee metadata\n   */\n  function create(string memory Name, string memory ipfsFieldContainerHash)\n    public\n    authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\")\n  {\n    bytes memory memProof = bytes(Name);\n    require(memProof.length > 0, \"A Name is required\");\n\n    BankGuarantee bankguarantee = new BankGuarantee(\n      address(gateKeeper),\n      Name,\n      ipfsFieldContainerHash,\n      _uiFieldDefinitionsHash\n    );\n\n    // Give every role registry a single permission on the newly created expense.\n    bytes32[] memory roles = bankguarantee.getRoles();\n    for (uint256 i = 0; i < roles.length; i++) {\n      gateKeeper.createPermission(\n        gateKeeper.getRoleRegistryAddress(roles[i]),\n        address(bankguarantee),\n        roles[i],\n        address(this)\n      );\n    }\n\n    _registry.insert(address(bankguarantee));\n    emit StateMachineCreated(address(bankguarantee));\n  }\n}\n"
    },
    "contracts/bankguarantee/BankGuaranteeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/StateMachineRegistry.sol\";\n\n/**\n * @title Registry contract for supplychainfinance state machines\n */\ncontract BankGuaranteeRegistry is StateMachineRegistry {\n  constructor(address gatekeeper) StateMachineRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/_library/_test/provenance/statemachine/StateMachineImplHappy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../../../provenance/statemachine/StateMachine.sol\";\n\ncontract StateMachineImplHappy is StateMachine {\n  bytes32 public constant STATE_CREATED = \"CREATED\";\n  bytes32 public constant STATE_TEMPORARY = \"TEMPORARY\";\n  bytes32 public constant STATE_MODIFIED = \"MODIFIED\";\n  bytes32 public constant STATE_ACCEPTED = \"ACCEPTED\";\n  bytes32 public constant STATE_REJECTED = \"REJECTED\";\n  bytes32 public constant STATE_ENDED = \"ENDED\";\n\n  bytes32 public constant ROLE_EDITOR = \"EDITOR\";\n  bytes32 public constant ROLE_COUNTERPARTY = \"COUNTERPARTY\";\n\n  bool public modified = false;\n  bool public modificationTransitionHandled = false;\n\n  address party1;\n  address party2;\n  mapping(address => bool) signatures;\n\n  constructor(\n    address gateKeeper,\n    address partyOne,\n    address partyTwo\n  ) Secured(gateKeeper) {\n    party1 = partyOne;\n    party2 = partyTwo;\n    setupStateMachine();\n  }\n\n  function modify() public checkAllowedFunction {\n    modified = true;\n  }\n\n  function sign() public {\n    signatures[msg.sender] = true;\n  }\n\n  function setupStateMachine() internal override {\n    createState(STATE_CREATED);\n    createState(STATE_MODIFIED);\n    createState(STATE_ACCEPTED);\n    createState(STATE_REJECTED);\n    createState(STATE_TEMPORARY);\n    createState(STATE_ENDED);\n\n    // STATE_ENDED\n    addRoleForState(STATE_ENDED, ROLE_EDITOR);\n\n    // STATE_REJECTED\n    addRoleForState(STATE_REJECTED, ROLE_COUNTERPARTY);\n\n    // STATE_ACCEPTED\n    addRoleForState(STATE_ACCEPTED, ROLE_COUNTERPARTY);\n    addPreConditionForState(STATE_ACCEPTED, acceptPreCondition);\n    addNextStateForState(STATE_ACCEPTED, STATE_ENDED);\n    addNextStateForState(STATE_ACCEPTED, STATE_TEMPORARY);\n\n    // STATE_MODIFIED\n    addRoleForState(STATE_MODIFIED, ROLE_EDITOR);\n    addAllowedFunctionForState(STATE_MODIFIED, this.modify.selector);\n    addNextStateForState(STATE_MODIFIED, STATE_MODIFIED);\n    addCallbackForState(STATE_MODIFIED, handleModificationTransition);\n    addNextStateForState(STATE_MODIFIED, STATE_ACCEPTED);\n    addNextStateForState(STATE_MODIFIED, STATE_REJECTED);\n\n    // Adjust STATE_REJECTED\n    addNextStateForState(STATE_REJECTED, STATE_MODIFIED);\n\n    // STATE_CREATED\n    addRoleForState(STATE_CREATED, ROLE_EDITOR);\n    addAllowedFunctionForState(STATE_CREATED, this.modify.selector);\n    addNextStateForState(STATE_CREATED, STATE_MODIFIED);\n    addNextStateForState(STATE_CREATED, STATE_ACCEPTED);\n    addNextStateForState(STATE_CREATED, STATE_REJECTED);\n    addNextStateForState(STATE_TEMPORARY, STATE_ENDED);\n    addCallbackForState(STATE_TEMPORARY, testInternalTransition);\n\n    setInitialState(STATE_CREATED);\n  }\n\n  function handleModificationTransition(\n    bytes32, /*fromState*/\n    bytes32 /*toState*/\n  ) internal {\n    modificationTransitionHandled = true;\n  }\n\n  function acceptPreCondition(\n    bytes32, /*fromState*/\n    bytes32 /*toState*/\n  ) internal view {\n    require(signatures[party1], \"Party 1 did not sign yet\");\n    require(signatures[party2], \"Party 2 did not sign yet\");\n  }\n\n  function testInternalTransition(\n    bytes32, /*fromState*/\n    bytes32 /*toState*/\n  ) internal {\n    transitionState(STATE_ENDED);\n  }\n}\n"
    },
    "contracts/omnibustoken/OmnibusToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\n\ncontract OmnibusToken is Secured, IpfsFieldContainer {\n  struct TokenAccount {\n    uint256 balance;\n    uint256 firstTransaction;\n  }\n\n  bytes32 internal constant MINT_ROLE = \"MINT_ROLE\";\n  bytes32 internal constant BURN_ROLE = \"BURN_ROLE\";\n\n  mapping(string => TokenAccount) public balances;\n  string[] public tokenHolders;\n  string internal _name;\n  string internal _symbol;\n  uint8 internal _decimals;\n  uint256 internal _tSupply;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint8 decimals,\n    address gateKeeper\n  ) Secured(gateKeeper) {\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n  }\n\n  struct TransactionDetail {\n    string recipient;\n    string sender;\n    bytes32 transactionType;\n    uint256 amount;\n    uint256 price;\n    string comment;\n  }\n\n  TransactionDetail[] public transactionHistory;\n  uint256 internal totalFunds;\n\n  function recordTransaction(\n    string memory recipient,\n    string memory sender,\n    uint256 amount,\n    uint256 price,\n    bytes32 transactionType,\n    string memory comment\n  ) internal {\n    transactionHistory.push();\n    uint256 index = transactionHistory.length;\n    TransactionDetail storage t = transactionHistory[index - 1];\n    t.recipient = recipient;\n    t.sender = sender;\n    t.transactionType = transactionType;\n    t.amount = amount;\n    t.price = price;\n    t.comment = comment;\n\n    totalFunds + price;\n  }\n\n  event Transfer(string sender, string recipient, uint256 amount);\n  event Burn(string indexed account, uint256 amount);\n  event Mint(string indexed account, uint256 amount);\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name or an ISIN.\n   */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * balanceOf and transfer.\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() public view returns (uint256) {\n    return _tSupply;\n  }\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(string memory account) public view returns (uint256) {\n    return balances[account].balance;\n  }\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be empty.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function transfer(\n    string memory sender,\n    string memory recipient,\n    uint256 amount,\n    uint256 price\n  ) public virtual returns (bool success) {\n    require(bytes(sender).length > 0, \"OmnibusToken: transfer from an empty account\");\n    require(bytes(recipient).length > 0, \"OmnibusToken: transfer to  an empty account\");\n    if (balances[sender].firstTransaction == 0) {\n      balances[sender].firstTransaction = block.timestamp;\n      tokenHolders.push(sender);\n    }\n    if (balances[recipient].firstTransaction == 0) {\n      balances[recipient].firstTransaction = block.timestamp;\n      tokenHolders.push(recipient);\n    }\n    TokenAccount storage senderBalance = balances[sender];\n    TokenAccount storage recipientBalance = balances[recipient];\n    senderBalance.balance = senderBalance.balance - amount;\n    recipientBalance.balance = recipientBalance.balance + amount;\n    recordTransaction(recipient, sender, amount, price, bytes32(\"TRANSFER\"), \"\");\n    success = true;\n\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` te total supply.\n   *\n   * Emits a {Mint} event\n   *\n   * Requirements\n   *\n   * - minted tokens must not cause the total supply to go over the cap.\n   */\n  function mint(\n    string memory account,\n    uint256 amount,\n    uint256 price\n  ) public virtual authWithCustomReason(MINT_ROLE, \"Caller needs MINT_ROLE\") returns (bool success) {\n    require(bytes(account).length > 0, \"OmnibusToken: mint to an empty account\");\n    if (balances[account].firstTransaction == 0) {\n      balances[account].firstTransaction = block.timestamp;\n      tokenHolders.push(account);\n    }\n    _tSupply = _tSupply + amount;\n    TokenAccount storage accountBalance = balances[account];\n    accountBalance.balance = accountBalance.balance + amount;\n    recordTransaction(account, \"WEALTH MANAGEMENT\", amount, price, bytes32(\"MINT\"), \"\");\n    success = true;\n    emit Mint(account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Burn} event.\n   *\n   * Requirements\n   *\n   * - `account` cannot be empty.\n   * - `account` must have at least `amount` tokens.\n   */\n  function burn(\n    string memory account,\n    uint256 amount,\n    uint256 price\n  ) public virtual authWithCustomReason(BURN_ROLE, \"Caller needs BURN_ROLE\") returns (bool success) {\n    require(bytes(account).length > 0, \"OmnibusToken: burn from an empty account\");\n    TokenAccount storage accountBalance = balances[account];\n    accountBalance.balance = accountBalance.balance - amount;\n    _tSupply = _tSupply - amount;\n    recordTransaction(account, \"WEALTH MANAGEMENT\", amount, price, bytes32(\"BURN\"), \"\");\n    success = true;\n    emit Burn(account, amount);\n  }\n}\n"
    },
    "contracts/identity/Identity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/digitaltwin/DigitalTwin.sol\";\nimport \"../_library/authentication/Secured.sol\";\n\ncontract Identity is DigitalTwin, Secured {\n  bytes32 public constant MANAGE_DIGITALTWIN_ROLE = \"MANAGE_DIGITALTWIN_ROLE\";\n  bytes32 public constant UPDATE_UIFIELDDEFINITIONS_ROLE = \"UPDATE_UIFIELDDEFINITIONS_ROLE\";\n\n  constructor(address gatekeeper) Secured(gatekeeper) {}\n\n  function create(\n    bytes32 idNumber,\n    bytes32 kind,\n    string memory ipfsHash\n  ) public authWithCustomReason(MANAGE_DIGITALTWIN_ROLE, \"Sender needs MANAGE_DIGITALTWIN_ROLE Role\") {\n    string memory DID = generateDID(idNumber);\n\n    addClaimWithIdentifier(DID, kind, ipfsHash);\n    assertClaim(DID);\n  }\n\n  function generateDID(bytes32 idNumber) internal pure returns (string memory) {\n    return string(abi.encodePacked(\"did:mint:identity:\", idNumber));\n  }\n\n  function edit(bytes32 idNumber, string memory ipfsHash)\n    public\n    authWithCustomReason(MANAGE_DIGITALTWIN_ROLE, \"Sender needs MANAGE_DIGITALTWIN_ROLE Role\")\n  {\n    string memory DID = generateDID(idNumber);\n    require(claimExists(DID), \"Claim does not exists\");\n\n    editClaimWithIdentifier(DID, ipfsHash);\n  }\n\n  function get(bytes32 idNumber)\n    public\n    view\n    authWithCustomReason(MANAGE_DIGITALTWIN_ROLE, \"Sender needs MANAGE_DIGITALTWIN_ROLE Role\")\n    returns (string memory ipfsHash, bytes32 Nomor_Identitas)\n  {\n    string memory DID = generateDID(idNumber);\n    require(claimExists(DID), \"Claim does not exists\");\n\n    return (getClaimWithIdentifier(DID), idNumber);\n  }\n\n  /**\n   * @notice returns the number of claims\n   */\n  function getIndexLength() public view returns (uint256 length) {\n    length = _claimRegistry.length;\n  }\n\n  /**\n   * @notice returns claim at index\n   * @param index index of the claim to be retrieved\n   */\n  function getByIndex(uint256 index) public view returns (Claim memory item) {\n    item = _claimRegistry[index];\n  }\n\n  /**\n   * @notice returns claim for given DID\n   * @param DID DID of the claim to be retrieved\n   */\n  function getByKey(string memory DID) public view returns (Claim memory item) {\n    uint256 claimIndex1B = _claimIndex[DID];\n    if (claimIndex1B > 0) {\n      item = _claimRegistry[claimIndex1B - 1];\n    }\n  }\n\n  /**\n   * @notice returns all claims\n   */\n  function getContents() public view returns (Claim[] memory items) {\n    items = _claimRegistry;\n  }\n\n  //////\n  // UI Field Definition Functions\n  //////\n  string public _uiFieldDefinitionsHash;\n\n  /**\n   * @notice Set the UI field definition hash\n   * @param uiFieldDefinitionsHash IPFS hash containing the UI field definitions JSON\n   */\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash)\n    public\n    authWithCustomReason(UPDATE_UIFIELDDEFINITIONS_ROLE, \"Sender needs UPDATE_UIFIELDDEFINITIONS_ROLE\")\n  {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  /**\n   * @notice Returns the UI field definition hash\n   */\n  function getUIFieldDefinitionsHash() public view returns (string memory) {\n    return _uiFieldDefinitionsHash;\n  }\n}\n"
    },
    "contracts/_library/provenance/digitaltwin/DigitalTwin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\ncontract DigitalTwin {\n  bytes32 public constant DIGITAL_TWIN = \"DIGITAL_TWIN\";\n  bytes32 public constant UPGRADEABLE_REGISTRY_TARGET = \"UPGRADEABLE_REGISTRY_TARGET\";\n\n  struct Claim {\n    string DID;\n    address owner;\n    bytes32 kind;\n    address[] assertions;\n    uint256 createdAt;\n    string identifier;\n  }\n\n  /**\n   * Events\n   */\n  event ClaimWithIdentifierCreated(string DID, bytes32 kind, string identifier);\n  event ClaimAsserted(string DID, address identity);\n  event ClaimWithIdentifierUpdated(string DID, string identifier);\n\n  Claim[] internal _claimRegistry;\n\n  // Beware, the claimIndex is 1-based!\n  // Obviously a tradeoff, the main benefit is that by making it 1-based, 0 acts as an invalid index.\n  // This means we can use this mapping to check if the DID is known or not:\n  // _claimIndex[NON_EXISTING_DID] will resolve to 0 -> which is an invalid index -> non existing DID\n  mapping(string => uint256) internal _claimIndex;\n\n  function addClaimWithIdentifier(\n    string memory DID,\n    bytes32 kind,\n    string memory identifier\n  ) internal {\n    string[] memory DIDs = new string[](1);\n    DIDs[0] = DID;\n\n    bytes32[] memory kinds = new bytes32[](1);\n    kinds[0] = kind;\n\n    string[] memory identifiers = new string[](1);\n    identifiers[0] = identifier;\n\n    addClaimsWithIdentifier(DIDs, kinds, identifiers);\n  }\n\n  function addClaimsWithIdentifier(\n    string[] memory DIDs,\n    bytes32[] memory kinds,\n    string[] memory identifiers\n  ) internal {\n    require(DIDs.length == kinds.length, \"Invalid array length input\");\n    require(kinds.length == identifiers.length, \"Invalid array length input\");\n    require(DIDs.length > 0, \"Empty argument error\");\n\n    for (uint256 i = 0; i < DIDs.length; i++) {\n      string memory DID = DIDs[i];\n      bytes32 kind = kinds[0];\n      string memory identifier = identifiers[0];\n\n      require(kind.length > 0, \"Invalid kind\");\n      require(bytes(DID).length > 0, \"Invalid DID\");\n      require(bytes(identifier).length > 0, \"Invalid identifier\");\n\n      require(_claimIndex[DID] == 0, \"Claim already exists\");\n      _claimRegistry.push();\n      uint256 claimIndex = _claimRegistry.length;\n\n      Claim storage c = _claimRegistry[claimIndex - 1];\n      c.DID = DID;\n      c.identifier = identifier;\n      c.kind = kind;\n      c.createdAt = block.timestamp;\n      c.owner = msg.sender;\n\n      _claimIndex[DID] = claimIndex;\n\n      emit ClaimWithIdentifierCreated(c.DID, kind, c.identifier);\n    }\n  }\n\n  function assertClaim(string memory DID) internal {\n    require(_claimIndex[DID] != 0, \"Unknown field\");\n\n    uint256 claimIndex = _claimIndex[DID];\n    Claim storage c = _claimRegistry[claimIndex - 1];\n\n    c.assertions.push(msg.sender);\n\n    emit ClaimAsserted(DID, msg.sender);\n  }\n\n  function editClaimWithIdentifier(string memory DID, string memory identifier) internal {\n    require(_claimIndex[DID] != 0, \"Unknown field\");\n\n    uint256 claimIndex = _claimIndex[DID];\n    Claim storage c = _claimRegistry[claimIndex - 1];\n    c.identifier = identifier;\n\n    emit ClaimWithIdentifierUpdated(c.DID, c.identifier);\n  }\n\n  function getClaimWithIdentifier(string memory DID) public view returns (string memory identifier) {\n    require(_claimIndex[DID] != 0, \"Unknown field!\");\n\n    uint256 claimIndex = _claimIndex[DID];\n    Claim storage c = _claimRegistry[claimIndex - 1];\n\n    return c.identifier;\n  }\n\n  function claimExists(string memory DID) public view returns (bool) {\n    return _claimIndex[DID] > 0;\n  }\n}\n"
    },
    "contracts/expense/Expense.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/FiniteStateMachine.sol\";\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/ui/UIFieldDefinitions.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * @title Expense Contract\n */\ncontract Expense is FiniteStateMachine, IpfsFieldContainer, FileFieldContainer, UIFieldDefinitions {\n  bytes32 public constant UPGRADEABLE_REGISTRY_TARGET = \"UPGRADEABLE_REGISTRY_TARGET\";\n  bytes32 public constant CREATE_STATEMACHINE_ROLE = \"CREATE_STATEMACHINE_ROLE\";\n\n  /**\n   * Expense Events\n   */\n  event ExpenseCreated(uint256 fsmIndex, address owner, address registry);\n  event ExpenseSubmitted(address owner, address expense, uint256 amount);\n  event ExpenseSubmittedWithException(address owner, address expense, uint256 amount, string comment);\n  event ExpenseReviewed(address owner, address expense, uint256 amount);\n  event ExpenseNeedsUpdate(address owner, address expense, uint256 amount, string comment);\n  event ExpenseAccepted(address owner, address expense, uint256 amount);\n  event ExpenseRejected(address owner, address expense, uint256 amount, string comment);\n  event ExpenseForceApproved(address owner, address expense, uint256 amount, string comment);\n  event AmountChanged(address sender, uint256 fromAmount, uint256 toAmount);\n  event ProofChanged(address sender, string fromProof, string toProof);\n\n  /**\n   * @dev State Constants\n   *\n   * DRAFT = the expense is added, possibly with missing info\n   * SUBMITTED = submitted to the OB for review, all precoditions are met\n   * SUBMITTED_WITH_EXCEPTION = submitted expense does not meet all preconditions\n   * REVIEWED = the OB has reviewed the invoice\n   * NEEDS_UPDATE = the OB has sent the invoice back to the CFP for modification\n   * APPROVED = VDB approves the invoice out of REVIEWED\n   * REJECTED = VDB (or DGD) rejects the invoice out of reviewed (a comment is required)\n   * FORCE_APPROVED = VDB approves the invoice out of REVIEWED even of it is not ok\n   */\n  bytes32 private constant STATE_DRAFT = \"DRAFT\";\n  bytes32 private constant STATE_SUBMITTED = \"SUBMITTED\";\n  bytes32 private constant STATE_SUBMITTED_WITH_EXCEPTION = \"SUBMITTED_WITH_EXCEPTION\";\n  bytes32 private constant STATE_REVIEWED = \"REVIEWED\";\n  bytes32 private constant STATE_NEEDS_UPDATE = \"NEEDS_UPDATE\";\n  bytes32 private constant STATE_APPROVED = \"APPROVED\";\n  bytes32 private constant STATE_REJECTED = \"REJECTED\";\n  bytes32 private constant STATE_FORCE_APPROVED = \"FORCE_APPROVED\";\n\n  /**\n   * @dev Role Constants\n   */\n  bytes32 private constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 private constant ROLE_REVISOR = \"ROLE_REVISOR\";\n  bytes32 private constant ROLE_USER = \"ROLE_USER\";\n\n  /**\n   * Expense states\n   */\n  bytes32[] public _allStates = [\n    STATE_DRAFT,\n    STATE_SUBMITTED,\n    STATE_SUBMITTED_WITH_EXCEPTION,\n    STATE_REVIEWED,\n    STATE_NEEDS_UPDATE,\n    STATE_APPROVED,\n    STATE_REJECTED,\n    STATE_FORCE_APPROVED\n  ];\n\n  /**\n   * @dev Expense roles\n   */\n  bytes32[] public _allRoles = [ROLE_ADMIN, ROLE_REVISOR, ROLE_USER];\n\n  /**\n   * @dev Expense helper role collection\n   * specifies anyone who can edit an exponse\n   */\n  bytes32[] private _canEdit = [ROLE_ADMIN, ROLE_USER];\n\n  /**\n   * @dev The address of the upgradeable registry this contract belongs to.\n   * Note that both this property together with the UPGRADEABLE_REGISTRY_TARGET const define a contract\n   * that is part of an upgradeable registry and provides the link to the registry if required.\n   */\n  address public _upgradeableRegistry;\n\n  /**\n   * @dev StateMachineMeta contains meta data for every StateMachine - seeing as struct are not composable\n   * and the base StateMachine struct is defined in the FiniteStateMachine abstract there's no other\n   * way to compose structs than having two separte arrays where the indices match.\n   *\n   * @dev Mint is aware of the above and will zip these two into a single struct so statemachines\n   * from the outside will look as a composition of both StateMachine and StateMachineMeta structs.\n   */\n  StateMachineMeta[] internal _meta;\n\n  /**\n   * @dev The index is a collection of DIDs for every state machine in the registry\n   * Usually the getIndex call returns a list of contract addresses however as FSMs are\n   * uniquely identified by their DID we return those instead\n   */\n  string[] internal _index;\n\n  /**\n   * @dev Struct defining an Expense\n   * @notice Gets decorated together with the StateMachine structs and forms the Expense FSM\n   */\n  struct StateMachineMeta {\n    string DID;\n    uint256 amount;\n    string proof;\n    string settlement;\n    string callForTenders;\n    string[] tenderResponses;\n    string tenderSelectionArgumentation;\n    address owner;\n    string reasonForRejection;\n    string revisorComment;\n    string ipfsFieldContainerHash;\n  }\n\n  constructor(address gateKeeper, address registry) Secured(gateKeeper) {\n    require(registry != address(0x0), \"registry can not be zero\");\n    _upgradeableRegistry = registry;\n  }\n\n  //////\n  // FSM Definition Functions\n  //////\n\n  /**\n   * @notice Returns initial state\n   */\n  function initialState() public pure override returns (bytes32) {\n    return STATE_DRAFT;\n  }\n\n  /**\n   * @notice Returns all possible states\n   */\n  function allStates() public view override returns (bytes32[] memory) {\n    return _allStates;\n  }\n\n  /**\n   * @notice Returns all possible roles\n   */\n  function allRoles() public view override returns (bytes32[] memory) {\n    return _allRoles;\n  }\n\n  /**\n   * @notice Retrieve all possible next states for a certain state\n   * @param state state\n   */\n  function getNextStatesForState(bytes32 state) public view override returns (bytes32[] memory test) {\n    bytes32[] memory states;\n\n    if (state == STATE_DRAFT || state == STATE_NEEDS_UPDATE) {\n      states = new bytes32[](2);\n      states[0] = STATE_SUBMITTED;\n      states[1] = STATE_SUBMITTED_WITH_EXCEPTION;\n    }\n\n    if (state == STATE_SUBMITTED || state == STATE_SUBMITTED_WITH_EXCEPTION) {\n      states = new bytes32[](2);\n      states[0] = STATE_REVIEWED;\n      states[1] = STATE_NEEDS_UPDATE;\n    }\n\n    if (state == STATE_REVIEWED) {\n      states = new bytes32[](4);\n      states[0] = STATE_REJECTED;\n      states[1] = STATE_APPROVED;\n      states[2] = STATE_FORCE_APPROVED;\n      states[3] = STATE_NEEDS_UPDATE;\n    }\n\n    if (state == STATE_APPROVED || state == STATE_FORCE_APPROVED) {\n      states = new bytes32[](1);\n      states[0] = STATE_REJECTED;\n    }\n\n    return states;\n  }\n\n  /**\n   * @notice Retrieve all roles that are allowed to move it to the given state\n   * @param state state\n   */\n  function getAllowedRolesForState(bytes32 state) public view override returns (bytes32[] memory) {\n    bytes32[] memory roles;\n\n    if (state == STATE_SUBMITTED || state == STATE_SUBMITTED_WITH_EXCEPTION) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    if (state == STATE_NEEDS_UPDATE) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    if (state == STATE_REVIEWED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_USER;\n    }\n\n    if (state == STATE_APPROVED || state == STATE_FORCE_APPROVED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_REVISOR;\n    }\n\n    if (state == STATE_REJECTED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_REVISOR;\n    }\n\n    return roles;\n  }\n\n  /**\n   * @notice Returns method signatures for functions which are allowed to execute in the given state\n   * @param state state\n   */\n  function getAllowedFunctionsForState(bytes32 state) public view override returns (bytes4[] memory) {\n    bytes4[] memory functions;\n\n    if (state == STATE_DRAFT) {\n      functions = new bytes4[](4);\n      functions[0] = this.addCallForTendersDocumentation.selector;\n      functions[1] = this.addTenderResponse.selector;\n      functions[2] = this.addTenderSelectionArgumentation.selector;\n      functions[3] = this.edit.selector;\n    }\n\n    if (state == STATE_SUBMITTED || state == STATE_SUBMITTED_WITH_EXCEPTION) {\n      functions = new bytes4[](2);\n      functions[0] = this.setNeedsUpdateRejectionReason.selector;\n      functions[1] = this.edit.selector;\n    }\n\n    if (state == STATE_REVIEWED) {\n      functions = new bytes4[](2);\n      functions[0] = this.setRejectedRejectionReason.selector;\n      functions[1] = this.edit.selector;\n    }\n\n    if (state == STATE_APPROVED || state == STATE_FORCE_APPROVED) {\n      functions = new bytes4[](2);\n      functions[0] = this.setRejectedRejectionReason.selector;\n      functions[1] = this.recordRevisorComment.selector;\n    }\n\n    return functions;\n  }\n\n  /**\n   * @notice Returns method signatures for functions that act as preconditions that must be met in order to transition to the given state\n   * @param state state\n   */\n  function getPreconditionsForState(bytes32 state) public view override returns (bytes4[] memory) {\n    bytes4[] memory preConditions;\n\n    if (\n      state == STATE_SUBMITTED ||\n      state == STATE_SUBMITTED_WITH_EXCEPTION ||\n      state == STATE_NEEDS_UPDATE ||\n      state == STATE_REJECTED\n    ) {\n      preConditions = new bytes4[](1);\n      preConditions[0] = this.canBeSubmitted.selector;\n    }\n\n    return preConditions;\n  }\n\n  /**\n   * @notice Returns method signatures for functions that will get called after transitioning to the given state\n   * @param state state\n   */\n  function getCallbacksForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that need to be called before transitioning to the given state\n   * @param state state\n   */\n  function getPreFunctionForState(bytes32 state) public pure override returns (bytes4) {}\n\n  //////\n  // UI Field Definition Functions\n  //////\n\n  /**\n   * @notice Set the UI field definition hash\n   * @param uiFieldDefinitionsHash IPFS hash containing the UI field definitions JSON\n   */\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash)\n    public\n    override\n    authWithCustomReason(UPDATE_UIFIELDDEFINITIONS_ROLE, \"Sender needs UPDATE_UIFIELDDEFINITIONS_ROLE\")\n  {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  /**\n   * @notice Returns the UI field definition hash\n   */\n  function getUIFieldDefinitionsHash() public view override returns (string memory) {\n    return _uiFieldDefinitionsHash;\n  }\n\n  //////\n  // Factory Functions\n  //////\n\n  /**\n   * @notice Create a new statemachine\n   * @param amount expense amount\n   * @param proof IPFS hash of the proof\n   * @param settlement settlement method (Bank or Cash)\n   * @param ipfsFieldContainerHash IPFS hash of the metadata fields\n   * @param owner expense owner\n   */\n  function create(\n    uint256 amount,\n    string memory proof,\n    string memory settlement,\n    string memory ipfsFieldContainerHash,\n    address owner\n  ) public authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\") {\n    _registry.push();\n    StateMachine storage sm = _registry[_registry.length - 1];\n    sm.currentState = initialState();\n    sm.createdAt = block.timestamp;\n    sm.index = _registry.length - 1;\n\n    _meta.push();\n    StateMachineMeta storage meta = _meta[_meta.length - 1];\n    meta.amount = amount;\n    meta.proof = proof;\n    meta.settlement = settlement;\n    meta.ipfsFieldContainerHash = ipfsFieldContainerHash;\n    meta.owner = owner;\n    meta.DID = generateDID(_meta.length - 1);\n\n    _index.push();\n    _index[_index.length - 1] = meta.DID;\n\n    emit ExpenseCreated(sm.index, owner, _upgradeableRegistry);\n  }\n\n  /**\n   * @notice Edit an existing statemachine\n   * @param fsmIndex registry index of the statemachine struct\n   * @param amount expense amount\n   * @param proof IPFS hash of the proof\n   * @param settlement settlement method (Bank or Cash)\n   * @param callForTenders IPFS hash of the call for tenders document\n   * @param ipfsFieldContainerHash IPFS hash of the metadata fields\n   */\n  function edit(\n    uint256 fsmIndex,\n    uint256 amount,\n    string memory proof,\n    string memory settlement,\n    string memory callForTenders,\n    string memory ipfsFieldContainerHash\n  )\n    public\n    authManyWithCustomReason(_canEdit, \"Edit requires one of roles: ROLE_ADMIN, ROLE_CFP, ROLE_OB, ROLE_VDB\")\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    // Verify input (copy paste of validations  we perform in the factory)\n    require(amount > 0, \"The amount of an expense cannot be zero\");\n    require(bytes(proof).length > 0, \"A proof file is required for all expenses\");\n\n    // Verify input (trigger verifications that were done from REVIEWED -> SUBMITTED)\n    canBeSubmitted(fsmIndex, _registry[fsmIndex].currentState, STATE_SUBMITTED);\n\n    if (amount != _meta[fsmIndex].amount) {\n      emit AmountChanged(msg.sender, _meta[fsmIndex].amount, amount);\n    }\n\n    if (uint256(keccak256(abi.encodePacked(proof))) != uint256(keccak256(abi.encodePacked(_meta[fsmIndex].proof)))) {\n      emit ProofChanged(msg.sender, _meta[fsmIndex].proof, proof);\n    }\n\n    _meta[fsmIndex].amount = amount;\n    _meta[fsmIndex].proof = proof;\n    _meta[fsmIndex].settlement = settlement;\n    _meta[fsmIndex].callForTenders = callForTenders;\n    _meta[fsmIndex].ipfsFieldContainerHash = ipfsFieldContainerHash;\n\n    transitionState(fsmIndex, STATE_REVIEWED);\n  }\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  //////\n  // Syncable Functions\n  //////\n\n  /**\n   * @notice Returns the structs composing a statemachine for given index\n   * @param fsmIndex state machine index\n   */\n  function getByIndex(uint256 fsmIndex) public view returns (StateMachine memory item, StateMachineMeta memory meta) {\n    item = _registry[fsmIndex];\n    meta = _meta[fsmIndex];\n  }\n\n  /**\n   * @notice Returns all state machines structs in a single fetch\n   */\n  function getContents() public view returns (StateMachine[] memory registry, StateMachineMeta[] memory meta) {\n    registry = _registry;\n    meta = _meta;\n  }\n\n  /**\n   * @notice Returns the (DID) index\n   */\n  function getIndex() public view returns (string[] memory index) {\n    return _index;\n  }\n\n  //////\n  // Expense Functions\n  //////\n\n  /**\n   * @notice Set rejection reason for STATE_NEEDS_UPDATE\n   * @param fsmIndex state machine index\n   * @param rejectionReason reason for rejection\n   */\n  function setNeedsUpdateRejectionReason(uint256 fsmIndex, string memory rejectionReason)\n    public\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    setRejectionReason(fsmIndex, rejectionReason, STATE_NEEDS_UPDATE);\n  }\n\n  /**\n   * @notice Set rejection reason for STATE_REJECTED\n   * @param fsmIndex state machine index\n   * @param rejectionReason reason for rejection\n   */\n  function setRejectedRejectionReason(uint256 fsmIndex, string memory rejectionReason)\n    public\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    setRejectionReason(fsmIndex, rejectionReason, STATE_REJECTED);\n  }\n\n  /**\n   * @notice Set a rejection reason document IPFS hash and transition to the given next state\n   * @param fsmIndex state machine index\n   * @param rejectionReason IPFS hash of the rejection reason document\n   * @param nextState next state to transition to\n   */\n  function setRejectionReason(\n    uint256 fsmIndex,\n    string memory rejectionReason,\n    bytes32 nextState\n  ) private doesStateMachineExists(fsmIndex) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    bytes memory bytesRejectionReason = bytes(rejectionReason);\n    require(bytesRejectionReason.length > 0, \"The rejection reason is required\");\n    meta.reasonForRejection = rejectionReason;\n    transitionState(fsmIndex, nextState);\n  }\n\n  /**\n   * @notice Add call for tenders IPFS hash\n   * @param fsmIndex state machine index\n   * @param callForTenders IPFS hash of the call for tenders document\n   */\n  function addCallForTendersDocumentation(uint256 fsmIndex, string memory callForTenders)\n    public\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    bytes memory bytesCallForTenders = bytes(callForTenders);\n    require(bytesCallForTenders.length > 0, \"You need to enter a call for tenders document\");\n\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.callForTenders = callForTenders;\n  }\n\n  /**\n   * @notice Add tender response document IPFS hash\n   * @param fsmIndex state machine index\n   * @param tenderResponse IPFS hash of the tender response document\n   */\n  function addTenderResponse(uint256 fsmIndex, string memory tenderResponse)\n    public\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    bytes memory bytesTenderResponse = bytes(tenderResponse);\n    require(bytesTenderResponse.length > 0, \"You need to enter a call for tenders response document\");\n\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.tenderResponses.push(tenderResponse);\n  }\n\n  /**\n   * @notice Add tender selection document IPFS hash\n   * @param fsmIndex state machine index\n   * @param tenderSelectionArgumentation IPFS hash of the tender selection document\n   */\n  function addTenderSelectionArgumentation(uint256 fsmIndex, string memory tenderSelectionArgumentation)\n    public\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    bytes memory bytesTenderSelectionArgumentation = bytes(tenderSelectionArgumentation);\n    require(bytesTenderSelectionArgumentation.length > 0, \"You need to enter a tender selection document\");\n\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.tenderSelectionArgumentation = tenderSelectionArgumentation;\n  }\n\n  /**\n   * @notice Add revisor comment document IPFS hash\n   * @param fsmIndex state machine index\n   * @param revisorComment IPFS hash of the revisor comment document\n   */\n  function recordRevisorComment(uint256 fsmIndex, string memory revisorComment)\n    public\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    bytes memory bytesRevisorComment = bytes(revisorComment);\n    require(bytesRevisorComment.length > 0, \"You need to enter a revisor comment document\");\n\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    meta.revisorComment = revisorComment;\n  }\n\n  /**\n   * @notice Returns whether an expense can be submitted or not\n   * @param fsmIndex state machine index\n   * @param toState state where we are transitioning to\n   * @dev This is a precondition function\n   */\n  function canBeSubmitted(\n    uint256 fsmIndex,\n    bytes32, /* fromState */\n    bytes32 toState\n  ) public view doesStateMachineExists(fsmIndex) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n\n    if (toState == STATE_SUBMITTED) {\n      require(meta.amount > 0, \"The amount of an expense cannot be zero\");\n      if (meta.amount > 850000) {\n        bytes memory callForTenders = bytes(meta.callForTenders);\n        require(\n          callForTenders.length > 0,\n          \"Since the amount of the expense is over 8500 euro, you need to upload a call for tenders\"\n        );\n        bytes memory tenderSelectionArgumentation = bytes(meta.tenderSelectionArgumentation);\n        require(\n          tenderSelectionArgumentation.length > 0,\n          \"Since the amount of the expense is over 8500 euro, you need to upload the reasons for selecting a tender\"\n        );\n        require(\n          meta.tenderResponses.length >= 3,\n          \"Since the amount of the expense is over 8500 euro, you need to upload at least three tender responses\"\n        );\n      }\n\n      if (uint256(keccak256(abi.encodePacked(meta.settlement))) == uint256(keccak256(abi.encodePacked(\"Cash\")))) {\n        require(meta.amount <= 300000, \"Cash expenses need to be less or equal than 3000 euro \");\n      }\n    }\n  }\n\n  /**\n   * @notice Returns whether an expense has a rejection reason set\n   * @param fsmIndex state machine index\n   * @dev This is a precondition function\n   */\n  function hasRejectionReason(\n    uint256 fsmIndex,\n    bytes32, /* fromState */\n    bytes32 /*toState*/\n  ) internal view doesStateMachineExists(fsmIndex) {\n    StateMachineMeta storage meta = _meta[fsmIndex];\n    bytes memory reasonForRejection = bytes(meta.reasonForRejection);\n    require(reasonForRejection.length > 0, \"A reason for a rejection is required\");\n  }\n\n  /**\n   * @notice Returns the preconditions for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the precondition function\n   */\n  function getPreconditionFunctionsForState(bytes32 state)\n    internal\n    view\n    override\n    returns (function(uint256, bytes32, bytes32) view[] memory)\n  {\n    function(uint256, bytes32, bytes32) internal view[] memory preConditions;\n\n    if (state == STATE_SUBMITTED || state == STATE_SUBMITTED_WITH_EXCEPTION) {\n      preConditions = new function(uint256, bytes32, bytes32) internal view[](1);\n      preConditions[0] = canBeSubmitted;\n    }\n\n    if (state == STATE_NEEDS_UPDATE || state == STATE_REJECTED) {\n      preConditions = new function(uint256, bytes32, bytes32) internal view[](1);\n      preConditions[0] = canBeSubmitted;\n    }\n\n    return preConditions;\n  }\n\n  /**\n   * @notice Returns the callbacks for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the callback function\n   */\n  function getCallbackFunctionsForState(bytes32 state)\n    internal\n    override\n    returns (function(uint256, bytes32, bytes32) internal[] memory)\n  {}\n\n  //////\n  // Helper Functions\n  //////\n\n  /**\n   * @notice Generate state machine DID\n   * @param fsmIndex state machine index\n   */\n  function generateDID(uint256 fsmIndex) internal view returns (string memory) {\n    return string(abi.encodePacked(\"did:vdb:expense:0x\", addressToString(address(this)), \":\", uintToString(fsmIndex)));\n  }\n}\n"
    },
    "contracts/billoflading/BillOfLading.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/provenance/statemachine/FiniteStateMachine.sol\";\nimport \"../_library/authentication/Secured.sol\";\nimport \"../_library/utility/metadata/IpfsFieldContainer.sol\";\nimport \"../_library/utility/metadata/FileFieldContainer.sol\";\nimport \"../_library/utility/ui/UIFieldDefinitions.sol\";\nimport \"../_library/utility/conversions/Converter.sol\";\n\n/**\n * @title BillOfLading Contract\n */\ncontract BillOfLading is FiniteStateMachine, IpfsFieldContainer, FileFieldContainer, UIFieldDefinitions {\n  bytes32 public constant UPGRADEABLE_REGISTRY_TARGET = \"UPGRADEABLE_REGISTRY_TARGET\";\n  bytes32 public constant CREATE_STATEMACHINE_ROLE = \"CREATE_STATEMACHINE_ROLE\";\n\n  /**\n   * @dev BillOfLading Events\n   */\n  event BillOfLadingCreated(uint256 fsmIndex, address owner, address registry);\n  event BillOfLadingSubmitted(address owner, address expense, uint256 amount);\n  event BillOfLadingSubmittedWithException(address owner, address expense, uint256 amount, string comment);\n  event BillOfLadingReviewed(address owner, address expense, uint256 amount);\n  event BillOfLadingNeedsUpdate(address owner, address expense, uint256 amount, string comment);\n  event BillOfLadingAccepted(address owner, address expense, uint256 amount);\n  event BillOfLadingRejected(address owner, address expense, uint256 amount, string comment);\n  event BillOfLadingForceApproved(address owner, address expense, uint256 amount, string comment);\n  event AmountChanged(address sender, uint256 fromAmount, uint256 toAmount);\n  event ProofChanged(address sender, string fromProof, string toProof);\n\n  /**\n   * @dev State Constants\n   */\n  bytes32 private constant STATE_PREPARED = \"PREPARED\";\n  bytes32 private constant STATE_PORT_OF_ORIGIN = \"PORT_OF_ORIGIN\";\n  bytes32 private constant STATE_IN_REVIEW = \"IN_REVIEW\";\n  bytes32 private constant STATE_INCOMPLETE = \"INCOMPLETE\";\n  bytes32 private constant STATE_EXCEPTION_GRANTED = \"EXCEPTION_GRANTED\";\n  bytes32 private constant STATE_CREATED = \"CREATED\";\n  bytes32 private constant STATE_IN_SHIPMENT = \"IN_SHIPMENT\";\n  bytes32 private constant STATE_PORT_OF_DESTINATION = \"PORT_OF_DESTINATION\";\n  bytes32 private constant STATE_RECEIVED = \"RECEIVED\";\n\n  /**\n   * @dev Role Constants\n   */\n  bytes32 private constant ROLE_ADMIN = \"ROLE_ADMIN\";\n  bytes32 private constant ROLE_CARRIER = \"ROLE_CARRIER\";\n  bytes32 private constant ROLE_CAPTAIN = \"ROLE_CAPTAIN\";\n  bytes32 private constant ROLE_FREIGHT_FORWARDER = \"ROLE_FREIGHT_FORWARDER\";\n\n  /**\n   * @dev BillOfLading states\n   */\n  bytes32[] public _allStates = [\n    STATE_PREPARED,\n    STATE_PORT_OF_ORIGIN,\n    STATE_IN_REVIEW,\n    STATE_INCOMPLETE,\n    STATE_EXCEPTION_GRANTED,\n    STATE_CREATED,\n    STATE_IN_SHIPMENT,\n    STATE_PORT_OF_DESTINATION,\n    STATE_RECEIVED\n  ];\n\n  /**\n   * @dev BillOfLading roles\n   */\n  bytes32[] public _allRoles = [ROLE_ADMIN, ROLE_CAPTAIN, ROLE_CARRIER, ROLE_FREIGHT_FORWARDER];\n\n  /**\n   * @dev BillOfLading helper role collection\n   * specifies anyone who can edit an exponse\n   */\n  bytes32[] private _canEdit = [ROLE_ADMIN, ROLE_FREIGHT_FORWARDER];\n\n  /**\n   * The address of the upgradeable registry this contract belongs to.\n   * Note that both this property together with the UPGRADEABLE_REGISTRY_TARGET const define a contract\n   * that is part of an upgradeable registry and provides the link to the registry if required.\n   */\n  address public _upgradeableRegistry;\n\n  /**\n   * @dev StateMachineMeta contains meta data for every StateMachine - seeing as struct are not composable\n   * and the base StateMachine struct is defined in the FiniteStateMachine abstract there's no other\n   * way to compose structs than having two separte arrays where the indices match.\n   *\n   * @dev Mint is aware of the above and will zip these two into a single struct so statemachines\n   * from the outside will look as a composition of both StateMachine and StateMachineMeta structs.\n   */\n  StateMachineMeta[] internal _meta;\n\n  /**\n   * @dev The index is a collection of DIDs for every state machine in the registry\n   * Usually the getIndex call returns a list of contract addresses however as FSMs are\n   * uniquely identified by their DID we return those instead\n   */\n  string[] internal _index;\n\n  /**\n   * @dev Struct defining an BillOfLading\n   * @notice Gets decorated together with the StateMachine structs and forms the BillOfLading FSM\n   */\n  struct StateMachineMeta {\n    string DID;\n    string ipfsFieldContainerHash;\n  }\n\n  constructor(address gateKeeper, address registry) Secured(gateKeeper) {\n    require(registry != address(0x0), \"registry can not be zero\");\n    _upgradeableRegistry = registry;\n  }\n\n  //////\n  // FSM Definition Functions\n  //////\n\n  /**\n   * @notice Returns initial state\n   */\n  function initialState() public pure override returns (bytes32) {\n    return STATE_PREPARED;\n  }\n\n  /**\n   * @notice Returns all possible states\n   */\n  function allStates() public view override returns (bytes32[] memory) {\n    return _allStates;\n  }\n\n  /**\n   * @notice Returns all possible roles\n   */\n  function allRoles() public view override returns (bytes32[] memory) {\n    return _allRoles;\n  }\n\n  /**\n   * @notice Retrieve all possible next states for a certain state\n   * @param state state\n   */\n  function getNextStatesForState(bytes32 state) public view override returns (bytes32[] memory test) {\n    bytes32[] memory states;\n\n    if (state == STATE_PREPARED) {\n      states = new bytes32[](1);\n      states[0] = STATE_PORT_OF_ORIGIN;\n    }\n\n    if (state == STATE_PORT_OF_ORIGIN) {\n      states = new bytes32[](1);\n      states[0] = STATE_IN_REVIEW;\n    }\n\n    if (state == STATE_IN_REVIEW) {\n      states = new bytes32[](2);\n      states[0] = STATE_INCOMPLETE;\n      states[1] = STATE_CREATED;\n    }\n\n    if (state == STATE_INCOMPLETE) {\n      states = new bytes32[](2);\n      states[0] = STATE_PORT_OF_ORIGIN;\n      states[1] = STATE_EXCEPTION_GRANTED;\n    }\n\n    if (state == STATE_EXCEPTION_GRANTED) {\n      states = new bytes32[](1);\n      states[0] = STATE_CREATED;\n    }\n\n    if (state == STATE_CREATED) {\n      states = new bytes32[](1);\n      states[0] = STATE_IN_SHIPMENT;\n    }\n\n    if (state == STATE_IN_SHIPMENT) {\n      states = new bytes32[](1);\n      states[0] = STATE_PORT_OF_DESTINATION;\n    }\n\n    if (state == STATE_PORT_OF_DESTINATION) {\n      states = new bytes32[](1);\n      states[0] = STATE_RECEIVED;\n    }\n\n    return states;\n  }\n\n  /**\n   * @notice Retrieve all roles that are allowed to move it to the given state\n   * @param state state\n   */\n  function getAllowedRolesForState(bytes32 state) public view override returns (bytes32[] memory) {\n    bytes32[] memory roles;\n\n    if (state == STATE_PREPARED || state == STATE_RECEIVED || state == STATE_PORT_OF_ORIGIN) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_FREIGHT_FORWARDER;\n    } else if (state == STATE_EXCEPTION_GRANTED) {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_CAPTAIN;\n    } else {\n      roles = new bytes32[](2);\n      roles[0] = ROLE_ADMIN;\n      roles[1] = ROLE_CARRIER;\n    }\n\n    return roles;\n  }\n\n  /**\n   * @notice Returns method signatures for functions which are allowed to execute in the given state\n   * @param state state\n   */\n  function getAllowedFunctionsForState(bytes32 state) public view override returns (bytes4[] memory) {\n    bytes4[] memory functions;\n\n    if (\n      state == STATE_PREPARED || state == STATE_PORT_OF_ORIGIN || state == STATE_IN_REVIEW || state == STATE_INCOMPLETE\n    ) {\n      functions = new bytes4[](1);\n      functions[0] = this.edit.selector;\n    }\n\n    return functions;\n  }\n\n  /**\n   * @notice Returns method signatures for functions that act as preconditions that must be met in order to transition to the given state\n   * @param state state\n   */\n  function getPreconditionsForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that will get called after transitioning to the given state\n   * @param state state\n   */\n  function getCallbacksForState(bytes32 state) public view override returns (bytes4[] memory) {}\n\n  /**\n   * @notice Returns method signatures for functions that need to be called before transitioning to the given state\n   * @param state state\n   */\n  function getPreFunctionForState(bytes32 state) public pure override returns (bytes4) {}\n\n  //////\n  // UI Field Definition Functions\n  //////\n\n  /**\n   * @notice Set the UI field definition hash\n   * @param uiFieldDefinitionsHash IPFS hash containing the UI field definitions JSON\n   */\n  function setUIFieldDefinitionsHash(string memory uiFieldDefinitionsHash)\n    public\n    override\n    authWithCustomReason(UPDATE_UIFIELDDEFINITIONS_ROLE, \"Sender needs UPDATE_UIFIELDDEFINITIONS_ROLE\")\n  {\n    _uiFieldDefinitionsHash = uiFieldDefinitionsHash;\n  }\n\n  /**\n   * @notice Returns the UI field definition hash\n   */\n  function getUIFieldDefinitionsHash() public view override returns (string memory) {\n    return _uiFieldDefinitionsHash;\n  }\n\n  //////\n  // Factory Functions\n  //////\n\n  /**\n   * @notice Create a new statemachine\n   * @param ipfsFieldContainerHash IPFS hash of the metadata fields\n   */\n  function create(string memory ipfsFieldContainerHash)\n    public\n    authWithCustomReason(CREATE_STATEMACHINE_ROLE, \"Sender needs CREATE_STATEMACHINE_ROLE\")\n  {\n    _registry.push();\n    StateMachine storage sm = _registry[_registry.length - 1];\n    sm.currentState = initialState();\n    sm.createdAt = block.timestamp;\n    sm.index = _registry.length - 1;\n\n    _meta.push();\n    StateMachineMeta storage meta = _meta[_meta.length - 1];\n    meta.ipfsFieldContainerHash = ipfsFieldContainerHash;\n    meta.DID = generateDID(_meta.length - 1);\n\n    _index.push();\n    _index[_index.length - 1] = meta.DID;\n\n    emit BillOfLadingCreated(sm.index, msg.sender, _upgradeableRegistry);\n  }\n\n  /**\n   * @notice Edit an existing statemachine\n   * @param fsmIndex registry index of the statemachine struct\n   * @param ipfsFieldContainerHash IPFS hash of the metadata fields\n   */\n  function edit(uint256 fsmIndex, string memory ipfsFieldContainerHash)\n    public\n    authManyWithCustomReason(_canEdit, \"Edit requires one of roles: ROLE_ADMIN, ROLE_CFP, ROLE_OB, ROLE_VDB\")\n    doesStateMachineExists(fsmIndex)\n    checkAllowedFunction(_registry[fsmIndex].currentState)\n  {\n    _meta[fsmIndex].ipfsFieldContainerHash = ipfsFieldContainerHash;\n  }\n\n  function canEdit() public view returns (bytes32[] memory) {\n    return _canEdit;\n  }\n\n  //////\n  // Syncable Functions\n  //////\n\n  /**\n   * @notice Returns the structs composing a statemachine for given index\n   * @param fsmIndex state machine index\n   */\n  function getByIndex(uint256 fsmIndex) public view returns (StateMachine memory item, StateMachineMeta memory meta) {\n    item = _registry[fsmIndex];\n    meta = _meta[fsmIndex];\n  }\n\n  /**\n   * @notice Returns all state machines structs in a single fetch\n   */\n  function getContents() public view returns (StateMachine[] memory registry, StateMachineMeta[] memory meta) {\n    registry = _registry;\n    meta = _meta;\n  }\n\n  /**\n   * @notice Returns the (DID) index\n   */\n  function getIndex() public view returns (string[] memory index) {\n    return _index;\n  }\n\n  //////\n  // BillOfLading Functions\n  //////\n\n  /**\n   * @notice Returns the preconditions for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the precondition function\n   */\n  function getPreconditionFunctionsForState(bytes32 state)\n    internal\n    view\n    override\n    returns (function(uint256, bytes32, bytes32) view[] memory)\n  {}\n\n  /**\n   * @notice Returns the callbacks for given state\n   * @param state state\n   * @dev Internal helper function that returns actual function pointers so a method can\n   * loop those and effectively call the callback function\n   */\n  function getCallbackFunctionsForState(bytes32 state)\n    internal\n    override\n    returns (function(uint256, bytes32, bytes32) internal[] memory)\n  {}\n\n  //////\n  // Helper Functions\n  //////\n\n  /**\n   * @notice Generate state machine DID\n   * @param fsmIndex state machine index\n   */\n  function generateDID(uint256 fsmIndex) internal view returns (string memory) {\n    return\n      string(abi.encodePacked(\"did:demo:billoflading:0x\", addressToString(address(this)), \":\", uintToString(fsmIndex)));\n  }\n}\n"
    },
    "contracts/_library/utility/upgrading/UpgradeableRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\nimport \"./Upgradeable.sol\";\n\ncontract UpgradeableRegistry is Upgradeable {\n  bytes32 public constant UPGRADEABLE_REGISTRY = \"UPGRADEABLE_REGISTRY\";\n\n  address[] internal _registries;\n  mapping(address => bool) internal _blacklisted;\n\n  constructor(address gateKeeper) Upgradeable(gateKeeper) {}\n\n  /**\n   * Returns the current registry address\n   */\n  function current() public view returns (address) {\n    return _target;\n  }\n\n  /**\n   * Returns all non blacklisted registry addresses\n   */\n  function registries() public view returns (address[] memory) {\n    uint8 counter = 0;\n    address[] memory tmp = new address[](_registries.length);\n    for (uint256 t = 0; t < _registries.length; t++) {\n      if (!_blacklisted[_registries[t]]) {\n        tmp[counter] = _registries[t];\n        counter++;\n      }\n    }\n\n    address[] memory nonBlacklistedRegistries = new address[](counter);\n    for (uint256 c = 0; c < counter; c++) {\n      nonBlacklistedRegistries[c] = tmp[c];\n    }\n\n    return nonBlacklistedRegistries;\n  }\n\n  /**\n   * Returns all addresses (including the blacklisted addresses)\n   */\n  function allRegistries() public view returns (address[] memory) {\n    return _registries;\n  }\n\n  /**\n   * Upgrade the current target\n   */\n  function upgrade(address registry) public {\n    require(_blacklisted[registry] == false, \"Can not upgrade to a previously blacklisted address\");\n    require(registry != _target, \"Registry already set\");\n    _registries.push(registry);\n    replace(registry);\n  }\n\n  /**\n   * Blacklist a registry address\n   */\n  function blacklist(address registry) public auth(UPGRADE_CONTRACT) {\n    bool known = false;\n    for (uint256 t = 0; t < _registries.length; t++) {\n      if (_registries[t] == registry) {\n        known = true;\n        break;\n      }\n    }\n    require(known == true, \"Unknown registry address\");\n    _blacklisted[registry] = true;\n  }\n\n  /**\n   * Whitelist a registry address\n   */\n  function whitelist(address registry) public auth(UPGRADE_CONTRACT) {\n    require(_blacklisted[registry] == true, \"Registry not blacklisted\");\n    _blacklisted[registry] = false;\n  }\n}\n"
    },
    "contracts/_library/utility/upgrading/Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\n\n/**\n * Base contract that all upgradeable contracts should use\n *\n * Contracts implementing this interface are all called using delegatecall from\n * a dispatcher. As a result, _dest variables are shared with the\n * dispatcher contract, which allows the called contract to update these at will.\n *\n * _dest is the address of the contract currently implementing all the\n * functionality of the composite contract. Contracts should update this by\n * calling the internal function `replace`, which updates _dest.\n *\n * When upgrading a contract, restrictions on permissible changes to the set of\n * storage variables must be observed. New variables may be added, but existing\n * ones may not be deleted or replaced. Changing variable names is acceptable.\n * Structs in arrays may not be modified, but structs in maps can be, following\n * the same rules described above.\n */\n\ncontract Upgradeable is Secured {\n  bytes32 public constant UPGRADE_CONTRACT = \"UPGRADE_CONTRACT\";\n  address public _target;\n\n  event TargetChanged(address originalTarget, address newTarget);\n\n  constructor(address gateKeeper) Secured(gateKeeper) {}\n\n  /**\n   * Performs a handover to a new implementing contract.\n   */\n  function replace(address target) internal auth(UPGRADE_CONTRACT) {\n    emit TargetChanged(_target, target);\n    _target = target;\n  }\n}\n"
    },
    "contracts/supplypackage/PackageRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/utility/upgrading/UpgradeableRegistry.sol\";\n\n/**\n * @title Registry contract for expense state machines\n */\ncontract PackageRegistry is UpgradeableRegistry {\n  constructor(address gateKeeper) UpgradeableRegistry(gateKeeper) {}\n}\n"
    },
    "contracts/orders/OrdersRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/utility/upgrading/UpgradeableRegistry.sol\";\n\n/**\n * @title Registry contract for bill of lading state machines\n */\ncontract OrdersRegistry is UpgradeableRegistry {\n  constructor(address gatekeeper) UpgradeableRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/identity/IdentityRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/utility/upgrading/UpgradeableRegistry.sol\";\n\n/**\n * @title Registry contract for identity digital twins\n */\ncontract IdentityRegistry is UpgradeableRegistry {\n  constructor(address gatekeeper) UpgradeableRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/expense/ExpenseRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/utility/upgrading/UpgradeableRegistry.sol\";\n\n/**\n * @title Registry contract for expense state machines\n */\ncontract ExpenseRegistry is UpgradeableRegistry {\n  constructor(address gatekeeper) UpgradeableRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/billoflading/BillOfLadingRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/utility/upgrading/UpgradeableRegistry.sol\";\n\n/**\n * @title Registry contract for bill of lading state machines\n */\ncontract BillOfLadingRegistry is UpgradeableRegistry {\n  constructor(address gatekeeper) UpgradeableRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/SimpleExampleV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"./SimpleIExample.sol\";\nimport \"../../../utility/upgrading/Upgradeable.sol\";\n\n/* The 'upgraded' version of ExampleV1 which modifies getUint to return 1 */\ncontract SimpleExampleV2 is SimpleIExample, Upgradeable {\n  constructor(address _gateKeeper) Upgradeable(_gateKeeper) {}\n\n  function getUint() public pure override returns (uint256) {\n    return 1;\n  }\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/SimpleIExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\n/* Example contracts interface */\nabstract contract SimpleIExample {\n  function getUint() public view virtual returns (uint256);\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/SimpleExampleV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"./SimpleIExample.sol\";\nimport \"../../../utility/upgrading/Upgradeable.sol\";\n\n/* Base version of Example class */\ncontract SimpleExampleV1 is SimpleIExample, Upgradeable {\n  constructor(address _gateKeeper) Upgradeable(_gateKeeper) {}\n\n  function getUint() public pure override returns (uint256) {\n    return 10;\n  }\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/ExampleV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"./ExampleStorage.sol\";\nimport \"./IExample.sol\";\nimport \"../../../utility/upgrading/Upgradeable.sol\";\n\n/* The 'upgraded' version of ExampleV1 which modifies getUint to return _value+10  */\ncontract ExampleV2 is ExampleStorage, IExample, Upgradeable {\n  constructor(address _gateKeeper) Upgradeable(_gateKeeper) {}\n\n  function getUint() public view override returns (uint256) {\n    return _value + 10;\n  }\n\n  function getValues() public view override returns (uint256 v1, uint256 v2) {\n    v1 = 100;\n    v2 = _value;\n  }\n\n  function setUint(uint256 value) public override {\n    _value = value;\n  }\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/ExampleStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\n/* Example contracts storage scheme */\ncontract ExampleStorage {\n  uint256 public _value;\n  uint256 public _value2;\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/IExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\n/* Example contracts interface */\nabstract contract IExample {\n  function getUint() public view virtual returns (uint256);\n\n  function getValues() public view virtual returns (uint256 v1, uint256 v2);\n\n  function setUint(uint256 value) public virtual;\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/ExampleV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"./ExampleStorage.sol\";\nimport \"./IExample.sol\";\nimport \"../../../utility/upgrading/Upgradeable.sol\";\n\n/* Base version of Example class */\ncontract ExampleV1 is ExampleStorage, IExample, Upgradeable {\n  constructor(address _gateKeeper) Upgradeable(_gateKeeper) {}\n\n  function getUint() public view override returns (uint256) {\n    return _value;\n  }\n\n  function getValues() public view override returns (uint256 v1, uint256 v2) {\n    v1 = _value;\n    v2 = 2;\n  }\n\n  function setUint(uint256 value) public override {\n    _value = value;\n  }\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/ExampleDispatcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../../../utility/upgrading/Dispatcher.sol\";\nimport \"./ExampleStorage.sol\";\n\n/* Dispatcher for Example contracts */\ncontract ExampleDispatcher is ExampleStorage, Dispatcher {\n  constructor(address _gateKeeper) Dispatcher(_gateKeeper) {}\n}\n"
    },
    "contracts/_library/utility/upgrading/Dispatcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./Upgradeable.sol\";\n\n/**\n * Found at: https://gist.github.com/Arachnid/4ca9da48d51e23e5cfe0f0e14dd6318f and\n * https://github.com/maraoz/solidity-proxy/blob/master/contracts/Dispatcher.sol\n *\n * The dispatcher is a minimal 'shim' that dispatches calls to a targeted\n * contract. Calls are made using 'delegatecall', meaning all storage and value\n * is kept on the dispatcher. As a result, when the target is updated, the new\n * contract inherits all the stored data and value from the old contract.\n */\n\ncontract Dispatcher is Upgradeable {\n  constructor(address gateKeeper) Upgradeable(gateKeeper) {}\n\n  fallback() external {\n    bytes4 sig;\n    assembly {\n      sig := calldataload(0)\n    }\n    address dest = _target;\n\n    assembly {\n      calldatacopy(0x0, 0x0, calldatasize())\n      let callResult := delegatecall(sub(gas(), 10000), dest, 0x0, calldatasize(), 0, 0)\n      let retSz := returndatasize()\n      returndatacopy(0, 0, retSz)\n      return(0, retSz)\n    }\n  }\n\n  function setTarget(address target) public {\n    replace(target);\n  }\n}\n"
    },
    "contracts/_library/_test/utility/upgrading/SimpleExampleDispatcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../../../utility/upgrading/Dispatcher.sol\";\nimport \"../../../authentication/Secured.sol\";\n\n/* Dispatcher for Example contracts */\ncontract SimpleExampleDispatcher is Dispatcher {\n  constructor(address _gateKeeper) Dispatcher(_gateKeeper) {}\n}\n"
    },
    "contracts/_library/tokens/ERC777/ERC777Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../../authentication/Secured.sol\";\nimport \"./IERC777TokenRecipient.sol\";\nimport \"./IERC777TokenSender.sol\";\nimport \"./IERC777Token.sol\";\n\nabstract contract ERC777Token is IERC777Token, Secured {\n  string public _name;\n  string public _symbol;\n  uint256 public _totalSupply;\n  uint256 public _granularity;\n\n  mapping(address => uint256) private balances;\n  mapping(address => mapping(address => bool)) private operators;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity\n  ) {\n    _name = name;\n    _symbol = symbol;\n    _totalSupply = 0;\n    require(granularity >= 1, \"The smallest unit must be greater than or equal to 1\");\n    _granularity = granularity;\n  }\n\n  /**\n   * Get the balance for a given address\n   * @param owner token owner\n   */\n  function balanceOf(address owner) public view override returns (uint256) {\n    return balances[owner];\n  }\n\n  /**\n   * Mint a certain amount of tokens for a certain address\n   */\n  function mint(address to, uint256 amount) public auth(MINT_ROLE) {\n    require(isOperatorFor(msg.sender, to), \"Only operators can mint tokens\");\n    require(isGranular(uint256(amount)), \"Only amounts which are a multiple of the granularity are allowed\");\n\n    _totalSupply = _totalSupply + (amount);\n    balances[to] = balances[to] + (amount);\n\n    emit Minted(msg.sender, to, amount, \"\");\n  }\n\n  /**\n   * Burn a certain amount of tokens for a certain address\n   */\n  function burn(address from, uint256 amount) public auth(BURN_ROLE) {\n    require(isOperatorFor(msg.sender, from), \"Only operators can burn tokens\");\n    require(isGranular(amount), \"Only amounts which are a multiple of the granularity are allowed\");\n    require(amount > 0, \"Amount should be bigger than 0\");\n    require(amount <= balances[from], \"Account balance should be sufficient\");\n\n    balances[from] = balances[from] - (amount);\n    _totalSupply = _totalSupply - (amount);\n\n    emit Burned(msg.sender, from, amount, \"\", \"\");\n  }\n\n  /**\n   * Send a certain amount of tokens to a certain address\n   */\n  function send(address to, uint256 amount) public override {\n    return send(to, amount, \"\");\n  }\n\n  /**\n   * Send a certain amount of tokens to a certain address\n   */\n  function send(\n    address to,\n    uint256 amount,\n    bytes memory userData\n  ) public override {\n    return operatorSend(msg.sender, to, amount, userData, \"\");\n  }\n\n  /**\n   * Authorize the given operator full control over the msg.sender's tokens\n   */\n  function authorizeOperator(address operator) public override {\n    require(operator != msg.sender, \"The owner of the tokens is by default authorized\");\n    operators[msg.sender][operator] = true;\n    emit AuthorizedOperator(operator, msg.sender);\n  }\n\n  /**\n   * Authorize the given operator full control over the tokenholder's tokens\n   */\n  function authorizeOperator(address operator, address tokenHolder) public auth(MANAGE_OPERATOR_ROLE) {\n    operators[tokenHolder][operator] = true;\n    emit AuthorizedOperator(operator, tokenHolder);\n  }\n\n  /**\n   * Revoke the given operator's full control over the msg.sender's tokens\n   */\n  function revokeOperator(address operator) public override {\n    require(operator != msg.sender, \"The owner of the tokens is by default authorized\");\n    operators[msg.sender][operator] = false;\n    emit RevokedOperator(operator, msg.sender);\n  }\n\n  /**\n   * Revoke the given operator's full control over tokenholder's tokens\n   */\n  function revokeOperator(address operator, address tokenHolder) public auth(MANAGE_OPERATOR_ROLE) {\n    operators[tokenHolder][operator] = false;\n    emit RevokedOperator(operator, tokenHolder);\n  }\n\n  /**\n   * Get a boolean indicating if the given operator address is operator of the given tokenholder\n   */\n  function isOperatorFor(address operator, address tokenHolder) public view override returns (bool) {\n    return operator == tokenHolder || operators[tokenHolder][operator];\n  }\n\n  /**\n   * Effectively sends the tokens and emits the proper events\n   */\n  function operatorSend(\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory userData,\n    bytes memory operatorData\n  ) public override {\n    require(isOperatorFor(msg.sender, from), \"Only operators can send tokens\");\n    require(isGranular(amount), \"Only amounts which are a multiple of the granularity are allowed\");\n    require(to != address(0), \"Only send to valid addresses\");\n    require(balances[from] >= amount, \"Ensure sender has sufficient balance\");\n\n    IERC777TokenSender(from).tokensToSend(msg.sender, from, to, amount, userData, operatorData);\n\n    balances[from] = balances[from] - (amount);\n    balances[to] = balances[to] + (amount);\n\n    IERC777TokenRecipient(to).tokensReceived(msg.sender, from, to, amount, userData, operatorData);\n\n    emit Sent(msg.sender, from, to, amount, userData, operatorData);\n  }\n\n  /**\n   * Check if the given amount is a multiple of the contract's granularity.\n   */\n  function isGranular(uint256 amount) internal view returns (bool) {\n    return (amount / (_granularity)) * (_granularity) == amount;\n  }\n}\n"
    },
    "contracts/_library/tokens/ERC777/IERC777TokenRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nabstract contract IERC777TokenRecipient {\n  function tokensReceived(\n    address operator,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory userData,\n    bytes memory operatorData\n  ) public virtual;\n}\n"
    },
    "contracts/_library/tokens/ERC777/IERC777TokenSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nabstract contract IERC777TokenSender {\n  function tokensToSend(\n    address operator,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory userData,\n    bytes memory operatorData\n  ) public virtual;\n}\n"
    },
    "contracts/_library/tokens/ERC777/IERC777Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nabstract contract IERC777Token {\n  bytes32 public constant MINT_ROLE = \"MINT_ROLE\";\n  bytes32 public constant BURN_ROLE = \"BURN_ROLE\";\n  bytes32 public constant MANAGE_OPERATOR_ROLE = \"MANAGE_OPERATOR_ROLE\";\n\n  event Sent(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    bytes userData,\n    bytes operatorData\n  );\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes userData, bytes operatorData);\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n  function balanceOf(address owner) public view virtual returns (uint256);\n\n  function send(address to, uint256 amount) public virtual;\n\n  function send(\n    address to,\n    uint256 amount,\n    bytes memory userData\n  ) public virtual;\n\n  function authorizeOperator(address operator) public virtual;\n\n  function revokeOperator(address operator) public virtual;\n\n  function isOperatorFor(address operator, address tokenHolder) public view virtual returns (bool);\n\n  function operatorSend(\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory userData,\n    bytes memory operatorData\n  ) public virtual;\n}\n"
    },
    "contracts/_library/tokens/ERC1410/IERC1410Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../ERC777/IERC777Token.sol\";\n\n/**\n * Please note that for simplicity, and because we won't be using this contract with an enormous\n * amount of tranches all functions marked external were made public\n */\nabstract contract IERC1410Token is IERC777Token {\n  event SentByTranche(\n    bytes32 indexed fromTranche,\n    address operator,\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  event ChangedTranche(bytes32 indexed fromTranche, bytes32 indexed toTranche, uint256 amount);\n\n  event AuthorizedOperatorByTranche(bytes32 indexed tranche, address indexed operator, address indexed tokenHolder);\n  event RevokedOperatorByTranche(bytes32 indexed tranche, address indexed operator, address indexed tokenHolder);\n\n  function balanceOf(address tokenHolder) public view virtual override returns (uint256);\n\n  function balanceOfByTranche(bytes32 tranche, address tokenHolder) public view virtual returns (uint256);\n\n  function tranchesOf(address tokenHolder) public view virtual returns (bytes32[] memory);\n\n  function sendByTranche(\n    bytes32 tranche,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public virtual returns (bytes32);\n\n  function sendByTranches(\n    bytes32[] memory tranches,\n    address to,\n    uint256[] memory amounts,\n    bytes memory data\n  ) public virtual returns (bytes32[] memory);\n\n  function operatorSendByTranche(\n    bytes32 tranche,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) public virtual returns (bytes32);\n\n  function operatorSendByTranches(\n    bytes32[] memory tranches,\n    address from,\n    address to,\n    uint256[] memory amounts,\n    bytes memory data,\n    bytes memory operatorData\n  ) public virtual returns (bytes32[] memory);\n\n  function getDefaultTranches(address tokenHolder) public view virtual returns (bytes32[] memory);\n\n  function setDefaultTranches(bytes32[] memory tranches) public virtual;\n\n  function defaultOperatorsByTranche(bytes32 tranche) public view virtual returns (address[] memory);\n\n  function authorizeOperatorByTranche(bytes32 tranche, address operator) public virtual;\n\n  function revokeOperatorByTranche(bytes32 tranche, address operator) public virtual;\n\n  function isOperatorForTranche(\n    bytes32 tranche,\n    address operator,\n    address tokenHolder\n  ) public view virtual returns (bool);\n\n  function hasTranche(address tokenHolder, bytes32 tranche) public view virtual returns (bool);\n\n  function addTranche(address tokenHolder, bytes32 tranche) public virtual;\n}\n"
    },
    "contracts/_library/tokens/ERC1410/ERC1410Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../authentication/Secured.sol\";\nimport \"../ERC777/IERC777Token.sol\";\nimport \"../ERC777/IERC777TokenRecipient.sol\";\nimport \"../ERC777/IERC777TokenSender.sol\";\nimport \"./IERC1410Token.sol\";\n\ncontract ERC1410Token is IERC777Token, IERC1410Token, Secured, Ownable {\n  uint256 public _granularity;\n  uint256 public totalSupply;\n  address[] public tokenHolders;\n\n  mapping(address => uint256) internal seen;\n  mapping(address => bytes32[]) internal _tranches;\n  mapping(address => bytes32[]) internal defaultTranches;\n  mapping(address => mapping(bytes32 => uint256)) internal balancesByTranche;\n  mapping(address => mapping(bytes32 => address[])) internal pDefaultOperatorsByTranche;\n  mapping(address => mapping(bytes32 => mapping(address => bool))) internal operatorsByTranche;\n\n  constructor(address gateKeeper, uint256 granularity) Secured(gateKeeper) {\n    require(granularity >= 1, \"The smalles unit for interaction with this contract must be greater than or equal to 1\");\n    _granularity = granularity;\n    totalSupply = 0;\n  }\n\n  /**\n   * Get the balance for a given address\n   * @param tokenHolder token owner\n   */\n  function balanceOf(address tokenHolder) public view override(IERC1410Token, IERC777Token) returns (uint256) {\n    uint256 balance = 0;\n    for (uint256 i = 0; i < _tranches[tokenHolder].length; i++) {\n      balance = balance + (balancesByTranche[tokenHolder][_tranches[tokenHolder][i]]);\n    }\n    return balance;\n  }\n\n  /**\n   * Get balance for given token holder by tranche\n   */\n  function balanceOfByTranche(bytes32 tranche, address tokenHolder) public view override returns (uint256) {\n    return balancesByTranche[tokenHolder][tranche];\n  }\n\n  /**\n   * Mint a certain amount of tokens for a certain address\n   */\n  function mint(address to, uint256 amount) public auth(MINT_ROLE) {\n    if (seen[to] == 0) {\n      tokenHolders.push(to);\n      seen[to] = block.timestamp;\n    }\n\n    bytes32 tranche = getDefaultTranche(to);\n    mint(tranche, to, amount);\n  }\n\n  /**\n   * Mint a certain amount of tokens for a certain address into a tranche\n   */\n  function mint(\n    bytes32 tranche,\n    address to,\n    uint256 amount\n  ) public auth(MINT_ROLE) {\n    require(isOperatorForTranche(tranche, msg.sender, to), \"Only operators can mint tokens\");\n    require(isGranular(uint256(amount)), \"Only amounts which are a multiple of the granularity are allowed\");\n\n    if (seen[to] == 0) {\n      tokenHolders.push(to);\n      seen[to] = block.timestamp;\n    }\n\n    totalSupply = totalSupply + (amount);\n    balancesByTranche[to][tranche] = balancesByTranche[to][tranche] + (amount);\n\n    emit Minted(msg.sender, to, amount, \"\");\n  }\n\n  /**\n   * Burn a certain amount of tokens for a certain address\n   */\n  function burn(address from, uint256 amount) public auth(BURN_ROLE) {\n    bytes32 tranche = getDefaultTranche(from);\n    burn(tranche, from, amount);\n  }\n\n  /**\n   * Burn a certain amount of tokens for a certain address\n   */\n  function burn(\n    bytes32 tranche,\n    address from,\n    uint256 amount\n  ) public auth(BURN_ROLE) {\n    require(isOperatorForTranche(tranche, msg.sender, from), \"Only operators can burn tokens\");\n    require(isGranular(amount), \"Only amounts which are a multiple of the granularity are allowed\");\n    require(amount > 0, \"Amount should be bigger than 0\");\n    require(amount <= balancesByTranche[from][tranche], \"Account balance should be sufficient\");\n\n    balancesByTranche[from][tranche] = balancesByTranche[from][tranche] - (amount);\n    totalSupply = totalSupply - (amount);\n\n    emit Burned(msg.sender, from, amount, \"\", \"\");\n  }\n\n  /**\n   * Get default operators for given tranche\n   */\n  function defaultOperatorsByTranche(bytes32 tranche) public view override returns (address[] memory) {\n    return pDefaultOperatorsByTranche[msg.sender][tranche];\n  }\n\n  /**\n   * Authorize the given operator full control over the msg.sender's tokens\n   */\n  function authorizeOperator(address operator) public override {\n    bytes32 tranche = getDefaultTranche(msg.sender);\n    authorizeOperatorByTranche(tranche, operator);\n  }\n\n  /**\n   * Authorize the given operator full control over the tokenholder's tokens\n   */\n  function authorizeOperator(address operator, address tokenHolder) public auth(MANAGE_OPERATOR_ROLE) {\n    bytes32 tranche = getDefaultTranche(msg.sender);\n    authorizeOperatorByTranche(tranche, operator, tokenHolder);\n  }\n\n  /**\n   * Authorize the given operator full control over the msg.sender's tokens for a given tranche\n   */\n  function authorizeOperatorByTranche(bytes32 tranche, address operator) public override {\n    require(operator != msg.sender, \"The owner of the tokens is by default authorized\");\n    operatorsByTranche[msg.sender][tranche][operator] = true;\n    emit AuthorizedOperator(operator, msg.sender);\n    emit AuthorizedOperatorByTranche(tranche, operator, msg.sender);\n  }\n\n  /**\n   * Authorize the given operator full control over the tokenholder's tokens for a given tranche\n   */\n  function authorizeOperatorByTranche(\n    bytes32 tranche,\n    address operator,\n    address tokenHolder\n  ) public auth(MANAGE_OPERATOR_ROLE) {\n    operatorsByTranche[tokenHolder][tranche][operator] = true;\n    emit AuthorizedOperator(operator, tokenHolder);\n    emit AuthorizedOperatorByTranche(tranche, operator, msg.sender);\n  }\n\n  /**\n   * Revoke the given operator's full control over the msg.sender's tokens\n   */\n  function revokeOperator(address operator) public override {\n    bytes32 tranche = getDefaultTranche(msg.sender);\n    revokeOperatorByTranche(tranche, operator);\n  }\n\n  /**\n   * Revoke the given operator's full control over tokenholder's tokens\n   */\n  function revokeOperator(address operator, address tokenHolder) public auth(MANAGE_OPERATOR_ROLE) {\n    bytes32 tranche = getDefaultTranche(msg.sender);\n    revokeOperatorByTranche(tranche, operator, tokenHolder);\n  }\n\n  /**\n   * Revoke the given operator's full control over tokenholder's tokens for a given tranche\n   */\n  function revokeOperatorByTranche(bytes32 tranche, address operator) public override {\n    require(operator != msg.sender, \"The owner of the tokens is by default authorized\");\n    operatorsByTranche[msg.sender][tranche][operator] = false;\n    emit RevokedOperator(operator, msg.sender);\n    emit RevokedOperatorByTranche(tranche, operator, msg.sender);\n  }\n\n  /**\n   * Revoke the given operator's full control over tokenholder's tokens for a given tranche\n   */\n  function revokeOperatorByTranche(\n    bytes32 tranche,\n    address operator,\n    address tokenHolder\n  ) public auth(MANAGE_OPERATOR_ROLE) {\n    operatorsByTranche[msg.sender][tranche][operator] = false;\n    emit RevokedOperator(operator, tokenHolder);\n    emit RevokedOperatorByTranche(tranche, operator, msg.sender);\n  }\n\n  /**\n   * Get a boolean indicating if the given operator address is operator of the given tokenholder\n   */\n  function isOperatorFor(address operator, address tokenHolder) public view override returns (bool) {\n    bytes32 tranche = getDefaultTranche(tokenHolder);\n    return isOperatorForTranche(tranche, operator, tokenHolder);\n  }\n\n  /**\n   * Get a boolean indicating if the given operator address is operator of the given tokenholder, for a given tranche\n   */\n  function isOperatorForTranche(\n    bytes32 tranche,\n    address operator,\n    address tokenHolder\n  ) public view override returns (bool) {\n    return operator == this.owner() || operatorsByTranche[tokenHolder][tranche][operator];\n  }\n\n  /**\n   * Send a certain amount of tokens to a certain address\n   */\n  function send(address to, uint256 amount) public override {\n    return send(to, amount, \"\");\n  }\n\n  /**\n   * Send a certain amount of tokens to a certain address\n   */\n  function send(\n    address to,\n    uint256 amount,\n    bytes memory userData\n  ) public override {\n    return operatorSend(msg.sender, to, amount, userData, \"\");\n  }\n\n  /**\n   * Effectively sends the tokens and emits the proper events\n   */\n  function operatorSend(\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory userData,\n    bytes memory operatorData\n  ) public override {\n    bytes32 tranche = getDefaultTranche(from);\n    operatorSendByTranche(tranche, from, to, amount, userData, operatorData);\n  }\n\n  function sendByTranche(\n    bytes32 tranche,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public override returns (bytes32) {\n    return operatorSendByTranche(tranche, msg.sender, to, amount, data, \"\");\n  }\n\n  function sendByTranches(\n    bytes32[] memory tranches,\n    address to,\n    uint256[] memory amounts,\n    bytes memory data\n  ) public override returns (bytes32[] memory tr) {\n    return operatorSendByTranches(tranches, msg.sender, to, amounts, data, \"\");\n  }\n\n  function operatorSendByTranche(\n    bytes32 tranche,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data,\n    bytes memory operatorData\n  ) public override returns (bytes32 tr) {\n    bytes32[] memory tranches = new bytes32[](1);\n    tranches[0] = tranche;\n\n    uint256[] memory amounts = new uint256[](1);\n    amounts[0] = amount;\n\n    operatorSendByTranches(tranches, from, to, amounts, data, operatorData);\n  }\n\n  function operatorSendByTranches(\n    bytes32[] memory tranches,\n    address from,\n    address to,\n    uint256[] memory amounts,\n    bytes memory data,\n    bytes memory operatorData\n  ) public override returns (bytes32[] memory tr) {\n    require(tranches.length == amounts.length, \"No 1-1 match between tranches and amounts\");\n    require(to != address(0), \"Only send to valid addresses\");\n\n    if (seen[to] == 0) {\n      tokenHolders.push(to);\n      seen[to] = block.timestamp;\n    }\n\n    for (uint256 i = 0; i < tranches.length; i++) {\n      bytes32 tranche = tranches[i];\n      uint256 amount = amounts[i];\n\n      require(isOperatorForTranche(tranche, msg.sender, from), \"Only operators can send tokens\");\n      require(isGranular(amount), \"Only amounts which are a multiple of the granularity are allowed\");\n      require(balancesByTranche[from][tranche] >= amount, \"Ensure sender has sufficient balance\");\n\n      // IERC777TokenSender(_from).tokensToSend(\n      //   msg.sender,\n      //   _from,\n      //   _to,\n      //   amount,\n      //   _data,\n      //   _operatorData\n      // );\n\n      balancesByTranche[from][tranche] = balancesByTranche[from][tranche] - (amount);\n      balancesByTranche[to][tranche] = balancesByTranche[to][tranche] + (amount);\n\n      // IERC777TokenRecipient(_to).tokensReceived(\n      //   msg.sender,\n      //   _from,\n      //   _to,\n      //   amount,\n      //   _data,\n      //   _operatorData\n      // );\n\n      emit Sent(msg.sender, from, to, amount, data, operatorData);\n\n      emit SentByTranche(tranche, msg.sender, from, to, amount, data, operatorData);\n    }\n  }\n\n  /**\n   * Check if tokenholder has a tranche\n   */\n  function hasTranche(address tokenHolder, bytes32 tranche) public view override returns (bool) {\n    for (uint256 i = 0; i < _tranches[tokenHolder].length; i++) {\n      if (_tranches[tokenHolder][i] == tranche) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set default tranches for a certain tokenholder\n   */\n  function addTranche(address tokenHolder, bytes32 tranche) public override {\n    if (!hasTranche(tokenHolder, tranche)) {\n      _tranches[tokenHolder].push(tranche);\n    }\n  }\n\n  /**\n   * Get tranches for a certain tokenholder\n   */\n  function tranchesOf(address tokenHolder) public view override returns (bytes32[] memory tranches) {\n    return _tranches[tokenHolder];\n  }\n\n  /**\n   * Get default tranches for a certain tokenholder\n   */\n  function getDefaultTranches(address tokenHolder) public view override returns (bytes32[] memory tranches) {\n    return defaultTranches[tokenHolder];\n  }\n\n  /**\n   * Get default tranche for a certain tokenholder\n   */\n  function getDefaultTranche(address tokenHolder) public view returns (bytes32 tranche) {\n    return defaultTranches[tokenHolder][0];\n  }\n\n  /**\n   * Set default tranches for a certain tokenholder\n   */\n  function setDefaultTranches(bytes32[] memory tranches) public override {\n    defaultTranches[msg.sender] = tranches;\n    _tranches[msg.sender] = tranches;\n  }\n\n  /**\n   * Check if the given amount is a multiple of the contract's granularity.\n   */\n  function isGranular(uint256 amount) internal view returns (bool) {\n    return (amount / (_granularity)) * (_granularity) == amount;\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/_library/tokencuratedregistry/TokenCuratedRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IListing.sol\";\nimport \"./IListingFactory.sol\";\nimport \"../tokens/ERC20/IERC20Token.sol\";\nimport \"../authentication/Secured.sol\";\nimport \"../utility/syncing/Syncable.sol\";\nimport \"../utility/metadata/IpfsFieldContainer.sol\";\nimport \"./Challenge.sol\";\nimport \"./ChallengeRegistry.sol\";\n\ncontract TokenCuratedRegistry is Secured, Syncable {\n  bytes32 public constant WITHDRAW_FUNDS_ROLE = \"WITHDRAW_FUNDS_ROLE\";\n  bytes32 public constant CURATE_CHALLENGE_ROLE = \"CURATE_CHALLENGE_ROLE\";\n  bytes32 public constant CHANGE_SETTINGS_ROLE = \"CHANGE_SETTINGS_ROLE\";\n\n  // ------\n  // EVENTS\n  // ------\n\n  event Enlisted(address listing, uint256 stake, uint256 price);\n  event Challenged(address listing, uint256 stake, address challenge);\n  event Unlisted(address listing);\n  event ChallengeApproved(address listing);\n  event ChallengeDenied(address listing);\n  event Increased(address listing, uint256 increasedBy, uint256 newStake);\n  event Decreased(address listing, uint256 decreasedBy, uint256 newStake);\n  event Withdrawn(address by, uint256 balance);\n  event MinEnlistAmountChanged(uint256 value);\n  event MinChallengeAmountChanged(uint256 value);\n  event CuratorPercentageChanged(uint256 value);\n\n  // Maps listingHashes to associated listing data\n  mapping(address => IListing) public listings;\n  address[] listingsIndex;\n\n  // Global Variables\n  IERC20Token public token;\n  IListingFactory public listingFactory;\n  ChallengeRegistry challengeRegistry;\n\n  // Settings\n  uint256 minEnlistAmount = 0;\n  uint256 minChallengeAmount = 0;\n  uint256 curatorPercentage = 0;\n\n  /**\n  @dev Contructor\n  @notice                Sets the address for token\n  @param _gateKeeper     Address of the gatekeeper\n  @param _token          Address of the token\n  */\n  constructor(\n    address _gateKeeper,\n    address _token,\n    address _listingFactory,\n    address _challengeRegistry,\n    uint256 _minEnlistAmount,\n    uint256 _minChallengeAmount,\n    uint256 _curatorPercentage\n  ) Secured(_gateKeeper) {\n    token = IERC20Token(_token);\n    listingFactory = IListingFactory(_listingFactory);\n    challengeRegistry = ChallengeRegistry(_challengeRegistry);\n\n    minEnlistAmount = _minEnlistAmount;\n    minChallengeAmount = _minChallengeAmount;\n    curatorPercentage = _curatorPercentage;\n  }\n\n  /**\n  @notice                 Allows a seller to list data to be available for selling.\n  @notice                 Takes tokens from user.\n  @param _stakeAmount     The number of ERC20 tokens a user is willing to potentially stake\n  @param _price           Price of the listing\n  @param _metadata        Metadata\n  */\n  function enlist(\n    uint256 _stakeAmount,\n    uint256 _price,\n    string calldata _metadata\n  ) external {\n    // Stake must be above a certain amount\n    require(_stakeAmount >= minEnlistAmount, \"_stakeAmount >= minEnlistAmount\");\n\n    // Transfers tokens from user to Registry contract\n    require(token.transferFrom(msg.sender, address(this), _stakeAmount), \"transfer failed\");\n\n    // Add listing to listings\n    listingFactory.createListing(msg.sender, _price, _stakeAmount, address(this), _metadata);\n  }\n\n  /**\n  @notice                 Listing is added through the factory\n  @param _listing         Address of the added listing\n  */\n  function addListing(address _listing) public {\n    IListing listing = IListing(_listing);\n\n    // Add to mapping\n    listings[_listing] = listing;\n    listingsIndex.push(_listing);\n\n    // Event\n    emit Enlisted(_listing, listing.stake(), listing.price());\n  }\n\n  /**\n  @notice             Allows the owner of a listing to remove the listing from the whitelist\n  @notice             Returns all tokens to the owner of the listing\n  @param _listing     The listing of a user's listing\n  */\n  function unlist(address _listing) public {\n    IListing listing = listings[_listing];\n    require(msg.sender == listing.owner(), \"sender is not the owner\");\n\n    // Transfers any remaining balance back to the owner\n    if (listing.stake() > 0) require(token.transfer(listing.owner(), listing.stake()), \"transfer failed\");\n\n    // Blacklist\n    listing.setWhitelisted(false);\n\n    // Event\n    emit Unlisted(_listing);\n  }\n\n  /**\n  @notice             Allows the owner of a listing to increase their unstaked deposit.\n  @param _listing     The listing of a user's application/listing\n  @param _stakeAmount The number of ERC20 tokens to increase a user's unstaked deposit\n  */\n  function increase(address _listing, uint256 _stakeAmount) public {\n    IListing listing = listings[_listing];\n\n    require(listing.owner() == msg.sender, \"owner is not the sender\");\n    require(token.transferFrom(msg.sender, address(this), _stakeAmount), \"transfer failed\");\n\n    listing.setStake(listing.stake() + _stakeAmount);\n\n    // Event\n    emit Increased(_listing, _stakeAmount, listing.stake());\n  }\n\n  /**\n  @notice             Allows the owner of a listing to decrease their unstaked deposit.\n  @notice             The listing keeps its previous status.\n  @param _listing     The listing of a user's application/listing\n  @param _stakeAmount The number of ERC20 tokens to decrease a user's unstaked deposit\n  */\n  function decrease(address _listing, uint256 _stakeAmount) public {\n    IListing listing = listings[_listing];\n\n    uint256 stake = listing.stake();\n\n    require(listing.owner() == msg.sender, \"owner is not the sender\");\n    require(_stakeAmount <= stake, \"_stakeAmount <= stake\");\n    require(stake - _stakeAmount >= minEnlistAmount, \"stake - _stakeAmount >= minEnlistAmount\");\n\n    require(token.transfer(msg.sender, _stakeAmount), \"transfer failed\");\n\n    listing.setStake(stake - _stakeAmount);\n\n    // Event\n    emit Decreased(_listing, _stakeAmount, listing.stake());\n  }\n\n  /**\n  @notice             Starts a challenge for a listing.\n  @dev                Tokens are taken from the challenger and the data seller's deposit is locked.\n  @param _listing     The listing of data.\n  @param _stakeAmount The amount the challenger wants to stake.\n  */\n  function challenge(\n    address _listing,\n    uint256 _stakeAmount,\n    string memory _metadata\n  ) public {\n    require(_stakeAmount >= minChallengeAmount, \"_stakeAmount >= minChallengeAmount\");\n\n    IListing listing = listings[_listing];\n\n    // Takes tokens from challenger\n    require(token.transferFrom(msg.sender, address(this), _stakeAmount), \"transfer failed\");\n\n    // Add challenge to the challenges mapping\n    Challenge _challenge = new Challenge(msg.sender, _stakeAmount, _listing, address(gateKeeper));\n\n    // Metadata role\n    gateKeeper.createPermission(msg.sender, address(_challenge), bytes32(\"UPDATE_IPFSCONTAINERHASH_ROLE\"), msg.sender);\n\n    // Add metadata\n    _challenge.setIpfsFieldContainerHash(_metadata);\n\n    // Add challenge to registry\n    challengeRegistry.addChallenge(address(_challenge));\n    // Add the necessary data on the challenged listing\n    listing.setChallengesStake(listing.challengesStake() + _stakeAmount);\n    listing.setNumberOfChallenges(listing.numberOfChallenges() + 1);\n    listing.setChallenge(address(_challenge));\n\n    // Event\n    emit Challenged(_listing, _stakeAmount, address(_challenge));\n  }\n\n  /**\n  @notice             Marks a challenge as resolved.\n  @notice             Rewards the winner tokens and either whitelists or de-whitelists the listing.\n  @param _listing     A listing with a challenge that is to be resolved\n  */\n  function approveChallenge(address _listing) public auth(CURATE_CHALLENGE_ROLE) {\n    IListing listing = listings[_listing];\n\n    uint256 challengesStake = listing.challengesStake();\n\n    // Curator (msg.sender) should get 10% of the total sum of all challenge stakes + lising stake\n    uint256 curatorShare = challengesStake * (curatorPercentage / 100);\n    token.transfer(msg.sender, curatorShare);\n\n    // Challengers should get a percentage of the total sum of all challenge stakes + lising stake\n    // equal to their share of the total challenge stake\n    // Get all challenges that are unresolved and are linked to this listing,\n    for (uint256 i = 0; i < listing.getChallengesLength(); i++) {\n      Challenge _challenge = Challenge(listing.getChallengeAtIndex(i));\n\n      if (_challenge.resolved() == false) {\n        // Calculate what's left to divide between the challengers\n        uint256 challengerShare = challengesStake - curatorShare;\n        // Transfer percentage of challenge to THIS challenger\n        token.transfer(_challenge.challenger(), challengerShare * (_challenge.stake() / challengesStake));\n        // Set challenge as resolved\n        _challenge.setResolved(true);\n      }\n    }\n\n    // Take stake from listing\n    listing.setStake(0);\n    // Reset number of challenges and total challenges stake\n    listing.setChallengesStake(0);\n    listing.setNumberOfChallenges(0);\n\n    // Blacklist listing\n    listing.setWhitelisted(false);\n\n    // Event\n    emit ChallengeApproved(_listing);\n  }\n\n  /**\n  @notice             Marks a challenge as denied.\n  @notice             Rewards the listing seller tokens and de-whitelists the listing.\n  @param _listing     A listing with a challenge that is to be resolved\n  */\n  function denyChallenge(address _listing) public auth(CURATE_CHALLENGE_ROLE) {\n    IListing listing = listings[_listing];\n\n    uint256 challengesStake = listing.challengesStake();\n\n    // Admin (msg.sender) should get 10% of the total sum of all challenge stakes + lising stake\n    uint256 curatorShare = (challengesStake * curatorPercentage) / 100;\n    token.transfer(msg.sender, curatorShare);\n\n    // Transfer the rest of the stake to the data owner\n    token.transfer(listing.owner(), challengesStake - curatorShare);\n\n    // Get all challenges that are unresolved and are linked to this listing,\n    for (uint256 i = 0; i < listing.getChallengesLength(); i++) {\n      Challenge _challenge = Challenge(listing.getChallengeAtIndex(i));\n\n      if (_challenge.resolved() == false) {\n        // Set challenge as resolved\n        _challenge.setResolved(true);\n      }\n    }\n\n    // Reset number of challenges and total challenges stake\n    listing.setChallengesStake(0);\n    listing.setNumberOfChallenges(0);\n\n    // Event\n    emit ChallengeDenied(_listing);\n  }\n\n  /**\n  @notice      Withdraw all the funds from this contract: safety measure\n  */\n  function withdraw() public auth(WITHDRAW_FUNDS_ROLE) {\n    uint256 balance = address(this).balance;\n    token.transfer(msg.sender, address(this).balance);\n    emit Withdrawn(msg.sender, balance);\n  }\n\n  /**\n  @notice                   Sets the minEnlistAmount\n  @param _minEnlistAmount   minEnlistAmount\n  */\n  function setMinEnlistAmount(uint256 _minEnlistAmount) public auth(CHANGE_SETTINGS_ROLE) {\n    minEnlistAmount = _minEnlistAmount;\n    emit MinEnlistAmountChanged(_minEnlistAmount);\n  }\n\n  /**\n  @notice                     Sets the minChallengeAmount\n  @param _minChallengeAmount  minChallengeAmount\n  */\n  function setMinChallengeAmount(uint256 _minChallengeAmount) public auth(CHANGE_SETTINGS_ROLE) {\n    minChallengeAmount = _minChallengeAmount;\n    emit MinChallengeAmountChanged(_minChallengeAmount);\n  }\n\n  /**\n  @notice                   Sets the curatorPercentage\n  @param _curatorPercentage curatorPercentage\n  */\n  function setCuratorPercentage(uint256 _curatorPercentage) public auth(CHANGE_SETTINGS_ROLE) {\n    curatorPercentage = _curatorPercentage;\n    emit CuratorPercentageChanged(_curatorPercentage);\n  }\n\n  /**\n   * implementation of syncable methods\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = listingsIndex.length;\n  }\n\n  function getByIndex(uint256 index) public view returns (address key, address contractAddress) {\n    return getByKey(listingsIndex[index]);\n  }\n\n  function getByKey(address _key) public view returns (address key, address contractAddress) {\n    key = address(listings[_key]);\n    contractAddress = address(listings[_key]);\n  }\n}\n"
    },
    "contracts/_library/tokencuratedregistry/IListing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../tokens/ERC20/IERC20Token.sol\";\nimport \"../authentication/Secured.sol\";\nimport \"../utility/metadata/IpfsFieldContainer.sol\";\nimport \"./Challenge.sol\";\n\ncontract IListing is Secured, IpfsFieldContainer {\n  bytes32 public constant BLACKLIST_ROLE = \"BLACKLIST_ROLE\";\n\n  event Blacklisted(address listing);\n  event StakeSet(address listing, uint256 stake);\n  event ChallengesStakeSet(address listing, uint256 stake);\n  event ChallengeSet(address listing, address challenge);\n  event WhitelistedSet(address listing, bool whitelisted);\n  event PriceSet(address listing, uint256 price);\n  event ChallengeIDSet(address listing, uint256 challengeID);\n  event NumberOfChallengesSet(address listing, uint256 numberOfChallenges);\n\n  uint256 public price = 0;\n  uint256 public stake = 0;\n  uint256 public challengesStake = 0; // Total stake locked up in challenges on this listing\n  uint256 public numberOfChallenges = 0; // Total number of unresolved challenges\n  address[] public challenges; // Array of addresses of the challenges, needed to get them from within the TCR,\n  // using the getByIndex method on the challengeRegistry\n\n  bool public whitelisted = true; // Should the data appear on the listing or not\n  address public owner;\n\n  /**\n  @dev Contructor\n  @notice                Sets the address for token\n  @param _owner          Address of the owner\n  @param _price          Price for the listing\n  @param _stakeAmount    Amount staked for the listing\n  @param _gateKeeper     Address of the gatekeeper\n  */\n  constructor(\n    address _owner,\n    uint256 _price,\n    uint256 _stakeAmount,\n    address _gateKeeper\n  ) Secured(_gateKeeper) {\n    owner = _owner;\n    price = _price;\n    stake = _stakeAmount;\n  }\n\n  /**\n  @notice         Sets whitelisted to false: the listing should not appear anymore\n  */\n  function blacklist() public auth(BLACKLIST_ROLE) {\n    whitelisted = false;\n    emit Blacklisted(address(this));\n  }\n\n  /**\n  @notice         Sets the stake\n  @param _stake   Stake\n  */\n  function setStake(uint256 _stake) public {\n    stake = _stake;\n    emit StakeSet(address(this), _stake);\n  }\n\n  /**\n  @notice                   Sets the amount staked for all challenged\n  @param _challengesStake   Amount staked for all challenges\n  */\n  function setChallengesStake(uint256 _challengesStake) public {\n    challengesStake = _challengesStake;\n    emit ChallengesStakeSet(address(this), _challengesStake);\n  }\n\n  /**\n  @notice                      Sets the muber of challenges\n  @param _numberOfChallenges   Number of challenges added to this listing\n  */\n  function setNumberOfChallenges(uint256 _numberOfChallenges) public {\n    numberOfChallenges = _numberOfChallenges;\n    emit NumberOfChallengesSet(address(this), _numberOfChallenges);\n  }\n\n  /**\n  @notice               Sets whether or not the listing is whitelisted\n  @param _whitelisted   Whitelisted\n  */\n  function setWhitelisted(bool _whitelisted) public {\n    whitelisted = _whitelisted;\n    emit WhitelistedSet(address(this), _whitelisted);\n  }\n\n  /**\n  @notice         Sets the price\n  @param _price   Price\n  */\n  function setPrice(uint256 _price) public {\n    price = _price;\n    emit PriceSet(address(this), _price);\n  }\n\n  /**\n  @notice             Adds a challenge to the challenges array\n  @param _challenge   Address of challenge\n  */\n  function setChallenge(address _challenge) public {\n    challenges.push(_challenge);\n  }\n\n  /**\n  @notice        Gets length of the challenges array, with addresses of all challenges to this listing\n  */\n  function getChallengesLength() public view returns (uint256 length) {\n    length = challenges.length;\n  }\n\n  /**\n  @notice        Gets a challenge in the challenges array at a certain index\n  @param _index  Index of the challenge\n  */\n  function getChallengeAtIndex(uint256 _index) public view returns (address challenge) {\n    challenge = address(challenges[_index]);\n  }\n}\n"
    },
    "contracts/_library/tokencuratedregistry/IListingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../authentication/Secured.sol\";\n\nabstract contract IListingFactory is Secured {\n  event ListingAdded(address _address);\n\n  constructor(address _gateKeeper) Secured(_gateKeeper) {}\n\n  function createListing(\n    address _owner,\n    uint256 _price,\n    uint256 _stakeAmount,\n    address _tcr,\n    string memory _metadata\n  ) public virtual;\n}\n"
    },
    "contracts/_library/tokencuratedregistry/Challenge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../authentication/Secured.sol\";\nimport \"../utility/metadata/IpfsFieldContainer.sol\";\n\ncontract Challenge is Secured, IpfsFieldContainer {\n  event ResolvedSet(address challenge, bool resoved);\n\n  address public challenger;\n  bool public resolved = false;\n  uint256 public stake;\n  address public listing;\n  uint256 public timestamp;\n\n  /**\n  @dev Contructor\n  @notice                     Hold one challenge to a listing\n  @param _challenger          Owner of Challenge\n  @param _stakeAmount         Number of tokens at risk for either party during challenge\n  @param _listing             Listing this challenge was added to\n  @param _gateKeeper          Address of the gatekeeper\n  */\n  constructor(\n    address _challenger,\n    uint256 _stakeAmount,\n    address _listing,\n    address _gateKeeper\n  ) Secured(_gateKeeper) IpfsFieldContainer() {\n    challenger = _challenger;\n    stake = _stakeAmount;\n    listing = _listing;\n    timestamp = block.timestamp;\n  }\n\n  /**\n  @notice            Sets resolved property\n  @param _resolved   Resolved\n  */\n  function setResolved(bool _resolved) public {\n    resolved = _resolved;\n    emit ResolvedSet(address(this), _resolved);\n  }\n}\n"
    },
    "contracts/_library/tokencuratedregistry/ChallengeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../authentication/Secured.sol\";\nimport \"../utility/syncing/Syncable.sol\";\nimport \"./Challenge.sol\";\n\ncontract ChallengeRegistry is Secured, Syncable {\n  event ChallengeAdded(address _address);\n\n  // Keep track of challenges\n  mapping(address => Challenge) public challenges;\n  address[] public challengesIndex; // Array of challenge ids\n\n  constructor(address _gateKeeper) Secured(_gateKeeper) {}\n\n  /**\n  @notice             Adds a challenge to the registry\n  @param _challenge   Address of the challenge to add\n  */\n  function addChallenge(address _challenge) public {\n    challenges[_challenge] = Challenge(address(_challenge));\n    challengesIndex.push(_challenge);\n    emit ChallengeAdded(_challenge);\n  }\n\n  /**\n   * implementation of syncable methods\n   */\n  function getIndexLength() public view override returns (uint256 length) {\n    length = challengesIndex.length;\n  }\n\n  function getByIndex(uint256 index) public view returns (address key, address contractAddress) {\n    return getByKey(challengesIndex[index]);\n  }\n\n  function getByKey(address _key) public view returns (address key, address contractAddress) {\n    key = address(challenges[_key]);\n    contractAddress = address(challenges[_key]);\n  }\n}\n"
    },
    "contracts/_library/tokencuratedregistry/Listing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IListing.sol\";\n\ncontract Listing is IListing {\n  /**\n  @dev Contructor\n  @notice                Sets the address for token\n  @param _owner          Address of the owner\n  @param _price          Price for the listing\n  @param _stakeAmount    Amount staked for the listing\n  @param _gateKeeper     Address of the gatekeeper\n  */\n  constructor(\n    address _owner,\n    uint256 _price,\n    uint256 _stakeAmount,\n    address _gateKeeper\n  ) IListing(_owner, _price, _stakeAmount, _gateKeeper) {}\n}\n"
    },
    "contracts/_library/tokens/ERC20/ERC20TokenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20TokenRegistry.sol\";\n\ncontract ERC20TokenRegistry is IERC20TokenRegistry {\n  event TokenAdded(address indexed token);\n\n  constructor(address gateKeeper) IERC20TokenRegistry(gateKeeper) {}\n\n  function addToken(string memory name, address token)\n    public\n    override\n    authWithCustomReason(LIST_TOKEN_ROLE, \"Sender needs LIST_TOKEN_ROLE\")\n  {\n    require(address(tokens[name]) == address(0x0), \"only accept unique names\");\n    tokens[name] = IERC20Token(token);\n    tokenIndex.push(name);\n    emit TokenAdded(token);\n  }\n\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenIndex.length;\n  }\n\n  function getByIndex(uint256 index) public view returns (string memory key, address contractAddress) {\n    return getByKey(tokenIndex[index]);\n  }\n\n  function getByKey(string memory _key) public view returns (string memory key, address contractAddress) {\n    contractAddress = address(tokens[_key]);\n    key = _key;\n  }\n}\n"
    },
    "contracts/share/ShareRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenRegistry.sol\";\n\n/**\n * @title Lists all deployed coins\n */\ncontract ShareRegistry is ERC20TokenRegistry {\n  constructor(address gateKeeper) ERC20TokenRegistry(gateKeeper) {}\n}\n"
    },
    "contracts/loyaltypoint/LoyaltyPointRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenRegistry.sol\";\n\n/**\n * @title Lists all deployed coins\n */\ncontract LoyaltyPointRegistry is ERC20TokenRegistry {\n  constructor(address gatekeeper) ERC20TokenRegistry(address(gateKeeper)) {}\n}\n"
    },
    "contracts/loan/LoanRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenRegistry.sol\";\n\n/**\n * @title Lists all deployed coins\n */\ncontract LoanRegistry is ERC20TokenRegistry {\n  constructor(address gatekeeper) ERC20TokenRegistry(address(gateKeeper)) {}\n}\n"
    },
    "contracts/currency/CurrencyRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenRegistry.sol\";\n\n/**\n * @title Lists all deployed coins\n */\ncontract CurrencyRegistry is ERC20TokenRegistry {\n  constructor(address gatekeeper) ERC20TokenRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/bonds/BondRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/tokens/ERC20/ERC20TokenRegistry.sol\";\n\n/**\n * @title Lists all deployed coins\n */\ncontract BondRegistry is ERC20TokenRegistry {\n  constructor(address gatekeeper) ERC20TokenRegistry(gatekeeper) {}\n}\n"
    },
    "contracts/_library/_test/tokens/ERC20/TestTokenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../../../tokens/ERC20/ERC20TokenRegistry.sol\";\n\ncontract TestTokenRegistry is ERC20TokenRegistry {\n  constructor(address gateKeeper) ERC20TokenRegistry(gateKeeper) {}\n}\n"
    },
    "contracts/_library/_test/tokens/ERC20/TestTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../../../tokens/ERC20/ERC20TokenFactory.sol\";\nimport \"./TestToken.sol\";\nimport \"./TestTokenRegistry.sol\";\n\ncontract TestTokenFactory is ERC20TokenFactory {\n  constructor(address registry, address gateKeeper) ERC20TokenFactory(registry, gateKeeper) {}\n\n  function createToken(string memory name, uint8 decimals) public auth(CREATE_TOKEN_ROLE) {\n    TestToken newToken = new TestToken(name, decimals, address(gateKeeper), _uiFieldDefinitionsHash);\n    _tokenRegistry.addToken(name, address(newToken));\n    emit TokenCreated(address(newToken), name);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"MINT_ROLE\"), msg.sender);\n    gateKeeper.createPermission(msg.sender, address(newToken), bytes32(\"BURN_ROLE\"), msg.sender);\n  }\n}\n"
    },
    "contracts/_library/_test/tokens/ERC20/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../../../tokens/ERC20/ERC20Token.sol\";\n\ncontract TestToken is ERC20Token {\n  constructor(\n    string memory name,\n    uint8 decimals,\n    address gateKeeper,\n    string memory uiFieldDefinitionsHash\n  ) ERC20Token(name, decimals, gateKeeper, uiFieldDefinitionsHash) {}\n\n  function getDecimalsFor(\n    bytes memory /*fieldName*/\n  ) public view override returns (uint256) {\n    return _decimals;\n  }\n\n  function getIndexLength() public view override returns (uint256 length) {\n    length = tokenHolders.length;\n  }\n\n  function getByIndex(uint256 index) public view returns (address holder, uint256 balance) {\n    holder = tokenHolders[index];\n    balance = balances[tokenHolders[index]].balance;\n  }\n\n  function getByKey(address key) public view returns (address holder, uint256 balance) {\n    holder = key;\n    balance = balances[key].balance;\n  }\n}\n"
    },
    "contracts/_library/_test/tokens/ERC20/TestApproveAndCallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\npragma solidity ^0.8.0;\n\nimport \"../../../tokens/IApproveAndCallable.sol\";\nimport \"./TestToken.sol\";\n\ncontract TestApproveAndCallable is IApproveAndCallable {\n  function receiveApproval(\n    address from,\n    uint256 amount,\n    address token,\n    bytes memory data\n  ) public override {\n    emit ReceivedApproval(from, amount, token, data);\n\n    assert(from != address(0x0));\n    assert(token != address(0x0));\n    assert(amount > 0);\n\n    require(\n      TestToken(token).allowance(from, address(this)) >= amount,\n      \"The allowance is less than the amount asking to be approved\"\n    );\n    TestToken(token).transferFrom(from, address(this), amount);\n  }\n}\n"
    },
    "contracts/roles/WholesalerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract WholesalerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_WHOLESALER = \"ROLE_WHOLESALER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_WHOLESALER;\n  }\n}\n"
    },
    "contracts/roles/WarehouseRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract WarehouseRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_WAREHOUSE = \"ROLE_WAREHOUSE\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_WAREHOUSE;\n  }\n}\n"
    },
    "contracts/roles/UserRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all users\n */\ncontract UserRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_USER = \"ROLE_USER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_USER;\n  }\n}\n"
    },
    "contracts/roles/TransporterRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract TransporterRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_TRANSPORTER = \"ROLE_TRANSPORTER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_TRANSPORTER;\n  }\n}\n"
    },
    "contracts/roles/SupplierRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract SupplierRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_SUPPLIER = \"ROLE_SUPPLIER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_SUPPLIER;\n  }\n}\n"
    },
    "contracts/roles/SSCRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract SSCRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_SSC = \"ROLE_SSC\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_SSC;\n  }\n}\n"
    },
    "contracts/roles/RevisorRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all revisors\n */\ncontract RevisorRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_REVISOR = \"ROLE_REVISOR\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_REVISOR;\n  }\n}\n"
    },
    "contracts/roles/RetailerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract RetailerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_RETAILER = \"ROLE_RETAILER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_RETAILER;\n  }\n}\n"
    },
    "contracts/roles/ResellerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all resellers\n */\ncontract ResellerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_RESELLER = \"ROLE_RESELLER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_RESELLER;\n  }\n}\n"
    },
    "contracts/roles/RequesterRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract RequesterRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_REQUESTER = \"ROLE_REQUESTER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_REQUESTER;\n  }\n}\n"
    },
    "contracts/roles/RegulatorRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all regulators\n */\ncontract RegulatorRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_REGULATOR = \"ROLE_REGULATOR\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_REGULATOR;\n  }\n}\n"
    },
    "contracts/roles/PharmacyRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all pharmacies\n */\ncontract PharmacyRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_PHARMACY = \"ROLE_PHARMACY\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_PHARMACY;\n  }\n}\n"
    },
    "contracts/roles/NotaryRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\ncontract NotaryRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_NOTARY = \"ROLE_NOTARY\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_NOTARY;\n  }\n}\n"
    },
    "contracts/roles/ManufacturerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all manufacturers\n */\ncontract ManufacturerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_MANUFACTURER = \"ROLE_MANUFACTURER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_MANUFACTURER;\n  }\n}\n"
    },
    "contracts/roles/MakerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all operators level one\n */\ncontract MakerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_MAKER = \"ROLE_MAKER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_MAKER;\n  }\n}\n"
    },
    "contracts/roles/LandRegistrarRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\ncontract LandRegistrarRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_LAND_REGISTRAR = \"ROLE_LAND_REGISTRAR\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_LAND_REGISTRAR;\n  }\n}\n"
    },
    "contracts/roles/FreightForwarderRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all carriers\n */\ncontract FreightForwarderRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_FREIGHT_FORWARDER = \"ROLE_FREIGHT_FORWARDER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_FREIGHT_FORWARDER;\n  }\n}\n"
    },
    "contracts/roles/CustomerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all customers\n */\ncontract CustomerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_CUSTOMER = \"ROLE_CUSTOMER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_CUSTOMER;\n  }\n}\n"
    },
    "contracts/roles/ConglomerateRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract ConglomerateRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_CONGLOMERATE = \"ROLE_CONGLOMERATE\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_CONGLOMERATE;\n  }\n}\n"
    },
    "contracts/roles/CheckerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all operators level one\n */\ncontract CheckerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_CHECKER = \"ROLE_CHECKER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_CHECKER;\n  }\n}\n"
    },
    "contracts/roles/CarrierRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all carriers\n */\ncontract CarrierRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_CARRIER = \"ROLE_CARRIER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_CARRIER;\n  }\n}\n"
    },
    "contracts/roles/CaptainRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all carriers\n */\ncontract CaptainRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_CAPTAIN = \"ROLE_CAPTAIN\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_CAPTAIN;\n  }\n}\n"
    },
    "contracts/roles/BuyerRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract BuyerRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_BUYER = \"ROLE_BUYER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_BUYER;\n  }\n}\n"
    },
    "contracts/roles/BusinessUnitRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract BusinessUnitRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_BU = \"ROLE_BU\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_BU;\n  }\n}\n"
    },
    "contracts/roles/BeneficiaryRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract BeneficiaryRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_BENEFICIARY = \"ROLE_BENEFICIARY\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_BENEFICIARY;\n  }\n}\n"
    },
    "contracts/roles/BankRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract BankRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_BANK = \"ROLE_BANK\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_BANK;\n  }\n}\n"
    },
    "contracts/roles/AWTARoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract AWTARoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_AWTA = \"ROLE_AWTA\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_AWTA;\n  }\n}\n"
    },
    "contracts/roles/AWEXRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract AWEXRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_AWEX = \"ROLE_AWEX\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_AWEX;\n  }\n}\n"
    },
    "contracts/roles/ApproverRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract ApproverRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_APPROVER = \"ROLE_APPROVER\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_APPROVER;\n  }\n}\n"
    },
    "contracts/roles/ApplicantRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract ApplicantRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_APPLICANT = \"ROLE_APPLICANT\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_APPLICANT;\n  }\n}\n"
    },
    "contracts/roles/AgentRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all agents\n */\ncontract AgentRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_AGENT = \"ROLE_AGENT\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_AGENT;\n  }\n}\n"
    },
    "contracts/roles/AdminRoleRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n\npragma solidity ^0.8.0;\n\nimport \"../_library/authentication/RoleRegistry.sol\";\n\n/**\n * @title Lists all administrators\n */\ncontract AdminRoleRegistry is RoleRegistry {\n  bytes32 public constant ROLE_ADMIN = \"ROLE_ADMIN\";\n\n  constructor(address gatekeeper) RoleRegistry(gatekeeper) {}\n\n  /**\n   * @dev Returns the role\n   * @return A bytes32 role\n   */\n  function role() public pure returns (bytes32) {\n    return ROLE_ADMIN;\n  }\n}\n"
    },
    "contracts/_library/tokens/ERC20/ERC20TokenConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"../../authentication/RoleRegistry.sol\";\nimport \"./ERC20Token.sol\";\n\ncontract ERC20TokenConverter {\n  // Needs the MINT_ROLE on the UnrestrictedCoin\n  // Needs the BURN_ROLE on the to be relayed coins\n\n  RoleRegistry roleRegistry;\n\n  event ConvertingTransfer(\n    address indexed _from,\n    address _fromToken,\n    address indexed _to,\n    address _toToken,\n    uint256 _amount\n  );\n\n  constructor(address _roleRegistry) {\n    roleRegistry = RoleRegistry(_roleRegistry);\n  }\n\n  function convert(\n    address _from,\n    address _fromToken,\n    address _to,\n    address _toToken,\n    uint256 _amount\n  ) public {\n    require(roleRegistry.hasRole(_to), \"_to needs to be an authorised party\");\n    require(_fromToken == msg.sender, \"_fromToken should be the sender\");\n    ERC20Token fromToken = ERC20Token(_fromToken);\n    require(fromToken.burn(_from, _amount), \"burn was unsuccesfull\");\n    ERC20Token toToken = ERC20Token(_toToken);\n    require(toToken.mint(_to, _amount), \"mint was unsuccesfull\");\n    emit ConvertingTransfer(_from, _fromToken, _to, _toToken, _amount);\n  }\n}\n"
    },
    "contracts/_library/tokencuratedregistry/ListingFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SettleMint.com\n/**\n * Copyright (C) SettleMint NV - All Rights Reserved\n *\n * Use of this file is strictly prohibited without an active license agreement.\n * Distribution of this file, via any medium, is strictly prohibited.\n *\n * For license inquiries, contact hello@settlemint.com\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IListingFactory.sol\";\n\nabstract contract ListingFactory is IListingFactory {\n  constructor(address _gateKeeper) IListingFactory(_gateKeeper) {}\n\n  function createListing(\n    address _owner,\n    uint256 _price,\n    uint256 _stakeAmount,\n    address _tcr,\n    string memory _metadata\n  ) public virtual override;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}